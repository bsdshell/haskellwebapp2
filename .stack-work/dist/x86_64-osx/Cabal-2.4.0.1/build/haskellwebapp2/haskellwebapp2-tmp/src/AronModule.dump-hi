
==================== FINAL INTERFACE ====================
2019-09-07 22:35:07.382129 UTC

interface main:AronModule [orphan module] [family instance module] 8065
  interface hash: 83c2e15fda622a636694728d75c005ba
  ABI hash: 01d8902e7f9c01a77ac76f926d25bc58
  export-list hash: 0a3bc963a01206f2c729d4f8f07cf5cb
  orphan hash: 23d37be7154809e219eac0010d548954
  flag hash: e320f36dc9d5615b4d3223f6e70f20d5
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  AronModule.<<<
  AronModule.addR
  AronModule.addRL
  AronModule.anagram
  AronModule.asplitPath
  AronModule.baseName
  AronModule.baseNameT
  AronModule.binarySearch
  AronModule.binsert
  AronModule.bs
  AronModule.buildTree
  AronModule.c2w_
  AronModule.cat
  AronModule.catMaybe
  AronModule.cc
  AronModule.cd
  AronModule.charToStrictByteString
  AronModule.clear
  AronModule.cmd
  AronModule.co
  AronModule.codeCapture
  AronModule.compileHaskellToBin
  AronModule.con
  AronModule.concatStr
  AronModule.containPrefix
  AronModule.containStr
  AronModule.containSuffix
  AronModule.containsTries
  AronModule.copyDir
  AronModule.copyFileToDir
  AronModule.copyRename
  AronModule.createFile
  AronModule.degreeToRadian
  AronModule.det
  AronModule.df
  AronModule.diag1
  AronModule.dim
  AronModule.dirModified
  AronModule.dirWalk
  AronModule.div'
  AronModule.divI
  AronModule.divR
  AronModule.divR'
  AronModule.drawInt
  AronModule.drawInteger
  AronModule.drop'
  AronModule.dropBS
  AronModule.dropEnd
  AronModule.eightQueen
  AronModule.en
  AronModule.eps
  AronModule.escapeHtml
  AronModule.evens
  AronModule.fExist
  AronModule.fe
  AronModule.ff
  AronModule.filtermap
  AronModule.findBalance
  AronModule.fl
  AronModule.fpp
  AronModule.fs
  AronModule.fw
  AronModule.g
  AronModule.geneMat
  AronModule.geneMat1ToN
  AronModule.geneMatMN
  AronModule.getLocalDate
  AronModule.getOS
  AronModule.getPwd
  AronModule.getTime
  AronModule.getVec
  AronModule.getX
  AronModule.getY
  AronModule.gotoCurrDir
  AronModule.groupCount
  AronModule.head'
  AronModule.help
  AronModule.ident
  AronModule.ident'
  AronModule.identS
  AronModule.im
  AronModule.inorder
  AronModule.insertFromList
  AronModule.insertNode
  AronModule.insertTries
  AronModule.insertTriesList
  AronModule.intToString
  AronModule.interleave
  AronModule.invR
  AronModule.inverse
  AronModule.isBST
  AronModule.isBalanced
  AronModule.isBalanced2
  AronModule.isDir
  AronModule.isEmpty
  AronModule.isFile
  AronModule.isInver
  AronModule.isInvertible
  AronModule.isWord
  AronModule.iterateList
  AronModule.lazyByteStringToLazyText
  AronModule.lazyByteStringToStrictByteString
  AronModule.lazyTextToLazyByteString
  AronModule.lazyTextToStr
  AronModule.lazyTextToStrictText
  AronModule.lca
  AronModule.leftDiagonal
  AronModule.len
  AronModule.listAdd
  AronModule.listDirFilter
  AronModule.listDot
  AronModule.listDots
  AronModule.listMul
  AronModule.listNeg
  AronModule.listScale
  AronModule.listSub
  AronModule.ls
  AronModule.lsFile
  AronModule.lsFileFull
  AronModule.lsFullRegex
  AronModule.lsRegex
  AronModule.lsRegexFull
  AronModule.mag
  AronModule.mat
  AronModule.mat'
  AronModule.matDiv
  AronModule.matr
  AronModule.maxlen
  AronModule.mergeList
  AronModule.mergeListLen
  AronModule.mergeListList
  AronModule.mergeSort
  AronModule.mergeSortC
  AronModule.mergeSortList
  AronModule.mergeSortM
  AronModule.mkdir
  AronModule.mkdirp
  AronModule.mlist
  AronModule.multR
  AronModule.multRL
  AronModule.multiMat
  AronModule.multiMatDouble
  AronModule.multiMatInt
  AronModule.multiMatR
  AronModule.multiRatMat
  AronModule.mv
  AronModule.mvFile
  AronModule.mvFiles
  AronModule.nToFractMat
  AronModule.nToNumMat
  AronModule.negList
  AronModule.negR
  AronModule.normList
  AronModule.normR
  AronModule.normalR
  AronModule.odds
  AronModule.oneRoot
  AronModule.orgList
  AronModule.orgTable
  AronModule.outer
  AronModule.outerStr
  AronModule.p
  AronModule.pa
  AronModule.paa
  AronModule.parseFileBlock
  AronModule.partList
  AronModule.partList2
  AronModule.pathBase
  AronModule.perm
  AronModule.perm2
  AronModule.perm3
  AronModule.pf
  AronModule.pm
  AronModule.pp
  AronModule.ppad
  AronModule.pre
  AronModule.prefix
  AronModule.prime
  AronModule.principleSubmatrix
  AronModule.proj
  AronModule.projn
  AronModule.ps
  AronModule.putStrBS
  AronModule.putStrLnBS
  AronModule.pw
  AronModule.pwd
  AronModule.qqsort
  AronModule.qrDecompose'
  AronModule.quickSort
  AronModule.quickSort'
  AronModule.quickSort1
  AronModule.quickSortAny
  AronModule.rMatrixUpperTri
  AronModule.rToRatMat
  AronModule.radianToDegree
  AronModule.randomDouble
  AronModule.randomFloat
  AronModule.randomFrac
  AronModule.randomList
  AronModule.randomMatrix
  AronModule.ratToInt
  AronModule.re
  AronModule.readConfig
  AronModule.readFileLatin1
  AronModule.readFileLatin1ToList
  AronModule.readFileRemote
  AronModule.readFileRemoteToList
  AronModule.readFileToList
  AronModule.readSnippet
  AronModule.redisExtractAronModule
  AronModule.redisExtractJavaMethod
  AronModule.reduce
  AronModule.reduceForm
  AronModule.rejection
  AronModule.removeIndex
  AronModule.removeRowCol
  AronModule.removeSpace
  AronModule.rename
  AronModule.renameAllFile
  AronModule.rep2d
  AronModule.repeat'
  AronModule.repeatN
  AronModule.replaceList
  AronModule.replicate'
  AronModule.reverseWord
  AronModule.rf
  AronModule.rightDiagonal
  AronModule.rm
  AronModule.rmDir
  AronModule.rootList
  AronModule.run
  AronModule.run'
  AronModule.rw
  AronModule.scaleList
  AronModule.searchReplace
  AronModule.sentence
  AronModule.sfilter
  AronModule.sleep
  AronModule.sleepSec
  AronModule.sort
  AronModule.sortRow
  AronModule.splitBS
  AronModule.splitBlock
  AronModule.splitList
  AronModule.splitListEmptyLine
  AronModule.splitPathA
  AronModule.splitR
  AronModule.splitStr
  AronModule.splitStrChar
  AronModule.splitStrT
  AronModule.sqVec
  AronModule.sqrtC
  AronModule.sqrtC'
  AronModule.strCompareIC
  AronModule.strToLazyByteString
  AronModule.strToLazyText
  AronModule.strToStrictByteString
  AronModule.strToStrictText
  AronModule.strictBSToString
  AronModule.strictByteStringToLazyByteString
  AronModule.strictByteStringToStrictText
  AronModule.strictTextToLazyText
  AronModule.strictTextToStr
  AronModule.strictTextToStrictByteString
  AronModule.stringToInt
  AronModule.subR
  AronModule.subRL
  AronModule.sumLeft
  AronModule.sumRatList
  AronModule.sumRight
  AronModule.sym
  AronModule.sys
  AronModule.t1
  AronModule.t2
  AronModule.t3
  AronModule.take'
  AronModule.takeBS
  AronModule.takeEnd
  AronModule.takeFileNameT
  AronModule.tangent
  AronModule.tangentVec
  AronModule.textArea
  AronModule.timeNowMicro
  AronModule.timeNowMilli
  AronModule.timeNowNano
  AronModule.timeNowPico
  AronModule.timeNowSecond
  AronModule.toCard
  AronModule.toLowerStr
  AronModule.toPolar
  AronModule.toStrictBS
  AronModule.toUpperStr
  AronModule.tran
  AronModule.tri
  AronModule.trim
  AronModule.trimAll
  AronModule.trimBoth
  AronModule.trimEnd
  AronModule.trimStart
  AronModule.trimT
  AronModule.trimWS
  AronModule.tuplify2
  AronModule.tuplify3
  AronModule.unique
  AronModule.unwrap
  AronModule.upperTri
  AronModule.upperTri'
  AronModule.uptri
  AronModule.vcol
  AronModule.vimLink
  AronModule.vrow
  AronModule.watchDir
  AronModule.wf
  AronModule.wfs
  AronModule.word
  AronModule.writeFileBS
  AronModule.writeFileList
  AronModule.writeFileListBS
  AronModule.writeToFile
  AronModule.writeToFile2dMat
  AronModule.writeToFileAppend
  AronModule.writeToFileMat
  AronModule.zipWith2
  AronModule.Add{AronModule.SumTy AronModule.addd}
  AronModule.C{AronModule.C x y}
  AronModule.Cnum{AronModule._cos AronModule._sin AronModule._sqrt}
  AronModule.Dnum{AronModule.DivType AronModule._div}
  AronModule.GPoint{AronModule.GPoint}
  AronModule.Mat{AronModule.Id AronModule.Zero}
  AronModule.Quaternion{AronModule.Quaternion a b c d}
  AronModule.Tree{AronModule.Empty AronModule.Node}
  AronModule.XNode{AronModule.XNode}
module dependencies:
package dependencies: ansi-terminal-0.8.2 array-0.5.3.0
                      asn1-encoding-0.9.5 asn1-parse-0.9.4 asn1-types-0.3.3 async-2.2.2
                      base-4.12.0.0 basement-0.0.10 binary-0.8.6.0 blaze-builder-0.4.1.0
                      bytestring-0.10.8.2 case-insensitive-1.2.0.11 cereal-0.5.8.1
                      colour-2.3.5 conduit-1.3.1.1 connection-0.2.8 containers-0.6.0.1
                      cookie-0.4.4 cryptonite-0.25 data-default-class-0.1.2.0
                      deepseq-1.4.4.0 directory-1.3.3.0 exceptions-0.10.2
                      filepath-1.4.2.1 ghc-boot-th-8.6.5 ghc-prim-0.5.3 hashable-1.2.7.0
                      hourglass-0.2.12 http-client-0.5.14 http-client-tls-0.3.5.3
                      http-conduit-2.3.7.1 http-types-0.12.3 integer-gmp-1.0.2.0
                      memory-0.14.18 mtl-2.2.2 network-2.8.0.1 network-uri-2.6.1.0
                      parsec-3.1.13.0 pem-0.2.4 pretty-simple-2.2.0.1 primitive-0.6.4.0
                      process-1.6.5.0 random-1.1 regex-base-0.93.2 regex-compat-0.95.1
                      regex-posix-0.95.2 regex-tdfa-1.2.3.2 resourcet-1.2.2 socks-0.5.6
                      split-0.2.3.3 stm-2.5.0.0 streaming-commons-0.2.1.1
                      template-haskell-2.14.0.0 text-1.2.3.1 time-1.8.0.2 tls-1.4.1
                      transformers-0.5.6.2 unix-2.7.2.2 unliftio-core-0.1.2.0
                      unordered-containers-0.2.10.0 utf8-string-1.0.1.1 vector-0.12.0.3
                      x509-1.7.5 x509-store-1.6.7 x509-system-1.6.6
                      x509-validation-1.6.11 zlib-0.6.2
orphans: colour-2.3.5:Data.Colour
         http-client-0.5.14:Network.HTTP.Client.Request
         basement-0.0.10:Basement.UArray.Base basement-0.0.10:Basement.Block
         network-2.8.0.1:Network.Socket stm-2.5.0.0:Control.Monad.STM
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         vector-0.12.0.3:Data.Vector.Fusion.Bundle
         hashable-1.2.7.0:Data.Hashable.Generic
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.ByteString
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.ByteString.Lazy
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.Sequence
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.String
         transformers-0.5.6.2:Control.Monad.Trans.Error
         regex-posix-0.95.2:Text.Regex.Posix.String
         regex-posix-0.95.2:Text.Regex.Posix.Sequence
         regex-posix-0.95.2:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2:Text.Regex.Posix.ByteString
         regex-base-0.93.2:Text.Regex.Base.Context
         text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         basement-0.0.10:Basement.Block.Base
                         basement-0.0.10:Basement.Bounded basement-0.0.10:Basement.Monad
                         basement-0.0.10:Basement.MutableBuilder
                         basement-0.0.10:Basement.Nat basement-0.0.10:Basement.NonEmpty
                         basement-0.0.10:Basement.Numerical.Subtractive
                         basement-0.0.10:Basement.PrimType basement-0.0.10:Basement.String
                         basement-0.0.10:Basement.String.Encoding.ASCII7
                         basement-0.0.10:Basement.String.Encoding.ISO_8859_1
                         basement-0.0.10:Basement.String.Encoding.UTF16
                         basement-0.0.10:Basement.String.Encoding.UTF32
                         basement-0.0.10:Basement.Types.OffsetSize
                         basement-0.0.10:Basement.UArray.Base
                         basement-0.0.10:Basement.UTF8.Base
                         conduit-1.3.1.1:Data.Conduit.Internal.Conduit
                         conduit-1.3.1.1:Data.Conduit.Internal.Pipe
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         cryptonite-0.25:Crypto.ECC cryptonite-0.25:Crypto.Error.Types
                         cryptonite-0.25:Crypto.Hash.Blake2
                         cryptonite-0.25:Crypto.Hash.Blake2b
                         cryptonite-0.25:Crypto.Hash.Blake2bp
                         cryptonite-0.25:Crypto.Hash.Blake2s
                         cryptonite-0.25:Crypto.Hash.Blake2sp
                         cryptonite-0.25:Crypto.Hash.Keccak cryptonite-0.25:Crypto.Hash.MD2
                         cryptonite-0.25:Crypto.Hash.MD4 cryptonite-0.25:Crypto.Hash.MD5
                         cryptonite-0.25:Crypto.Hash.RIPEMD160
                         cryptonite-0.25:Crypto.Hash.SHA1 cryptonite-0.25:Crypto.Hash.SHA224
                         cryptonite-0.25:Crypto.Hash.SHA256 cryptonite-0.25:Crypto.Hash.SHA3
                         cryptonite-0.25:Crypto.Hash.SHA384
                         cryptonite-0.25:Crypto.Hash.SHA512
                         cryptonite-0.25:Crypto.Hash.SHA512t
                         cryptonite-0.25:Crypto.Hash.SHAKE
                         cryptonite-0.25:Crypto.Hash.Skein256
                         cryptonite-0.25:Crypto.Hash.Skein512
                         cryptonite-0.25:Crypto.Hash.Tiger
                         cryptonite-0.25:Crypto.Hash.Whirlpool
                         ghc-boot-th-8.6.5:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.5:GHC.LanguageExtensions.Type
                         http-client-0.5.14:Network.HTTP.Client
                         network-uri-2.6.1.0:Network.URI
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.Color
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.Expr
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.ExprToOutput
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.Output
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.OutputPrinter
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         resourcet-1.2.2:Control.Monad.Trans.Resource.Internal
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unordered-containers-0.2.10.0:Data.HashMap.Base
                         unordered-containers-0.2.10.0:Data.HashSet.Base
                         vector-0.12.0.3:Data.Vector
                         zlib-0.6.2:Codec.Compression.Zlib.Stream
import  -/  array-0.5.3.0:Data.Array 92f4b3399a96adb44649ce9a9d6cd419
import  -/  base-4.12.0.0:Control.Concurrent 945d3c1c41ed03e6117e3861cad65d9f
import  -/  base-4.12.0.0:Control.Monad 07eaec7fd256019b318d048d00f45b1c
import  -/  base-4.12.0.0:Data.Char 74f67fe9150a102afa18766e840f6832
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.List 17d0c71c557e42abe196f130788fd997
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:Data.Ratio ca7795f81c201f83d6159a8388bb75b9
import  -/  base-4.12.0.0:Data.Traversable d2c09bff1e4f0c871306c3ff8aa4dc36
import  -/  base-4.12.0.0:Data.Tuple c719fc29608fe81c10bee9a1bf1e05ff
import  -/  base-4.12.0.0:Data.Word 6b968b6c7df442cfcad986e497aee095
import  -/  base-4.12.0.0:Debug.Trace 60f75ad789dcddb29321db1cb21ccd4c
import  -/  base-4.12.0.0:GHC.Arr ec26aa94fff9ed31a6fa85d884b35f3c
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Conc.IO 32e1704711ef19bc91e5b7c0d3a5cfa2
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.Float ccb68fbeaab348f60d11c8132d51af5d
import  -/  base-4.12.0.0:GHC.IO 898d4ddbf00eb4732e5f462760aa42ae
import  -/  base-4.12.0.0:GHC.IO.Encoding 5eddf37c1e942b3a4e0865c5cf981a13
import  -/  base-4.12.0.0:GHC.IO.Exception 77722984940ee6ccf9e2f7dab10b83a4
import  -/  base-4.12.0.0:GHC.IO.Handle fe51659cf05ea3ecd36fe5e2d515d89a
import  -/  base-4.12.0.0:GHC.IO.Handle.FD 815f4d400e6239c7550e040518bdbf45
import  -/  base-4.12.0.0:GHC.IO.Handle.Text 182a34cefe4f282196178eec37b94471
import  -/  base-4.12.0.0:GHC.IO.IOMode 8012a3f94976206c971b9384804b372a
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:GHC.Unicode 87726eb81a3f9c9b22160a0afd5dc56a
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:System.Environment c54e0d0308e729fdace6bc37aa74bb52
import  -/  base-4.12.0.0:System.Exit 3c945ec7c596067c067092c41083c3d0
import  -/  base-4.12.0.0:System.IO c961e5ee6731c0683a6e879272c9e9f6
import  -/  base-4.12.0.0:System.Posix.Types f584192f89d47f3750707514ba65c3f8
import  -/  base-4.12.0.0:Text.Printf d9e1f32eb8aa55bafa1cf4360210b275
import  -/  base-4.12.0.0:Text.Read 87f80fc2538a174aea915dd98f74fc0a
import  -/  bytestring-0.10.8.2:Data.ByteString fc40bec3e4fb10b918937406130fe77a
import  -/  bytestring-0.10.8.2:Data.ByteString.Char8 40491ceac5d0f84d2a7f4a84fd2dd3ab
import  -/  bytestring-0.10.8.2:Data.ByteString.Internal ff13c732dcda19b677c2f5e999517616
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy 2f1c3e7310d730fefed76cfb6092806e
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy.Char8 ee271bbed336425979c30600663f1b4d
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy.Internal 8ceea8f415ed041d41a5a276316e69bb
import  -/  containers-0.6.0.1:Data.Set afd5ab7eac5658da18a4fffc2d1b683c
import  -/  containers-0.6.0.1:Data.Set.Internal a9b0d2c3208f9a74ef7f480a7813af2a
import  -/  directory-1.3.3.0:System.Directory 49a915596c61b7c4c6db58cd4e1272c2
import  -/  filepath-1.4.2.1:System.FilePath.Posix 807571ae31e154c61d0c6bb61ff8b097
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  http-conduit-2.3.7.1:Network.HTTP.Conduit a54e444689787e81aa6705be9208f27e
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 6d87087aea24143d2650f78480d954a3
import  -/  pretty-simple-2.2.0.1:Text.Pretty.Simple 707b2bc6f116ea6d674407fd8950002a
import  -/  process-1.6.5.0:System.Process 2e810cee2a417b14ed03c6fbb00362a9
import  -/  process-1.6.5.0:System.Process.Common 4971a958b3afdd38bd752a68ac80c12a
import  -/  random-1.1:System.Random 92935f2739d08d3c469b92fe5ac17118
import  -/  regex-base-0.93.2:Text.Regex.Base 38db9417236ed3a9eb5d5959c0551869
import  -/  regex-base-0.93.2:Text.Regex.Base.RegexLike fa2c0de5c64e014d2ef6fd2421527991
import  -/  regex-compat-0.95.1:Text.Regex 7217c00d13a781e2337d1a1f0f474b2e
import  -/  regex-posix-0.95.2:Text.Regex.Posix c4d3a6df4cf5fd30c7c141af2e1ceba1
import  -/  regex-tdfa-1.2.3.2:Text.Regex.TDFA 1f5520f04edc87777baa08ec77ad505b
import  -/  regex-tdfa-1.2.3.2:Text.Regex.TDFA.Common d66684ad95679f8e227959c9fac7afb3
import  -/  split-0.2.3.3:Data.List.Split 3518b4851dc357bd81ca9eb7a13694f0
import  -/  split-0.2.3.3:Data.List.Split.Internals b4ab8dde94aedb7514b1f8d89c369cbe
import  -/  text-1.2.3.1:Data.Text 681b9c3df5b4e4b4e23ef5f840f0b692
import  -/  text-1.2.3.1:Data.Text.Encoding 90a09b7eff84aa60662c467f3d3a3a73
import  -/  text-1.2.3.1:Data.Text.Internal 537e168590e8068f673f691833f78483
import  -/  text-1.2.3.1:Data.Text.Internal.Lazy 60724f417edac0a71b3efdb9a450a954
import  -/  text-1.2.3.1:Data.Text.Lazy 5dfd4775189d1cf6b5f168bbf44e9081
import  -/  text-1.2.3.1:Data.Text.Lazy.Encoding 54d8a57ac2b9488e6671150dcf5d5643
import  -/  text-1.2.3.1:Data.Text.Show b788b7edd0f190b1a7c4f4aba0e35f18
import  -/  time-1.8.0.2:Data.Time f6ff4096de7c69ad22c2a67f4dd509e4
import  -/  time-1.8.0.2:Data.Time.Clock.POSIX 9cecc2051debab576bd5d468a9a020cc
import  -/  time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime fd06ee93564026f9847fb4d314327b91
import  -/  time-1.8.0.2:Data.Time.LocalTime.Internal.TimeOfDay 269703c5d705425fe67c405f6d60838e
import  -/  time-1.8.0.2:Data.Time.LocalTime.Internal.TimeZone a9973b8829e07378372866c701ab5ba5
import  -/  time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime 6189345cc0c6b1a86921f052f5066e3e
import  -/  unix-2.7.2.2:System.Posix.Files 8b4394d70ac72397a0a2e65b696ae5fc
import  -/  unix-2.7.2.2:System.Posix.Files.Common 48c599450545932cbafbc488bf5d48a8
import  -/  unix-2.7.2.2:System.Posix.Unistd df669442b24f9247b1a8d9f5004b6b19
import  -/  unordered-containers-0.2.10.0:Data.HashMap.Base b666983525a9fb01e24fb8a55df5d8dd
import  -/  unordered-containers-0.2.10.0:Data.HashMap.Strict 14aa6b14c186f36ceb9dd8a7757e3d8e
import  -/  unordered-containers-0.2.10.0:Data.HashMap.Strict.Base 6e0d0383757a8ba89fde11fc481190de
import  -/  utf8-string-1.0.1.1:Data.ByteString.Lazy.UTF8 f5b0a832db1bd1f54d51a8a6303c888b
import  -/  utf8-string-1.0.1.1:Data.ByteString.UTF8 695d13a27a7b1ff88bf5105edcca8ef2
import  -/  vector-0.12.0.3:Data.Vector c0c0d9d6b460ae754b065c5a1411482b
fixities infixl 1 <<<
09de7967b7fa68ac333932f144982214
  $fAddDoubleInt :: AronModule.Add GHC.Types.Double GHC.Types.Int
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fAddDoubleInt1
                  `cast`
                ((<GHC.Types.Double>_R
                  ->_R <GHC.Types.Int>_R
                  ->_R Sub (Sym (AronModule.D:R:SumTyDoubleInt[0]))) ; Sym (AronModule.N:Add[0]
                                                                                <GHC.Types.Double>_N
                                                                                <GHC.Types.Int>_N)) -}
9142851deb5a488c0d4453be10a55ff5
  $fAddDoubleInt1 ::
    GHC.Types.Double -> GHC.Types.Int -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: GHC.Types.Double) (y1 :: GHC.Types.Int) ->
                 case x1 of wild { GHC.Types.D# x2 ->
                 case y1 of wild1 { GHC.Types.I# i ->
                 GHC.Types.D# (GHC.Prim.+## x2 (GHC.Prim.int2Double# i)) } }) -}
09de7967b7fa68ac333932f144982214
  $fAddDoubleInteger ::
    AronModule.Add GHC.Types.Double GHC.Integer.Type.Integer
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,1*U>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fAddDoubleInteger1
                  `cast`
                ((<GHC.Types.Double>_R
                  ->_R <GHC.Integer.Type.Integer>_R
                  ->_R Sub (Sym (AronModule.D:R:SumTyDoubleInteger[0]))) ; Sym (AronModule.N:Add[0]
                                                                                    <GHC.Types.Double>_N
                                                                                    <GHC.Integer.Type.Integer>_N)) -}
6b452962bad3f0dc503e5e764794f69b
  $fAddDoubleInteger1 ::
    GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: GHC.Types.Double) (y1 :: GHC.Integer.Type.Integer) ->
                 case x1 of wild { GHC.Types.D# x2 ->
                 case GHC.Integer.Type.doubleFromInteger y1 of wild1 { DEFAULT ->
                 GHC.Types.D# (GHC.Prim.+## x2 wild1) } }) -}
09de7967b7fa68ac333932f144982214
  $fAddIntDouble :: AronModule.Add GHC.Types.Int GHC.Types.Double
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fAddIntDouble1
                  `cast`
                ((<GHC.Types.Int>_R
                  ->_R <GHC.Types.Double>_R
                  ->_R Sub (Sym (AronModule.D:R:SumTyIntDouble[0]))) ; Sym (AronModule.N:Add[0]
                                                                                <GHC.Types.Int>_N
                                                                                <GHC.Types.Double>_N)) -}
133ce09a04eeb38e1e4cca4350552e27
  $fAddIntDouble1 ::
    GHC.Types.Int -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: GHC.Types.Int) (y1 :: GHC.Types.Double) ->
                 case x1 of wild { GHC.Types.I# i ->
                 case y1 of wild1 { GHC.Types.D# y2 ->
                 GHC.Types.D# (GHC.Prim.+## (GHC.Prim.int2Double# i) y2) } }) -}
09de7967b7fa68ac333932f144982214
  $fAddIntegerDouble ::
    AronModule.Add GHC.Integer.Type.Integer GHC.Types.Double
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fAddIntegerDouble1
                  `cast`
                ((<GHC.Integer.Type.Integer>_R
                  ->_R <GHC.Types.Double>_R
                  ->_R Sub (Sym (AronModule.D:R:SumTyIntegerDouble[0]))) ; Sym (AronModule.N:Add[0]
                                                                                    <GHC.Integer.Type.Integer>_N
                                                                                    <GHC.Types.Double>_N)) -}
800d46712c3c6d9c39a572d9b04658c5
  $fAddIntegerDouble1 ::
    GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: GHC.Integer.Type.Integer) (y1 :: GHC.Types.Double) ->
                 case GHC.Integer.Type.doubleFromInteger x1 of wild { DEFAULT ->
                 case y1 of wild1 { GHC.Types.D# y2 ->
                 GHC.Types.D# (GHC.Prim.+## wild y2) } }) -}
09de7967b7fa68ac333932f144982214
  $fAddaa :: GHC.Num.Num a => AronModule.Add a a
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (x1 :: a1) (y1 :: a1) ->
                 GHC.Num.+ @ a1 $dNum x1 y1)
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R (<a1>_R
                       ->_R <a1>_R
                       ->_R Sub (Sym (AronModule.D:R:SumTyaa[0]
                                          <a1>_N))) ; Sym (AronModule.N:Add[0] <a1>_N <a1>_N)) -}
1ab116b66d03e62dd6e88c3c7847d493
  $fCnumDouble :: AronModule.Cnum GHC.Types.Double
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.Double
                  AronModule.$fCnumDouble_$c_sqrt
                  AronModule.$fCnumDouble_$c_sin
                  AronModule.$fCnumDouble_$c_cos -}
7cdbc04c135e63bbd16b08fcae342f22
  $fCnumDouble_$c_cos :: GHC.Types.Double -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Double) ->
                 case n of wild { GHC.Types.D# x1 ->
                 GHC.Types.F# (GHC.Prim.cosFloat# (GHC.Prim.double2Float# x1)) }) -}
048a880701008ff4d26a99af51e83963
  $fCnumDouble_$c_sin :: GHC.Types.Double -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Double) ->
                 case n of wild { GHC.Types.D# x1 ->
                 GHC.Types.F# (GHC.Prim.sinFloat# (GHC.Prim.double2Float# x1)) }) -}
ca0a267174bfefe447ed00736538665d
  $fCnumDouble_$c_sqrt :: GHC.Types.Double -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Double) ->
                 case n of wild { GHC.Types.D# x1 ->
                 GHC.Types.F#
                   (GHC.Prim.sqrtFloat# (GHC.Prim.double2Float# x1)) }) -}
1ab116b66d03e62dd6e88c3c7847d493
  $fCnumFloat :: AronModule.Cnum GHC.Types.Float
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.Float
                  GHC.Float.sqrtFloat
                  GHC.Float.sinFloat
                  GHC.Float.cosFloat -}
1ab116b66d03e62dd6e88c3c7847d493
  $fCnumInt :: AronModule.Cnum GHC.Types.Int
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.Int
                  AronModule.$fCnumInt_$c_sqrt
                  AronModule.$fCnumInt_$c_sin
                  AronModule.$fCnumInt_$c_cos -}
7459109052734db448d24f52c1c885ed
  $fCnumInt_$c_cos :: GHC.Types.Int -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 case n of wild { GHC.Types.I# i ->
                 GHC.Types.F# (GHC.Prim.cosFloat# (GHC.Prim.int2Float# i)) }) -}
b60a6338e93a308904312b72a8a059f9
  $fCnumInt_$c_sin :: GHC.Types.Int -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 case n of wild { GHC.Types.I# i ->
                 GHC.Types.F# (GHC.Prim.sinFloat# (GHC.Prim.int2Float# i)) }) -}
6716d07e427b1295cede3ff833833977
  $fCnumInt_$c_sqrt :: GHC.Types.Int -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 case n of wild { GHC.Types.I# i ->
                 GHC.Types.F# (GHC.Prim.sqrtFloat# (GHC.Prim.int2Float# i)) }) -}
1ab116b66d03e62dd6e88c3c7847d493
  $fCnumInteger :: AronModule.Cnum GHC.Integer.Type.Integer
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Integer.Type.Integer
                  AronModule.$fCnumInteger_$c_sqrt
                  AronModule.$fCnumInteger_$c_sin
                  AronModule.$fCnumInteger_$c_cos -}
579e7a60f1b64635d7a19ec752b8c566
  $fCnumInteger_$c_cos :: GHC.Integer.Type.Integer -> GHC.Types.Float
  {- Arity: 1, Strictness: <S,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Integer.Type.Integer) ->
                 case n of dt { DEFAULT ->
                 case GHC.Float.rationalToFloat
                        dt
                        GHC.Real.$fEnumRatio1 of wild { GHC.Types.F# x1 ->
                 GHC.Types.F# (GHC.Prim.cosFloat# x1) } }) -}
98a26907b6af74312e0312eb56f4ccf2
  $fCnumInteger_$c_sin :: GHC.Integer.Type.Integer -> GHC.Types.Float
  {- Arity: 1, Strictness: <S,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Integer.Type.Integer) ->
                 case n of dt { DEFAULT ->
                 case GHC.Float.rationalToFloat
                        dt
                        GHC.Real.$fEnumRatio1 of wild { GHC.Types.F# x1 ->
                 GHC.Types.F# (GHC.Prim.sinFloat# x1) } }) -}
1e586e3cda8b8aa15894baccea05f2d2
  $fCnumInteger_$c_sqrt ::
    GHC.Integer.Type.Integer -> GHC.Types.Float
  {- Arity: 1, Strictness: <S,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Integer.Type.Integer) ->
                 case n of dt { DEFAULT ->
                 case GHC.Float.rationalToFloat
                        dt
                        GHC.Real.$fEnumRatio1 of wild { GHC.Types.F# x1 ->
                 GHC.Types.F# (GHC.Prim.sqrtFloat# x1) } }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumDoubleInt :: AronModule.Dnum GHC.Types.Double GHC.Types.Int
  DFunId
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumDoubleInt_$c_div
                  `cast`
                (Sym (AronModule.N:Dnum[0]
                          <GHC.Types.Double>_N <GHC.Types.Int>_N)) -}
a39fd3cf33c337a1ecc953f4f7c78e55
  $fDnumDoubleInt1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumDoubleInt_$c_div ::
    GHC.Types.Double
    -> GHC.Types.Int
    -> AronModule.DivType GHC.Types.Double GHC.Types.Int
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Double) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.D# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 AronModule.$w$c_div ww1 ww3 } }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumDoubleInteger ::
    AronModule.Dnum GHC.Types.Double GHC.Integer.Type.Integer
  DFunId
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumDoubleInteger1
                  `cast`
                ((<GHC.Types.Double>_R
                  ->_R <GHC.Integer.Type.Integer>_R
                  ->_R Sub (Sym (AronModule.D:R:DivTypeDoubleInteger[0]))) ; Sym (AronModule.N:Dnum[0]
                                                                                      <GHC.Types.Double>_N
                                                                                      <GHC.Integer.Type.Integer>_N)) -}
f1d9ed5b16a40d5ca1b5f74650ec6846
  $fDnumDoubleInteger1 ::
    GHC.Types.Double
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Double) (w1 :: GHC.Integer.Type.Integer) ->
                 case w of ww { GHC.Types.D# ww1 ->
                 AronModule.$w$c_div1 ww1 w1 }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumFloatInt :: AronModule.Dnum GHC.Types.Float GHC.Types.Int
  DFunId
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumFloatInt_$c_div
                  `cast`
                (Sym (AronModule.N:Dnum[0]
                          <GHC.Types.Float>_N <GHC.Types.Int>_N)) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumFloatInt_$c_div ::
    GHC.Types.Float
    -> GHC.Types.Int
    -> AronModule.DivType GHC.Types.Float GHC.Types.Int
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.F# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 AronModule.$w$c_div2 ww1 ww3 } }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumFloatInteger ::
    AronModule.Dnum GHC.Types.Float GHC.Integer.Type.Integer
  DFunId
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumFloatInteger1
                  `cast`
                ((<GHC.Types.Float>_R
                  ->_R <GHC.Integer.Type.Integer>_R
                  ->_R Sub (Sym (AronModule.D:R:DivTypeFloatInteger[0]))) ; Sym (AronModule.N:Dnum[0]
                                                                                     <GHC.Types.Float>_N
                                                                                     <GHC.Integer.Type.Integer>_N)) -}
bd49efd7f4d0b57f2da8dad0211d3fa1
  $fDnumFloatInteger1 ::
    GHC.Types.Float
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: GHC.Integer.Type.Integer) ->
                 case w of ww { GHC.Types.F# ww1 ->
                 AronModule.$w$c_div3 ww1 w1 }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumIntFloat :: AronModule.Dnum GHC.Types.Int GHC.Types.Float
  DFunId
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumIntFloat_$c_div
                  `cast`
                (Sym (AronModule.N:Dnum[0]
                          <GHC.Types.Int>_N <GHC.Types.Float>_N)) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumIntFloat_$c_div ::
    GHC.Types.Int
    -> GHC.Types.Float
    -> AronModule.DivType GHC.Types.Int GHC.Types.Float
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Float) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.F# ww3 ->
                 AronModule.$w$c_div4 ww1 ww3 } }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumIntegerDouble ::
    AronModule.Dnum GHC.Integer.Type.Integer GHC.Types.Double
  DFunId
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumIntegerDouble_$c_div
                  `cast`
                (Sym (AronModule.N:Dnum[0]
                          <GHC.Integer.Type.Integer>_N <GHC.Types.Double>_N)) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumIntegerDouble_$c_div ::
    GHC.Integer.Type.Integer
    -> GHC.Types.Double
    -> AronModule.DivType GHC.Integer.Type.Integer GHC.Types.Double
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Integer.Type.Integer) (w1 :: GHC.Types.Double) ->
                 case w1 of ww { GHC.Types.D# ww1 ->
                 AronModule.$w$c_div5 w ww1 }) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumIntegerFloat ::
    AronModule.Dnum GHC.Integer.Type.Integer GHC.Types.Float
  DFunId
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                AronModule.$fDnumIntegerFloat_$c_div
                  `cast`
                (Sym (AronModule.N:Dnum[0]
                          <GHC.Integer.Type.Integer>_N <GHC.Types.Float>_N)) -}
69d92da5d2e845bc4c67d166769fda73
  $fDnumIntegerFloat_$c_div ::
    GHC.Integer.Type.Integer
    -> GHC.Types.Float
    -> AronModule.DivType GHC.Integer.Type.Integer GHC.Types.Float
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Integer.Type.Integer) (w1 :: GHC.Types.Float) ->
                 case w1 of ww { GHC.Types.F# ww1 ->
                 AronModule.$w$c_div6 w ww1 }) -}
333978fdd88953d8934bc07531783829
  $fEqC :: GHC.Classes.Eq AronModule.C
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.C AronModule.$fEqC_$c== AronModule.$fEqC_$c/= -}
333978fdd88953d8934bc07531783829
  $fEqC_$c/= :: AronModule.C -> AronModule.C -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(LS(S)),1*U(A,1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.C) (w1 :: AronModule.C) ->
                 case w of ww { AronModule.C ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.F# ww4 ->
                 case w1 of ww5 { AronModule.C ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.F# ww9 ->
                 AronModule.$w$c/= ww4 ww2 ww9 } } } }) -}
333978fdd88953d8934bc07531783829
  $fEqC_$c== :: AronModule.C -> AronModule.C -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.C) (w1 :: AronModule.C) ->
                 case w of ww { AronModule.C ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.F# ww4 ->
                 case w1 of ww5 { AronModule.C ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.F# ww9 ->
                 AronModule.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fEqTree :: GHC.Classes.Eq a => GHC.Classes.Eq (AronModule.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a1 (v :: GHC.Classes.Eq a1).
                  @ (AronModule.Tree a1)
                  (AronModule.$fEqTree_$c== @ a1 v)
                  (AronModule.$fEqTree_$c/= @ a1 v) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fEqTree_$c/= ::
    GHC.Classes.Eq a =>
    AronModule.Tree a -> AronModule.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a1
                   ($dEq :: GHC.Classes.Eq a1)
                   (x1 :: AronModule.Tree a1)
                   (y1 :: AronModule.Tree a1) ->
                 case AronModule.$fEqTree_$c== @ a1 $dEq x1 y1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fEqTree_$c== ::
    GHC.Classes.Eq a =>
    AronModule.Tree a -> AronModule.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fEqXNode :: GHC.Classes.Eq AronModule.XNode
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.XNode
                  AronModule.$fEqXNode_$c==
                  AronModule.$fEqXNode_$c/= -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fEqXNode_$c/= ::
    AronModule.XNode -> AronModule.XNode -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x1 :: AronModule.XNode) (y1 :: AronModule.XNode) ->
                 case AronModule.$fEqXNode_$c== x1 y1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fEqXNode_$c== ::
    AronModule.XNode -> AronModule.XNode -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.XNode) (w1 :: AronModule.XNode) ->
                 case w of ww { AronModule.XNode ww1 ww2 ->
                 case w1 of ww3 { AronModule.XNode ww4 ww5 ->
                 AronModule.$w$c==1 ww1 ww2 ww4 ww5 } }) -}
333978fdd88953d8934bc07531783829
  $fNumC :: GHC.Num.Num AronModule.C
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.C
                  AronModule.$fNumC_$c+
                  AronModule.$fNumC_$c-
                  AronModule.$fNumC_$c*
                  AronModule.$fNumC_$cnegate
                  AronModule.$fNumC_$cabs
                  AronModule.$fNumC_$csignum
                  AronModule.$fNumC_$cfromInteger -}
4c78d21e433024b918f62634b0a7aa47
  $fNumC1 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 0.0#) -}
333978fdd88953d8934bc07531783829
  $fNumC_$c* :: AronModule.C -> AronModule.C -> AronModule.C
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U(U),1*U(U))><S,1*U(U(U),U(U))>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.C) (w1 :: AronModule.C) ->
                 case w of ww { AronModule.C ww1 ww2 ->
                 case w1 of ww3 { AronModule.C ww4 ww5 ->
                 AronModule.C
                   (case ww1 of wild { GHC.Types.F# x1 ->
                    case ww4 of wild1 { GHC.Types.F# y1 ->
                    case ww2 of wild2 { GHC.Types.F# x2 ->
                    case ww5 of wild3 { GHC.Types.F# y2 ->
                    GHC.Types.F#
                      (GHC.Prim.minusFloat#
                         (GHC.Prim.timesFloat# x1 y1)
                         (GHC.Prim.timesFloat# x2 y2)) } } } })
                   (case ww1 of wild { GHC.Types.F# x1 ->
                    case ww5 of wild1 { GHC.Types.F# y1 ->
                    case ww4 of wild2 { GHC.Types.F# x2 ->
                    GHC.Types.F#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.timesFloat# x1 y1)
                         (GHC.Prim.timesFloat# x2 y1)) } } }) } }) -}
333978fdd88953d8934bc07531783829
  $fNumC_$c+ :: AronModule.C -> AronModule.C -> AronModule.C
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: AronModule.C) (ds1 :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 ->
                 case ds1 of wild1 { AronModule.C x2 y2 ->
                 AronModule.C
                   (GHC.Float.plusFloat x1 x2)
                   (GHC.Float.plusFloat y1 y2) } }) -}
333978fdd88953d8934bc07531783829
  $fNumC_$c- :: AronModule.C -> AronModule.C -> AronModule.C
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: AronModule.C) (ds1 :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 ->
                 case ds1 of wild1 { AronModule.C x2 y2 ->
                 AronModule.C
                   (GHC.Float.minusFloat x1 x2)
                   (GHC.Float.minusFloat y1 y2) } }) -}
333978fdd88953d8934bc07531783829
  $fNumC_$cabs :: AronModule.C -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 ->
                 AronModule.C
                   (GHC.Float.fabsFloat x1)
                   (GHC.Float.fabsFloat y1) }) -}
333978fdd88953d8934bc07531783829
  $fNumC_$cfromInteger :: GHC.Integer.Type.Integer -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Integer.Type.Integer) ->
                 AronModule.C
                   (GHC.Float.$fNumFloat_$cfromInteger n)
                   AronModule.$fNumC1) -}
333978fdd88953d8934bc07531783829
  $fNumC_$cnegate :: AronModule.C -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),1*U(U))>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (x1 :: AronModule.C) ->
                 case x1 of wild { AronModule.C x2 y2 ->
                 AronModule.C
                   (case x2 of wild1 { GHC.Types.F# y1 ->
                    GHC.Types.F# (GHC.Prim.minusFloat# 0.0# y1) })
                   (case y2 of wild1 { GHC.Types.F# y1 ->
                    GHC.Types.F# (GHC.Prim.minusFloat# 0.0# y1) }) }) -}
333978fdd88953d8934bc07531783829
  $fNumC_$csignum :: AronModule.C -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 ->
                 AronModule.C
                   (GHC.Float.$fNumFloat_$csignum x1)
                   (GHC.Float.$fNumFloat_$csignum y1) }) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion :: GHC.Num.Num AronModule.Quaternion
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.Quaternion
                  AronModule.$fNumQuaternion_$c+
                  AronModule.$fNumQuaternion_$c-
                  AronModule.$fNumQuaternion_$c*
                  AronModule.$fNumQuaternion_$cnegate
                  AronModule.$fNumQuaternion_$cabs
                  AronModule.$fNumQuaternion_$csignum
                  AronModule.$fNumQuaternion_$cfromInteger -}
88692aa03849020516f7cbf7648700d1
  $fNumQuaternion1 :: GHC.Stack.Types.CallStack
  {- Strictness: m2,
     Unfolding: (GHC.Stack.Types.PushCallStack
                   AronModule.$fNumQuaternion12
                   AronModule.$fNumQuaternion2
                   GHC.Stack.Types.EmptyCallStack) -}
f5bf3e6bfebe49fdbff99d8c53ac2121
  $fNumQuaternion10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.$fNumQuaternion11) -}
efec0edf81f94a4cfad87677d53aac1a
  $fNumQuaternion11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
0467e7a399f824a8e5892ebd5d350c2a
  $fNumQuaternion12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.$fNumQuaternion13) -}
747c01e21baf7145284b2af212285417
  $fNumQuaternion13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("undefined"#) -}
852b53fc451f2e04b7469e4f203412c2
  $fNumQuaternion14 :: GHC.Stack.Types.CallStack
  {- Strictness: m2,
     Unfolding: (GHC.Stack.Types.PushCallStack
                   AronModule.$fNumQuaternion12
                   AronModule.$fNumQuaternion15
                   GHC.Stack.Types.EmptyCallStack) -}
0e994be087939204810cfabfa8ad1206
  $fNumQuaternion15 :: GHC.Stack.Types.SrcLoc
  {- Strictness: m,
     Unfolding: (GHC.Stack.Types.SrcLoc
                   AronModule.$fNumQuaternion10
                   AronModule.$fNumQuaternion8
                   AronModule.$fNumQuaternion6
                   AronModule.$fNumQuaternion16
                   AronModule.$fNumQuaternion4
                   AronModule.$fNumQuaternion16
                   AronModule.$fNumQuaternion3) -}
b2660e41093e33dbf9c49be17a5312d0
  $fNumQuaternion16 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 221#) -}
a0194bd9f5d53c95169a7d9ce1d6a944
  $fNumQuaternion17 :: GHC.Stack.Types.CallStack
  {- Strictness: m2,
     Unfolding: (GHC.Stack.Types.PushCallStack
                   AronModule.$fNumQuaternion12
                   AronModule.$fNumQuaternion18
                   GHC.Stack.Types.EmptyCallStack) -}
57eadfacbb4c23d7828bf4c07ef463b8
  $fNumQuaternion18 :: GHC.Stack.Types.SrcLoc
  {- Strictness: m,
     Unfolding: (GHC.Stack.Types.SrcLoc
                   AronModule.$fNumQuaternion10
                   AronModule.$fNumQuaternion8
                   AronModule.$fNumQuaternion6
                   AronModule.$fNumQuaternion19
                   AronModule.$fNumQuaternion4
                   AronModule.$fNumQuaternion19
                   AronModule.$fNumQuaternion3) -}
3f3dbb5c467cb8894daab25bd928fdd5
  $fNumQuaternion19 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 220#) -}
8a31de566fda524a7ca593f3980db21b
  $fNumQuaternion2 :: GHC.Stack.Types.SrcLoc
  {- Strictness: m,
     Unfolding: (GHC.Stack.Types.SrcLoc
                   AronModule.$fNumQuaternion10
                   AronModule.$fNumQuaternion8
                   AronModule.$fNumQuaternion6
                   AronModule.$fNumQuaternion5
                   AronModule.$fNumQuaternion4
                   AronModule.$fNumQuaternion5
                   AronModule.$fNumQuaternion3) -}
577f5150f132bf3e4d3d775031098f59
  $fNumQuaternion3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 68#) -}
67d41755c96ae8fa86fbbc8b47d5f7c6
  $fNumQuaternion4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 59#) -}
5bf5ac3aa056504cddec01804c7e7a3d
  $fNumQuaternion5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 222#) -}
cf744b90fed7725833cc330389eb2316
  $fNumQuaternion6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.$fNumQuaternion7) -}
b9fe170027f95982c7e6e7a149240e88
  $fNumQuaternion7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/AronModule.hs"#) -}
09c8e1961dfc90e9141779875fa07d4f
  $fNumQuaternion8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.$fNumQuaternion9) -}
a29bcadd9f15f381f0096887f89453b4
  $fNumQuaternion9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("AronModule"#) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$c* ::
    AronModule.Quaternion
    -> AronModule.Quaternion -> AronModule.Quaternion
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U(U),U(U),U(U),1*U(U))><S,1*U(U(U),U(U),U(U),U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.Quaternion) (w1 :: AronModule.Quaternion) ->
                 case w of ww { AronModule.Quaternion ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { AronModule.Quaternion ww6 ww7 ww8 ww9 ->
                 case AronModule.$w$c*
                        ww1
                        ww2
                        ww3
                        ww4
                        ww6
                        ww7
                        ww8
                        ww9 of ww10 { (#,,,#) ww11 ww12 ww13 ww14 ->
                 AronModule.Quaternion ww11 ww12 ww13 ww14 } } }) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$c+ ::
    AronModule.Quaternion
    -> AronModule.Quaternion -> AronModule.Quaternion
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.Quaternion) (w1 :: AronModule.Quaternion) ->
                 case w of ww { AronModule.Quaternion ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { AronModule.Quaternion ww6 ww7 ww8 ww9 ->
                 AronModule.Quaternion
                   (GHC.Float.plusFloat ww1 ww6)
                   (GHC.Float.plusFloat ww2 ww7)
                   (GHC.Float.plusFloat ww3 ww8)
                   (GHC.Float.plusFloat ww4 ww9) } }) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$c- ::
    AronModule.Quaternion
    -> AronModule.Quaternion -> AronModule.Quaternion
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.Quaternion) (w1 :: AronModule.Quaternion) ->
                 case w of ww { AronModule.Quaternion ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { AronModule.Quaternion ww6 ww7 ww8 ww9 ->
                 AronModule.Quaternion
                   (GHC.Float.minusFloat ww1 ww6)
                   (GHC.Float.minusFloat ww2 ww7)
                   (GHC.Float.minusFloat ww3 ww8)
                   (GHC.Float.minusFloat ww4 ww9) } }) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$cabs ::
    AronModule.Quaternion -> AronModule.Quaternion
  {- Arity: 1, Strictness: <B,A>x,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: AronModule.Quaternion) ->
                 GHC.Err.undefined
                   @ 'GHC.Types.LiftedRep
                   @ AronModule.Quaternion
                   AronModule.$fNumQuaternion17
                     `cast`
                   (Sym (GHC.Classes.N:IP[0]
                             <"callStack">_N <GHC.Stack.Types.CallStack>_N))) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$cfromInteger ::
    GHC.Integer.Type.Integer -> AronModule.Quaternion
  {- Arity: 1, Strictness: <B,A>x,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Integer.Type.Integer) ->
                 GHC.Err.undefined
                   @ 'GHC.Types.LiftedRep
                   @ AronModule.Quaternion
                   AronModule.$fNumQuaternion1
                     `cast`
                   (Sym (GHC.Classes.N:IP[0]
                             <"callStack">_N <GHC.Stack.Types.CallStack>_N))) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$cnegate ::
    AronModule.Quaternion -> AronModule.Quaternion
  {- Arity: 1, Strictness: <B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x1 :: AronModule.Quaternion) ->
                 GHC.Err.undefined
                   @ 'GHC.Types.LiftedRep
                   @ AronModule.Quaternion
                   AronModule.$fNumQuaternion1
                     `cast`
                   (Sym (GHC.Classes.N:IP[0]
                             <"callStack">_N <GHC.Stack.Types.CallStack>_N))) -}
4c45874df1274e5eea47b5815f9124ec
  $fNumQuaternion_$csignum ::
    AronModule.Quaternion -> AronModule.Quaternion
  {- Arity: 1, Strictness: <B,A>x,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: AronModule.Quaternion) ->
                 GHC.Err.undefined
                   @ 'GHC.Types.LiftedRep
                   @ AronModule.Quaternion
                   AronModule.$fNumQuaternion14
                     `cast`
                   (Sym (GHC.Classes.N:IP[0]
                             <"callStack">_N <GHC.Stack.Types.CallStack>_N))) -}
4b09f2e68912ce3843c52eabfc18cc46
  $fNum[] :: GHC.Num.Num a => GHC.Num.Num [a]
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a1 (v :: GHC.Num.Num a1).
                  @ [a1]
                  (AronModule.$fNum[]_$c+ @ a1 v)
                  (AronModule.$fNum[]_$c- @ a1 v)
                  (AronModule.$fNum[]_$c* @ a1 v)
                  (AronModule.$fNum[]_$cnegate @ a1 v)
                  (AronModule.$fNum[]_$cabs @ a1 v)
                  (AronModule.$fNum[]_$csignum @ a1 v)
                  (AronModule.$fNum[]_$cfromInteger @ a1 v) -}
859b9b91152bd3d821dbaa8f2200ff7d
  $fNum[]_$c* :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C(C1(U)),A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (eta :: [a1]) (eta1 :: [a1]) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ a1
                      @ a1
                      @ b1
                      (GHC.List.zipWithFB
                         @ a1
                         @ b1
                         @ b1
                         @ a1
                         @ a1
                         c1
                         (GHC.Num.* @ a1 $dNum))
                      n
                      eta
                      eta1)) -}
467f09f49e248d9da06a41b246786a52
  $fNum[]_$c+ :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C(C1(U)),A,A,A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (eta :: [a1]) (eta1 :: [a1]) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ a1
                      @ a1
                      @ b1
                      (GHC.List.zipWithFB
                         @ a1
                         @ b1
                         @ b1
                         @ a1
                         @ a1
                         c1
                         (GHC.Num.+ @ a1 $dNum))
                      n
                      eta
                      eta1)) -}
a355394d028f63b66a381b3a5f5e6239
  $fNum[]_$c- :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C(C1(U)),A,A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (eta :: [a1]) (eta1 :: [a1]) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ a1
                      @ a1
                      @ b1
                      (GHC.List.zipWithFB
                         @ a1
                         @ b1
                         @ b1
                         @ a1
                         @ a1
                         c1
                         (GHC.Num.- @ a1 $dNum))
                      n
                      eta
                      eta1)) -}
f89b2c2a9419b68cde555a03069131ae
  $fNum[]_$cabs :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,1*C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (eta :: [a1]) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a1
                      @ b1
                      (GHC.Base.mapFB @ a1 @ b1 @ a1 c1 (GHC.Num.abs @ a1 $dNum))
                      n
                      eta)) -}
375fd6e79d33e2f3b13535715dc3ac8c
  $fNum[]_$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: GHC.Integer.Type.Integer) ->
                 let {
                   x1 :: a1 = GHC.Num.fromInteger @ a1 $dNum eta
                 } in
                 letrec { xs :: [a1] = GHC.Types.: @ a1 x1 xs } in xs) -}
cd2cec421d066da1b0628046818ff220
  $fNum[]_$cnegate :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (x1 :: [a1]) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    let {
                      _k :: a1 -> a1 -> a1 = GHC.Num.- @ a1 $dNum
                    } in
                    GHC.List.repeatFB
                      @ a1
                      @ ([a1] -> b1)
                      (\ (_x :: a1) (_r :: [a1] -> b1)[OneShot] (ds :: [a1]) ->
                       case ds of wild {
                         [] -> n
                         : y1 ys
                         -> GHC.List.zipWithFB
                              @ a1
                              @ b1
                              @ b1
                              @ a1
                              @ a1
                              c1
                              _k
                              _x
                              y1
                              (_r ys) })
                      (GHC.Num.fromInteger @ a1 $dNum 0)
                      x1)) -}
5ffff2513b0fb3be82c0ff56f28bf077
  $fNum[]_$csignum :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,1*C(U),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (eta :: [a1]) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a1
                      @ b1
                      (GHC.Base.mapFB @ a1 @ b1 @ a1 c1 (GHC.Num.signum @ a1 $dNum))
                      n
                      eta)) -}
333978fdd88953d8934bc07531783829
  $fShowC :: GHC.Show.Show AronModule.C
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.C
                  AronModule.$fShowC_$cshowsPrec
                  AronModule.$fShowC_$cshow
                  AronModule.$fShowC_$cshowList -}
333978fdd88953d8934bc07531783829
  $fShowC1 :: AronModule.C -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: (\ (w :: AronModule.C) ->
                 case w of ww { AronModule.C ww1 ww2 ->
                 AronModule.$w$cshowsPrec 0# ww1 ww2 }) -}
7b6f5e23e72b0476bf79af7053bc4bea
  $fShowC2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
b37dc97ea408be7b58f71523d3dc7c64
  $fShowC3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("y = "#) -}
2921e2ab2091f1dd8a7b48c61e9321ba
  $fShowC4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("x = "#) -}
e0b4217ca3f3dfdb56942ccda0bd34a5
  $fShowC5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("C {"#) -}
255321fcd2990f527d64c3b5d1603525
  $fShowC6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
333978fdd88953d8934bc07531783829
  $fShowC_$cshow :: AronModule.C -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: AronModule.C) ->
                 AronModule.$fShowC_$cshowsPrec
                   AronModule.$fShowC6
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
333978fdd88953d8934bc07531783829
  $fShowC_$cshowList :: [AronModule.C] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls4 :: [AronModule.C]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ AronModule.C AronModule.$fShowC1 ls4 s) -}
333978fdd88953d8934bc07531783829
  $fShowC_$cshowsPrec ::
    GHC.Types.Int -> AronModule.C -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AronModule.C) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { AronModule.C ww3 ww4 ->
                 AronModule.$w$cshowsPrec ww1 ww3 ww4 } }) -}
4c45874df1274e5eea47b5815f9124ec
  $fShowQuaternion :: GHC.Show.Show AronModule.Quaternion
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.Quaternion
                  AronModule.$fShowQuaternion_$cshowsPrec
                  AronModule.$fShowQuaternion_$cshow
                  AronModule.$fShowQuaternion_$cshowList -}
4c45874df1274e5eea47b5815f9124ec
  $fShowQuaternion1 :: AronModule.Quaternion -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>,
     Unfolding: (\ (w :: AronModule.Quaternion) ->
                 case w of ww { AronModule.Quaternion ww1 ww2 ww3 ww4 ->
                 AronModule.$w$cshowsPrec1 0# ww1 ww2 ww3 ww4 }) -}
4c45874df1274e5eea47b5815f9124ec
  $fShowQuaternion_$cshow :: AronModule.Quaternion -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: AronModule.Quaternion) ->
                 AronModule.$fShowQuaternion_$cshowsPrec
                   AronModule.$fShowC6
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4c45874df1274e5eea47b5815f9124ec
  $fShowQuaternion_$cshowList ::
    [AronModule.Quaternion] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls4 :: [AronModule.Quaternion]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ AronModule.Quaternion
                   AronModule.$fShowQuaternion1
                   ls4
                   s) -}
4c45874df1274e5eea47b5815f9124ec
  $fShowQuaternion_$cshowsPrec ::
    GHC.Types.Int -> AronModule.Quaternion -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AronModule.Quaternion) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { AronModule.Quaternion ww3 ww4 ww5 ww6 ->
                 AronModule.$w$cshowsPrec1 ww1 ww3 ww4 ww5 ww6 } }) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (AronModule.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a1 (v :: GHC.Show.Show a1).
                  @ (AronModule.Tree a1)
                  (AronModule.$fShowTree_$cshowsPrec @ a1 v)
                  (AronModule.$fShowTree_$cshow @ a1 v)
                  (AronModule.$fShowTree_$cshowList @ a1 v) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fShowTree_$cshow ::
    GHC.Show.Show a => AronModule.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 ($dShow :: GHC.Show.Show a1) (x1 :: AronModule.Tree a1) ->
                 AronModule.$fShowTree_$cshowsPrec
                   @ a1
                   $dShow
                   AronModule.$fShowC6
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [AronModule.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   ($dShow :: GHC.Show.Show a1)
                   (ls4 :: [AronModule.Tree a1])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (AronModule.Tree a1)
                   (AronModule.$fShowTree_$cshowsPrec @ a1 $dShow AronModule.$fShowC6)
                   ls4
                   s) -}
ee7f704147a2417a2e9d7ca38b6754ab
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> AronModule.Tree a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><L,1*U(U)><S,1*U> -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fShowXNode :: GHC.Show.Show AronModule.XNode
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ AronModule.XNode
                  AronModule.$fShowXNode_$cshowsPrec
                  AronModule.$fShowXNode_$cshow
                  AronModule.$fShowXNode_$cshowList -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fShowXNode1 :: AronModule.XNode -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>,
     Unfolding: (\ (w :: AronModule.XNode) ->
                 case w of ww { AronModule.XNode ww1 ww2 ->
                 AronModule.$w$cshowsPrec2 0# ww1 ww2 }) -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fShowXNode_$cshow :: AronModule.XNode -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: AronModule.XNode) ->
                 AronModule.$fShowXNode_$cshowsPrec
                   AronModule.$fShowC6
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fShowXNode_$cshowList :: [AronModule.XNode] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls4 :: [AronModule.XNode]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ AronModule.XNode
                   AronModule.$fShowXNode1
                   ls4
                   s) -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $fShowXNode_$cshowsPrec ::
    GHC.Types.Int -> AronModule.XNode -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: AronModule.XNode) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { AronModule.XNode ww3 ww4 ->
                 AronModule.$w$cshowsPrec2 ww1 ww3 ww4 } }) -}
2fd51a6ee73785f7a98d3c058c226bd0
  $s$wupdateOrSnocWithKey1 ::
    (GHC.Base.String -> v -> v -> v)
    -> GHC.Base.String
    -> v
    -> Data.HashMap.Array.Array#
         (Data.HashMap.Base.Leaf GHC.Base.String v)
    -> Data.HashMap.Array.Array
         (Data.HashMap.Base.Leaf GHC.Base.String v)
  {- Arity: 4, Strictness: <L,C(C1(C1(U)))><S,1*U><L,U><S,U>,
     Inline: [2],
     Unfolding: (\ @ v
                   (w1 :: GHC.Base.String -> v -> v -> v)
                   (w2 :: GHC.Base.String)
                   (w3 :: v)
                   (ww :: Data.HashMap.Array.Array#
                            (Data.HashMap.Base.Leaf GHC.Base.String v)) ->
                 let {
                   exit9 :: v
                            -> Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf GHC.Base.String v)
                            -> GHC.Prim.Int#
                            -> GHC.Base.String
                            -> v
                            -> Data.HashMap.Array.Array
                                 (Data.HashMap.Base.Leaf GHC.Base.String v)
                     <join 5> {- Arity: 5, Strictness: <L,U><S,U><S,U><L,U><L,U> -}
                   = \ (w :: v)[OneShot]
                       (ww1 :: Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf GHC.Base.String v))[OneShot]
                       (ww2 :: GHC.Prim.Int#)[OneShot]
                       (k2 :: GHC.Base.String)[OneShot]
                       (y1 :: v)[OneShot] ->
                     case GHC.Magic.runRW#
                            @ ('GHC.Types.TupleRep
                                 '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                            @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.HashMap.Array.Array
                                   (Data.HashMap.Base.Leaf GHC.Base.String v) #)
                            (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.thawSmallArray#
                                    @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                    @ GHC.Prim.RealWorld
                                    ww1
                                    0#
                                    (GHC.Prim.sizeofSmallArray#
                                       @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                       ww1)
                                    s1 of ds2 { (#,#) ipv4 ipv5 ->
                             case GHC.Prim.writeSmallArray#
                                    @ GHC.Prim.RealWorld
                                    @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                    ipv5
                                    ww2
                                    (Data.HashMap.Base.L @ GHC.Base.String @ v k2 (w1 k2 w y1))
                                    ipv4 of s' { DEFAULT ->
                             case GHC.Prim.unsafeFreezeSmallArray#
                                    @ GHC.Prim.RealWorld
                                    @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                    ipv5
                                    s' of ds3 { (#,#) ipv6 ipv7 ->
                             (# ipv6,
                                Data.HashMap.Array.Array
                                  @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                  ipv7 #) } } }) of ds2 { (#,#) ipv4 ipv5 ->
                     ipv5 }
                 } in
                 letrec {
                   $wgo12 :: GHC.Base.String
                             -> v
                             -> Data.HashMap.Array.Array#
                                  (Data.HashMap.Base.Leaf GHC.Base.String v)
                             -> GHC.Prim.Int#
                             -> GHC.Prim.Int#
                             -> Data.HashMap.Array.Array
                                  (Data.HashMap.Base.Leaf GHC.Base.String v)
                     <join 5> {- Arity: 5, Strictness: <S,1*U><L,U><S,U><S,U><S,U>,
                                 Inline: [2] -}
                   = \ (w :: GHC.Base.String)
                       (w4 :: v)
                       (ww1 :: Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf GHC.Base.String v))
                       (ww2 :: GHC.Prim.Int#)
                       (ww3 :: GHC.Prim.Int#) ->
                     case w of k2 { DEFAULT ->
                     case GHC.Prim.>=# ww2 ww3 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexSmallArray#
                                 @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                 ww1
                                 ww2 of ds1 { Unit# ipv3 ->
                          case ipv3 of wild1 { Data.HashMap.Base.L kx y1 ->
                          case GHC.Base.eqString k2 kx of wild2 {
                            GHC.Types.False -> $wgo12 k2 w4 ww1 (GHC.Prim.+# ww2 1#) ww3
                            GHC.Types.True -> exit9 w4 ww1 ww2 k2 y1 } } }
                       1#
                       -> case GHC.Magic.runRW#
                                 @ ('GHC.Types.TupleRep
                                      '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                                 @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                      Data.HashMap.Array.Array
                                        (Data.HashMap.Base.Leaf GHC.Base.String v) #)
                                 (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newSmallArray#
                                         @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                         @ GHC.Prim.RealWorld
                                         (GHC.Prim.+# ww3 1#)
                                         (Data.HashMap.Array.undefinedElem
                                            @ (Data.HashMap.Base.Leaf GHC.Base.String v))
                                         s1 of ds { (#,#) ipv3 ipv4 ->
                                  case GHC.Prim.copySmallArray#
                                         @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                         @ GHC.Prim.RealWorld
                                         ww1
                                         0#
                                         ipv4
                                         0#
                                         ww3
                                         ipv3 of s2 { DEFAULT ->
                                  case GHC.Prim.writeSmallArray#
                                         @ GHC.Prim.RealWorld
                                         @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                         ipv4
                                         ww3
                                         (Data.HashMap.Base.L @ GHC.Base.String @ v k2 w4)
                                         s2 of s' { DEFAULT ->
                                  case GHC.Prim.unsafeFreezeSmallArray#
                                         @ GHC.Prim.RealWorld
                                         @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                         ipv4
                                         s' of ds2 { (#,#) ipv5 ipv6 ->
                                  (# ipv5,
                                     Data.HashMap.Array.Array
                                       @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                                       ipv6 #) } } } }) of ds1 { (#,#) ipv3 ipv4 ->
                          ipv4 } } }
                 } in
                 $wgo12
                   w2
                   w3
                   ww
                   0#
                   (GHC.Prim.sizeofSmallArray#
                      @ (Data.HashMap.Base.Leaf GHC.Base.String v)
                      ww)) -}
3242f21fd96886347bde124d31c39bd1
  $s^ ::
    Data.Time.Clock.Internal.POSIXTime.POSIXTime
    -> GHC.Integer.Type.Integer
    -> Data.Time.Clock.Internal.POSIXTime.POSIXTime
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [1],
     Unfolding: (\ (x0 :: Data.Time.Clock.Internal.POSIXTime.POSIXTime)
                   (y0 :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.ltInteger#
                        y0
                        AronModule.$fDnumDoubleInt1 of wild {
                   DEFAULT
                   -> case GHC.Integer.Type.eqInteger#
                             y0
                             AronModule.$fDnumDoubleInt1 of wild1 {
                        DEFAULT -> AronModule.$s^_f x0 y0
                        1#
                        -> AronModule.$s^2
                             `cast`
                           (Sym (Data.Fixed.N:Fixed[0]
                                     <Data.Fixed.E12>_P) ; Sym (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0])) }
                   1# -> AronModule.$s^1 }) -}
3a994c4a7f7f951c4ef960bc6ae026d1
  $s^1 :: Data.Time.Clock.Internal.POSIXTime.POSIXTime
  {- Strictness: x -}
d53074979fc6338f54efb8bbd1362fce
  $s^2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1000000000000) -}
1f638fc43afbdd0cde9aabce1742d701
  $s^_f ::
    Data.Time.Clock.Internal.POSIXTime.POSIXTime
    -> GHC.Integer.Type.Integer
    -> Data.Time.Clock.Internal.POSIXTime.POSIXTime
  {- Arity: 2, Strictness: <S,U><S,U> -}
bb90d711b2a40c2991b827f687ed2705
  $seven1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
c4522748d1b48ea2db407077654fb5db
  $sfromIntegral ::
    GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [1],
     Unfolding: InlineRule (1, True, True)
                (\ (w2 :: GHC.Integer.Type.Integer) -> w2) -}
b8239692a35d3f256991a207ea8a5afb
  $sfromList ::
    [GHC.Base.String] -> Data.Set.Internal.Set GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) ->
                 case ds of wild {
                   [] -> Data.Set.Internal.Tip @ GHC.Base.String
                   : x1 ds1
                   -> case ds1 of wild1 {
                        []
                        -> case x1 of dt { DEFAULT ->
                           Data.Set.Internal.Bin
                             @ GHC.Base.String
                             1#
                             dt
                             (Data.Set.Internal.Tip @ GHC.Base.String)
                             (Data.Set.Internal.Tip @ GHC.Base.String) }
                        : ipv ipv1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 x1 ipv of wild2 {
                             DEFAULT
                             -> case x1 of dt { DEFAULT ->
                                AronModule.$sfromList_go
                                  wild1
                                  (Data.Set.Internal.Bin
                                     @ GHC.Base.String
                                     1#
                                     dt
                                     (Data.Set.Internal.Tip @ GHC.Base.String)
                                     (Data.Set.Internal.Tip @ GHC.Base.String)) }
                             GHC.Types.LT
                             -> case x1 of dt { DEFAULT ->
                                AronModule.$wgo3
                                  1#
                                  (Data.Set.Internal.Bin
                                     @ GHC.Base.String
                                     1#
                                     dt
                                     (Data.Set.Internal.Tip @ GHC.Base.String)
                                     (Data.Set.Internal.Tip @ GHC.Base.String))
                                  wild1 } } } }) -}
7ff2a83e0361435495208b81436872f8
  $sfromList_go ::
    [GHC.Base.String]
    -> Data.Set.Internal.Set GHC.Base.String
    -> Data.Set.Internal.Set GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
9d3b0fd3ee47324c6f916338c04003b0
  $sinsert_$sgo3 ::
    GHC.Base.String
    -> GHC.Base.String
    -> Data.Set.Internal.Set GHC.Base.String
    -> Data.Set.Internal.Set GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
5488091f9050cce3f7771754a9fb28ad
  $slookup# ::
    [GHC.Types.Char]
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v -> (# (# #) | v #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ @ v
                   (k1 :: [GHC.Types.Char])
                   (m :: Data.HashMap.Base.HashMap [GHC.Types.Char] v) ->
                 let {
                   exit9 :: GHC.Prim.Int# -> GHC.Prim.Int# -> (# (# #) | v #)
                     <join 2> {- Arity: 2, Strictness: <S,U><S,U> -}
                   = \ (ww :: GHC.Prim.Int#)[OneShot]
                       (ww1 :: GHC.Prim.Int#)[OneShot] ->
                     AronModule.$wpoly_go3
                       @ v
                       (GHC.Prim.int2Word#
                          (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) ww1))
                       k1
                       0#
                       m
                 } in
                 letrec {
                   $wgo12 :: [GHC.Types.Char]
                             -> GHC.Prim.Int# -> GHC.Prim.Int# -> (# (# #) | v #)
                     <join 3> {- Arity: 3, Strictness: <S,1*U><S,U><S,U>, Inline: [2] -}
                   = \ (w1 :: [GHC.Types.Char])
                       (ww :: GHC.Prim.Int#)
                       (ww1 :: GHC.Prim.Int#) ->
                     case w1 of wild {
                       [] -> exit9 ww ww1
                       : y1 ys
                       -> case y1 of wild1 { GHC.Types.C# c# ->
                          $wgo12
                            ys
                            (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) (GHC.Prim.ord# c#))
                            (GHC.Prim.+# ww1 1#) } }
                 } in
                 $wgo12 k1 -2578643520546668380# 0#) -}
66bf1de7f7d533ec11063c5a2fbf451f
  $ssimpleHttp ::
    GHC.Base.String
    -> GHC.Types.IO Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 1, Strictness: <L,U>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: GHC.Base.String) ->
                 Network.HTTP.Conduit.$wsimpleHttp
                   @ GHC.Types.IO
                   (\ @ a1 -> GHC.Base.id @ (GHC.Types.IO a1))
                   w1) -}
aa5038cf06ad5bdee47294b0daf99edb
  $sunsafeInsert ::
    GHC.Base.String
    -> v
    -> Data.HashMap.Base.HashMap GHC.Base.String v
    -> Data.HashMap.Base.HashMap GHC.Base.String v
  {- Arity: 3, Strictness: <S,U><L,U><S,U>,
     Unfolding: (\ @ v
                   (k0 :: GHC.Base.String)
                   (v0 :: v)
                   (m0 :: Data.HashMap.Base.HashMap GHC.Base.String v) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.HashMap.Base.HashMap GHC.Base.String v #)
                        (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           exit9 :: GHC.Prim.Int#
                                    -> GHC.Prim.Int#
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.HashMap.Base.HashMap GHC.Base.String v #)
                             <join 2> {- Arity: 2, Strictness: <S,U><S,U> -}
                           = \ (ww :: GHC.Prim.Int#)[OneShot]
                               (ww1 :: GHC.Prim.Int#)[OneShot] ->
                             AronModule.$wpoly_go5
                               @ v
                               (GHC.Prim.int2Word#
                                  (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) ww1))
                               k0
                               v0
                               0#
                               m0
                               w
                         } in
                         letrec {
                           $wgo12 :: [GHC.Types.Char]
                                     -> GHC.Prim.Int#
                                     -> GHC.Prim.Int#
                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                           Data.HashMap.Base.HashMap GHC.Base.String v #)
                             <join 3> {- Arity: 3, Strictness: <S,1*U><S,U><S,U>, Inline: [2] -}
                           = \ (w1 :: [GHC.Types.Char])
                               (ww :: GHC.Prim.Int#)
                               (ww1 :: GHC.Prim.Int#) ->
                             case w1 of wild {
                               [] -> exit9 ww ww1
                               : y1 ys
                               -> case y1 of wild1 { GHC.Types.C# c# ->
                                  $wgo12
                                    ys
                                    (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) (GHC.Prim.ord# c#))
                                    (GHC.Prim.+# ww1 1#) } }
                         } in
                         $wgo12 k0 -2578643520546668380# 0#) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
63644f166ee48626c4eccf39941ee221
  $tc'C :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3089709595768978703##
                   6189124764168379738##
                   AronModule.$trModule
                   AronModule.$tc'C2
                   0#
                   AronModule.$tc'C1) -}
107c9ba282b32ee507aaecd6caf2d7b5
  $tc'C1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6262657d8409e91ba60344f11463bdba
  $tc'C2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'C3) -}
38978b82e0d23a0098b054a43a239a0e
  $tc'C3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C"#) -}
3d0ec42a33820422ba804411081b48f4
  $tc'C:Cnum :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   253459086565641605##
                   4911936810239800057##
                   AronModule.$trModule
                   AronModule.$tc'C:Cnum2
                   1#
                   AronModule.$tc'C:Cnum1) -}
6cbe0161850dd136c45e36775587f47a
  $tc'C:Cnum1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7f1be41994b19addf35b7288828a9b97
  $tc'C:Cnum2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'C:Cnum3) -}
11498c7715a273dffc05b4e33000ba55
  $tc'C:Cnum3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:Cnum"#) -}
f8b457d5f8a7dbfdc12cd4f72a173ef5
  $tc'Empty :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   147574273690153016##
                   13530915822845784903##
                   AronModule.$trModule
                   AronModule.$tc'Empty2
                   1#
                   AronModule.$tc'Empty1) -}
f073d0f1b21e5f3f57fda7534b02c7a1
  $tc'Empty1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
06186a3e490bda8bc6dfb009d28e0c3e
  $tc'Empty2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'Empty3) -}
63cc65d8a9c058bd4cea189dc080a2d0
  $tc'Empty3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Empty"#) -}
692a7e522207b654cc631be5644c060e
  $tc'GPoint :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1455720541151225419##
                   6183670529381106627##
                   AronModule.$trModule
                   AronModule.$tc'GPoint2
                   0#
                   AronModule.$tc'GPoint1) -}
9f00cb3445c828551d308aac528264c3
  $tc'GPoint1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a57f8099f59982cc2f910f74d26695f1
  $tc'GPoint2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'GPoint3) -}
189642b46d110b51623d57e353f48a81
  $tc'GPoint3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GPoint"#) -}
071ce164dae2444add733746ca181a0d
  $tc'Id :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16902292713457763766##
                   6587701484014704562##
                   AronModule.$trModule
                   AronModule.$tc'Id2
                   0#
                   AronModule.$tc'Id1) -}
4254c9ba6169bc1a6233ca4ac03b5589
  $tc'Id1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
da91ea7e1f7298d7391b731699acb45f
  $tc'Id2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'Id3) -}
3bcf11e53126761226a95683b1633b6c
  $tc'Id3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Id"#) -}
22d0f443ef93ec07a1567d0d9a0327b2
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10432854276754265127##
                   14980522170588599500##
                   AronModule.$trModule
                   AronModule.$tc'Node2
                   1#
                   AronModule.$tc'Node1) -}
502b29da5ba61035c6c1e0fca916b42e
  $tc'Node1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
63be01f4bcbdcf7777960890c67e643f
  $tc'Node2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'Node3) -}
3cc154e0bc526056f09f0df13e2956a4
  $tc'Node3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Node"#) -}
40c7e759fa3b6d05f7d7908dc512a436
  $tc'Quaternion :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   404691518012423822##
                   14270583535650351250##
                   AronModule.$trModule
                   AronModule.$tc'Quaternion2
                   0#
                   AronModule.$tc'Quaternion1) -}
f234c14e64bc7b2f9e4fb56038e421e6
  $tc'Quaternion1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
97eb4e352766653e0e6f0f6c0770451b
  $tc'Quaternion2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'Quaternion3) -}
75a890b57244f2642123260474b675f7
  $tc'Quaternion3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Quaternion"#) -}
f241c23f8d73e0414c885ac31aa33ea2
  $tc'XNode :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15504292898542647232##
                   5702324429311476713##
                   AronModule.$trModule
                   AronModule.$tc'XNode2
                   0#
                   AronModule.$tc'XNode1) -}
67e051497452abbc330fc800c54d1e87
  $tc'XNode1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
771b1656dc7cb4214b79d5456c9a30ee
  $tc'XNode2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'XNode3) -}
f85e280272dc8a59c7b60908453ebc4e
  $tc'XNode3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'XNode"#) -}
f32cefd175e0bbaf42b67823b60c0d5c
  $tc'Zero :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17517731043664912753##
                   7646154095727101880##
                   AronModule.$trModule
                   AronModule.$tc'Zero1
                   0#
                   AronModule.$tc'Id1) -}
69046d55e0094c24a54ea94ddfb00798
  $tc'Zero1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tc'Zero2) -}
92d1b30b0f28c1f1d4b31675e978c4ad
  $tc'Zero2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Zero"#) -}
8f9e3eb048e9fedbed1c4207aa73d06c
  $tcAdd :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4809284454202007960##
                   7000494939348863944##
                   AronModule.$trModule
                   AronModule.$tcAdd2
                   0#
                   AronModule.$tcAdd1) -}
c7fda62c4b84d397d1cf89334923c2eb
  $tcAdd1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3a4e6e8043e50fdc1c704d65d5d72cd5
  $tcAdd2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcAdd3) -}
80a6cb4d06a63efcd6a054bf2ad50539
  $tcAdd3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Add"#) -}
93dcc66df7d334709119297466ea60e4
  $tcC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4591042173780565698##
                   5841959003265093203##
                   AronModule.$trModule
                   AronModule.$tcC1
                   0#
                   GHC.Types.krep$*) -}
f37319840daa1520aa7db5ec1bed2717
  $tcC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcC2) -}
6adb1817ff379157a4e25b3a10574dbb
  $tcC2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("C"#) -}
68b955dc7d53d4b9595929456217e5eb
  $tcCnum :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1668292853254075409##
                   2848581945381173511##
                   AronModule.$trModule
                   AronModule.$tcCnum2
                   0#
                   AronModule.$tcCnum1) -}
1fb477de727d4e9250969228ad7d75dc
  $tcCnum1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
713b0de25cad43da5c96aceb5b184543
  $tcCnum2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcCnum3) -}
df603760c3427194df8b204bf85a1297
  $tcCnum3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Cnum"#) -}
ddcbc86ad0df38c59ae746be5c22002c
  $tcDnum :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   696794035718075599##
                   7802033587790615645##
                   AronModule.$trModule
                   AronModule.$tcDnum1
                   0#
                   AronModule.$tcAdd1) -}
fe5a801cf8208808404ced38107324b3
  $tcDnum1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcDnum2) -}
e99f782a93934a344010ab4b693601e0
  $tcDnum2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Dnum"#) -}
2d17b6687032adcee8552a0ba61fcf49
  $tcGPoint :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4964132585520861771##
                   14720456475561118721##
                   AronModule.$trModule
                   AronModule.$tcGPoint1
                   0#
                   GHC.Types.krep$*) -}
18ba395e89842ce0a65a4fa0426df6ec
  $tcGPoint1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcGPoint2) -}
3389ae909cb3dca23d6581e5f31c856c
  $tcGPoint2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GPoint"#) -}
61d344d6432f0ce6b6d771baa0584ee0
  $tcMat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2215289348310232731##
                   8546903360201226066##
                   AronModule.$trModule
                   AronModule.$tcMat1
                   0#
                   GHC.Types.krep$*) -}
ec4ef0b00d23f976604a452820fb248f
  $tcMat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcMat2) -}
643d7729bea637c0acc54ee7276cdd5e
  $tcMat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Mat"#) -}
15836653e2a67869ba8efa6a5561417d
  $tcQuaternion :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14179886289001892864##
                   15820444437182700042##
                   AronModule.$trModule
                   AronModule.$tcQuaternion1
                   0#
                   GHC.Types.krep$*) -}
ad3de3023e4bbf4adee0369469701ede
  $tcQuaternion1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcQuaternion2) -}
80e31d646d463ff6c2b22355898fb9f8
  $tcQuaternion2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Quaternion"#) -}
ada8852d9c24d85341ae8e4c1e5ea339
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13052340176527480926##
                   18030748638992450764##
                   AronModule.$trModule
                   AronModule.$tcTree1
                   0#
                   GHC.Types.krep$*Arr*) -}
81506b505309bbbc6a08bd753e948d13
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcTree2) -}
2c76c3de8ae4ad74200c3e3c9f661bcc
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
a8e968cb5afa3b2baef97a658bafd7e8
  $tcXNode :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10803219705097191257##
                   3055842114987638959##
                   AronModule.$trModule
                   AronModule.$tcXNode1
                   0#
                   GHC.Types.krep$*) -}
d66ef76f7952d20875bc8920d19eb3aa
  $tcXNode1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$tcXNode2) -}
d0268a794b57f86f5d4f653e0171d0d7
  $tcXNode2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("XNode"#) -}
93501aed537b3283586d3d8462e78c5e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   AronModule.$trModule2
                   AronModule.$trModule1) -}
b0dbc24a2ee5888017511c4dfa184170
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$fNumQuaternion9) -}
b262b13bc64152f289afdfd28a7cf793
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS AronModule.$fNumQuaternion11) -}
faf5c76a9ebb15963ee417694eadf901
  $w$c* ::
    GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> (# GHC.Types.Float, GHC.Types.Float, GHC.Types.Float,
          GHC.Types.Float #)
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,U(U)><L,U(U)><L,U(U)><L,1*U(U)><L,U(U)><L,U(U)><L,U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Types.Float)
                   (ww1 :: GHC.Types.Float)
                   (ww2 :: GHC.Types.Float)
                   (ww3 :: GHC.Types.Float)
                   (ww4 :: GHC.Types.Float)
                   (ww5 :: GHC.Types.Float)
                   (ww6 :: GHC.Types.Float)
                   (ww7 :: GHC.Types.Float) ->
                 (# case ww of wild { GHC.Types.F# x1 ->
                    case ww4 of wild1 { GHC.Types.F# y1 ->
                    case ww1 of wild2 { GHC.Types.F# x2 ->
                    case ww5 of wild3 { GHC.Types.F# y2 ->
                    case ww2 of wild4 { GHC.Types.F# x3 ->
                    case ww6 of wild5 { GHC.Types.F# y3 ->
                    case ww7 of wild6 { GHC.Types.F# y4 ->
                    GHC.Types.F#
                      (GHC.Prim.minusFloat#
                         (GHC.Prim.minusFloat#
                            (GHC.Prim.minusFloat#
                               (GHC.Prim.timesFloat# x1 y1)
                               (GHC.Prim.timesFloat# x2 y2))
                            (GHC.Prim.timesFloat# x3 y3))
                         (GHC.Prim.timesFloat# y1 y4)) } } } } } } },
                    case ww1 of wild { GHC.Types.F# x1 ->
                    case ww4 of wild1 { GHC.Types.F# y1 ->
                    case ww of wild2 { GHC.Types.F# x2 ->
                    case ww5 of wild3 { GHC.Types.F# y2 ->
                    case ww6 of wild4 { GHC.Types.F# y3 ->
                    case ww2 of wild5 { GHC.Types.F# x3 ->
                    case ww7 of wild6 { GHC.Types.F# y4 ->
                    GHC.Types.F#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.minusFloat#
                            (GHC.Prim.plusFloat#
                               (GHC.Prim.timesFloat# x1 y1)
                               (GHC.Prim.timesFloat# x2 y2))
                            (GHC.Prim.timesFloat# y1 y3))
                         (GHC.Prim.timesFloat# x3 y4)) } } } } } } },
                    case ww2 of wild { GHC.Types.F# x1 ->
                    case ww4 of wild1 { GHC.Types.F# y1 ->
                    case ww5 of wild2 { GHC.Types.F# y2 ->
                    case ww of wild3 { GHC.Types.F# x2 ->
                    case ww6 of wild4 { GHC.Types.F# y3 ->
                    case ww1 of wild5 { GHC.Types.F# x3 ->
                    case ww7 of wild6 { GHC.Types.F# y4 ->
                    GHC.Types.F#
                      (GHC.Prim.minusFloat#
                         (GHC.Prim.plusFloat#
                            (GHC.Prim.plusFloat#
                               (GHC.Prim.timesFloat# x1 y1)
                               (GHC.Prim.timesFloat# y1 y2))
                            (GHC.Prim.timesFloat# x2 y3))
                         (GHC.Prim.timesFloat# x3 y4)) } } } } } } },
                    case ww3 of wild { GHC.Types.F# x1 ->
                    case ww4 of wild1 { GHC.Types.F# y1 ->
                    case ww2 of wild2 { GHC.Types.F# x2 ->
                    case ww5 of wild3 { GHC.Types.F# y2 ->
                    case ww1 of wild4 { GHC.Types.F# x3 ->
                    case ww6 of wild5 { GHC.Types.F# y3 ->
                    case ww of wild6 { GHC.Types.F# x4 ->
                    case ww7 of wild7 { GHC.Types.F# y4 ->
                    GHC.Types.F#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.plusFloat#
                            (GHC.Prim.minusFloat#
                               (GHC.Prim.timesFloat# x1 y1)
                               (GHC.Prim.timesFloat# x2 y2))
                            (GHC.Prim.timesFloat# x3 y3))
                         (GHC.Prim.timesFloat# x4 y4)) } } } } } } } } #)) -}
77e4ab998894bc0a8fdf24b6590c15f3
  $w$c/= ::
    GHC.Prim.Float#
    -> GHC.Types.Float -> GHC.Prim.Float# -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,1*U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Float#)
                   (ww1 :: GHC.Types.Float)
                   (ww2 :: GHC.Prim.Float#) ->
                 case GHC.Prim.eqFloat# ww ww2 of lwild {
                   DEFAULT
                   -> case ww1 of wild { GHC.Types.F# x1 ->
                      case GHC.Prim.eqFloat# x1 ww2 of lwild1 {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                   1# -> GHC.Types.False }) -}
6db31d65b7bcca3d0a0ed3a9aca0484f
  $w$c== ::
    GHC.Prim.Float#
    -> GHC.Types.Float
    -> GHC.Prim.Float#
    -> GHC.Types.Float
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Float#)
                   (ww1 :: GHC.Types.Float)
                   (ww2 :: GHC.Prim.Float#)
                   (ww3 :: GHC.Types.Float) ->
                 case GHC.Prim.eqFloat# ww ww2 of lwild {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Classes.eqFloat ww1 ww3 }) -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $w$c==1 ::
    Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode
    -> GHC.Types.Bool
    -> Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode
    -> GHC.Types.Bool
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [2] -}
69d92da5d2e845bc4c67d166769fda73
  $w$c_div ::
    GHC.Prim.Double#
    -> GHC.Prim.Int#
    -> AronModule.DivType GHC.Types.Double GHC.Types.Int
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Double#) (ww1 :: GHC.Prim.Int#) ->
                 let {
                   ds1 :: GHC.Integer.Type.Integer = GHC.Integer.Type.smallInteger ww1
                 } in
                 case GHC.Integer.Type.eqInteger#
                        ds1
                        AronModule.$fDnumDoubleInt1 of wild {
                   DEFAULT
                   -> case {__pkg_ccall base-4.12.0.0 GHC.Prim.Double#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Double# #)}
                             ww
                             GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                      case GHC.Integer.Type.decodeDoubleInteger
                             ds3 of ds4 { (#,#) ipv ipv1 ->
                      case GHC.Prim.<# ipv1 0# of lwild {
                        DEFAULT
                        -> (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.shiftLInteger ipv ipv1)
                              ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeDoubleInt[0])))
                        1#
                        -> case GHC.Integer.Type.integerToInt ipv of n { DEFAULT ->
                           (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.smallInteger
                                 (GHC.Prim.uncheckedIShiftRA# n (GHC.Prim.negateInt# ipv1)))
                              ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeDoubleInt[0]))) } } } }
                   1#
                   -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                        `cast`
                      (Sub (Sym (AronModule.D:R:DivTypeDoubleInt[0]))) }) -}
30af4ba0007cfa3a83f87f7c7de68aa4
  $w$c_div1 ::
    GHC.Prim.Double#
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Double#)
                   (w :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.eqInteger#
                        w
                        AronModule.$fDnumDoubleInt1 of wild {
                   DEFAULT
                   -> case {__pkg_ccall base-4.12.0.0 GHC.Prim.Double#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Double# #)}
                             ww
                             GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                      case GHC.Integer.Type.decodeDoubleInteger
                             ds3 of ds4 { (#,#) ipv ipv1 ->
                      case GHC.Prim.<# ipv1 0# of lwild {
                        DEFAULT
                        -> GHC.Integer.Type.divInteger
                             (GHC.Integer.Type.shiftLInteger ipv ipv1)
                             w
                        1#
                        -> case GHC.Integer.Type.integerToInt ipv of n { DEFAULT ->
                           GHC.Integer.Type.divInteger
                             (GHC.Integer.Type.smallInteger
                                (GHC.Prim.uncheckedIShiftRA# n (GHC.Prim.negateInt# ipv1)))
                             w } } } }
                   1# -> GHC.Real.divZeroError @ GHC.Integer.Type.Integer }) -}
69d92da5d2e845bc4c67d166769fda73
  $w$c_div2 ::
    GHC.Prim.Float#
    -> GHC.Prim.Int#
    -> AronModule.DivType GHC.Types.Float GHC.Types.Int
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Float#) (ww1 :: GHC.Prim.Int#) ->
                 let {
                   ds1 :: GHC.Integer.Type.Integer = GHC.Integer.Type.smallInteger ww1
                 } in
                 case GHC.Integer.Type.eqInteger#
                        ds1
                        AronModule.$fDnumDoubleInt1 of wild {
                   DEFAULT
                   -> case {__pkg_ccall base-4.12.0.0 GHC.Prim.Float#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Float# #)}
                             ww
                             GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                      case GHC.Prim.decodeFloat_Int# ds3 of ds4 { (#,#) ipv ipv1 ->
                      case GHC.Prim.<# ipv1 0# of lwild {
                        DEFAULT
                        -> (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.shiftLInteger
                                 (GHC.Integer.Type.smallInteger ipv)
                                 ipv1)
                              ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeFloatInt[0])))
                        1#
                        -> (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.smallInteger
                                 (GHC.Prim.uncheckedIShiftRA# ipv (GHC.Prim.negateInt# ipv1)))
                              ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeFloatInt[0]))) } } }
                   1#
                   -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                        `cast`
                      (Sub (Sym (AronModule.D:R:DivTypeFloatInt[0]))) }) -}
2cdebeb47e4bda251009edea270a860f
  $w$c_div3 ::
    GHC.Prim.Float#
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Float#)
                   (w :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.eqInteger#
                        w
                        AronModule.$fDnumDoubleInt1 of wild {
                   DEFAULT
                   -> case {__pkg_ccall base-4.12.0.0 GHC.Prim.Float#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Float# #)}
                             ww
                             GHC.Prim.realWorld# of wild1 { (#,#) ds2 ds3 ->
                      case GHC.Prim.decodeFloat_Int# ds3 of ds4 { (#,#) ipv ipv1 ->
                      case GHC.Prim.<# ipv1 0# of lwild {
                        DEFAULT
                        -> GHC.Integer.Type.divInteger
                             (GHC.Integer.Type.shiftLInteger
                                (GHC.Integer.Type.smallInteger ipv)
                                ipv1)
                             w
                        1#
                        -> GHC.Integer.Type.divInteger
                             (GHC.Integer.Type.smallInteger
                                (GHC.Prim.uncheckedIShiftRA# ipv (GHC.Prim.negateInt# ipv1)))
                             w } } }
                   1# -> GHC.Real.divZeroError @ GHC.Integer.Type.Integer }) -}
69d92da5d2e845bc4c67d166769fda73
  $w$c_div4 ::
    GHC.Prim.Int#
    -> GHC.Prim.Float#
    -> AronModule.DivType GHC.Types.Int GHC.Types.Float
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Float#) ->
                 case {__pkg_ccall base-4.12.0.0 GHC.Prim.Float#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       GHC.Prim.Float# #)}
                        ww1
                        GHC.Prim.realWorld# of wild { (#,#) ds2 ds3 ->
                 case GHC.Prim.decodeFloat_Int# ds3 of ds4 { (#,#) ipv ipv1 ->
                 let {
                   $j :: GHC.Integer.Type.Integer
                         -> AronModule.DivType GHC.Types.Int GHC.Types.Float
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (ds1 :: GHC.Integer.Type.Integer)[OneShot] ->
                     case GHC.Integer.Type.eqInteger#
                            ds1
                            AronModule.$fDnumDoubleInt1 of wild1 {
                       DEFAULT
                       -> (GHC.Integer.Type.divInteger
                             (GHC.Integer.Type.smallInteger ww)
                             ds1)
                            `cast`
                          (Sub (Sym (AronModule.D:R:DivTypeIntFloat[0])))
                       1#
                       -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                            `cast`
                          (Sub (Sym (AronModule.D:R:DivTypeIntFloat[0]))) }
                 } in
                 case GHC.Prim.<# ipv1 0# of lwild {
                   DEFAULT
                   -> $j
                        (GHC.Integer.Type.shiftLInteger
                           (GHC.Integer.Type.smallInteger ipv)
                           ipv1)
                   1#
                   -> $j
                        (GHC.Integer.Type.smallInteger
                           (GHC.Prim.uncheckedIShiftRA#
                              ipv
                              (GHC.Prim.negateInt# ipv1))) } } }) -}
69d92da5d2e845bc4c67d166769fda73
  $w$c_div5 ::
    GHC.Integer.Type.Integer
    -> GHC.Prim.Double#
    -> AronModule.DivType GHC.Integer.Type.Integer GHC.Types.Double
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer)
                   (ww :: GHC.Prim.Double#) ->
                 case {__pkg_ccall base-4.12.0.0 GHC.Prim.Double#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       GHC.Prim.Double# #)}
                        ww
                        GHC.Prim.realWorld# of wild { (#,#) ds2 ds3 ->
                 case GHC.Integer.Type.decodeDoubleInteger
                        ds3 of ds4 { (#,#) ipv ipv1 ->
                 case GHC.Prim.<# ipv1 0# of lwild {
                   DEFAULT
                   -> let {
                        ds1 :: GHC.Integer.Type.Integer
                        = GHC.Integer.Type.shiftLInteger ipv ipv1
                      } in
                      case GHC.Integer.Type.eqInteger#
                             ds1
                             AronModule.$fDnumDoubleInt1 of wild1 {
                        DEFAULT
                        -> (GHC.Integer.Type.divInteger w ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerDouble[0])))
                        1#
                        -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerDouble[0]))) }
                   1#
                   -> case GHC.Integer.Type.integerToInt ipv of n { DEFAULT ->
                      let {
                        ds1 :: GHC.Integer.Type.Integer
                        = GHC.Integer.Type.smallInteger
                            (GHC.Prim.uncheckedIShiftRA# n (GHC.Prim.negateInt# ipv1))
                      } in
                      case GHC.Integer.Type.eqInteger#
                             ds1
                             AronModule.$fDnumDoubleInt1 of wild1 {
                        DEFAULT
                        -> (GHC.Integer.Type.divInteger w ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerDouble[0])))
                        1#
                        -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerDouble[0]))) } } } } }) -}
69d92da5d2e845bc4c67d166769fda73
  $w$c_div6 ::
    GHC.Integer.Type.Integer
    -> GHC.Prim.Float#
    -> AronModule.DivType GHC.Integer.Type.Integer GHC.Types.Float
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer)
                   (ww :: GHC.Prim.Float#) ->
                 case {__pkg_ccall base-4.12.0.0 GHC.Prim.Float#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       GHC.Prim.Float# #)}
                        ww
                        GHC.Prim.realWorld# of wild { (#,#) ds2 ds3 ->
                 case GHC.Prim.decodeFloat_Int# ds3 of ds4 { (#,#) ipv ipv1 ->
                 case GHC.Prim.<# ipv1 0# of lwild {
                   DEFAULT
                   -> let {
                        ds1 :: GHC.Integer.Type.Integer
                        = GHC.Integer.Type.shiftLInteger
                            (GHC.Integer.Type.smallInteger ipv)
                            ipv1
                      } in
                      case GHC.Integer.Type.eqInteger#
                             ds1
                             AronModule.$fDnumDoubleInt1 of wild1 {
                        DEFAULT
                        -> (GHC.Integer.Type.divInteger w ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerFloat[0])))
                        1#
                        -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerFloat[0]))) }
                   1#
                   -> let {
                        ds1 :: GHC.Integer.Type.Integer
                        = GHC.Integer.Type.smallInteger
                            (GHC.Prim.uncheckedIShiftRA# ipv (GHC.Prim.negateInt# ipv1))
                      } in
                      case GHC.Integer.Type.eqInteger#
                             ds1
                             AronModule.$fDnumDoubleInt1 of wild1 {
                        DEFAULT
                        -> (GHC.Integer.Type.divInteger w ds1)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerFloat[0])))
                        1#
                        -> (GHC.Real.divZeroError @ GHC.Integer.Type.Integer)
                             `cast`
                           (Sub (Sym (AronModule.D:R:DivTypeIntegerFloat[0]))) } } } }) -}
b8a5b7abccaa7df7b0347da6e4ef8251
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Float -> GHC.Types.Float -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,1*U(U)><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Float)
                   (ww2 :: GHC.Types.Float) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = case ww1 of ww3 { GHC.Types.F# ww4 ->
                     GHC.Float.$w$sshowSignedFloat1
                       GHC.Float.$fShowFloat2
                       AronModule.$fShowC6
                       ww4 }
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww3 { GHC.Types.F# ww4 ->
                     GHC.Float.$w$sshowSignedFloat1
                       GHC.Float.$fShowFloat2
                       AronModule.$fShowC6
                       ww4 }
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x1 :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        AronModule.$fShowC5
                        (GHC.CString.unpackAppendCString#
                           AronModule.$fShowC4
                           (f (GHC.Base.++
                                 @ GHC.Types.Char
                                 GHC.Show.showCommaSpace1
                                 (GHC.CString.unpackAppendCString#
                                    AronModule.$fShowC3
                                    (f1
                                       (GHC.CString.unpackAppendCString#
                                          AronModule.$fShowC2
                                          x1))))))
                   1#
                   -> \ (x1 :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           AronModule.$fShowC5
                           (GHC.CString.unpackAppendCString#
                              AronModule.$fShowC4
                              (f (GHC.Base.++
                                    @ GHC.Types.Char
                                    GHC.Show.showCommaSpace1
                                    (GHC.CString.unpackAppendCString#
                                       AronModule.$fShowC3
                                       (f1
                                          (GHC.CString.unpackAppendCString#
                                             AronModule.$fShowC2
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.$fShow(,)2
                                                x1)))))))) }) -}
ee445766ed6bf86235942517c52303bb
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Types.Float
    -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [2] -}
0d31fabbd5aab0bc13d215e2b158ef0a
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode
    -> GHC.Types.Bool
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [2] -}
a1e484d5c226fc76ce5ba6bfcc447f3e
  $w$s$wupdateOrSnocWithKey ::
    (GHC.Types.Char -> v -> v -> v)
    -> GHC.Prim.Char#
    -> v
    -> Data.HashMap.Array.Array#
         (Data.HashMap.Base.Leaf GHC.Types.Char v)
    -> Data.HashMap.Array.Array
         (Data.HashMap.Base.Leaf GHC.Types.Char v)
  {- Arity: 4, Strictness: <L,C(C1(C1(U)))><S,U><L,U><S,U>,
     Inline: [2],
     Unfolding: (\ @ v
                   (w :: GHC.Types.Char -> v -> v -> v)
                   (ww :: GHC.Prim.Char#)
                   (w1 :: v)
                   (w2 :: Data.HashMap.Array.Array#
                            (Data.HashMap.Base.Leaf GHC.Types.Char v)) ->
                 let {
                   exit9 :: v
                            -> Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf GHC.Types.Char v)
                            -> GHC.Prim.Int#
                            -> GHC.Types.Char
                            -> v
                            -> Data.HashMap.Array.Array
                                 (Data.HashMap.Base.Leaf GHC.Types.Char v)
                     <join 5> {- Arity: 5, Strictness: <L,U><S,U><S,U><L,U><L,U> -}
                   = \ (w3 :: v)[OneShot]
                       (ww1 :: Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf GHC.Types.Char v))[OneShot]
                       (ww2 :: GHC.Prim.Int#)[OneShot]
                       (k2 :: GHC.Types.Char)[OneShot]
                       (y1 :: v)[OneShot] ->
                     case GHC.Magic.runRW#
                            @ ('GHC.Types.TupleRep
                                 '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                            @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.HashMap.Array.Array
                                   (Data.HashMap.Base.Leaf GHC.Types.Char v) #)
                            (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.thawSmallArray#
                                    @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                    @ GHC.Prim.RealWorld
                                    ww1
                                    0#
                                    (GHC.Prim.sizeofSmallArray#
                                       @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                       ww1)
                                    s1 of ds2 { (#,#) ipv4 ipv5 ->
                             case GHC.Prim.writeSmallArray#
                                    @ GHC.Prim.RealWorld
                                    @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                    ipv5
                                    ww2
                                    (Data.HashMap.Base.L @ GHC.Types.Char @ v k2 (w k2 w3 y1))
                                    ipv4 of s' { DEFAULT ->
                             case GHC.Prim.unsafeFreezeSmallArray#
                                    @ GHC.Prim.RealWorld
                                    @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                    ipv5
                                    s' of ds3 { (#,#) ipv6 ipv7 ->
                             (# ipv6,
                                Data.HashMap.Array.Array
                                  @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                  ipv7 #) } } }) of ds2 { (#,#) ipv4 ipv5 ->
                     ipv5 }
                 } in
                 letrec {
                   $wgo12 :: GHC.Prim.Char#
                             -> v
                             -> Data.HashMap.Array.Array#
                                  (Data.HashMap.Base.Leaf GHC.Types.Char v)
                             -> GHC.Prim.Int#
                             -> GHC.Prim.Int#
                             -> Data.HashMap.Array.Array
                                  (Data.HashMap.Base.Leaf GHC.Types.Char v)
                     <join 5> {- Arity: 5, Strictness: <L,U><L,U><S,U><S,U><S,U>,
                                 Inline: [2] -}
                   = \ (ww1 :: GHC.Prim.Char#)
                       (w3 :: v)
                       (ww2 :: Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf GHC.Types.Char v))
                       (ww3 :: GHC.Prim.Int#)
                       (ww4 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww3 ww4 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexSmallArray#
                                 @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                 ww2
                                 ww3 of ds1 { Unit# ipv3 ->
                          case ipv3 of wild1 { Data.HashMap.Base.L kx y1 ->
                          case kx of wild2 { GHC.Types.C# y2 ->
                          case GHC.Prim.eqChar# ww1 y2 of lwild1 {
                            DEFAULT -> $wgo12 ww1 w3 ww2 (GHC.Prim.+# ww3 1#) ww4
                            1# -> exit9 w3 ww2 ww3 (GHC.Types.C# ww1) y1 } } } }
                       1#
                       -> case GHC.Magic.runRW#
                                 @ ('GHC.Types.TupleRep
                                      '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                                 @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                      Data.HashMap.Array.Array
                                        (Data.HashMap.Base.Leaf GHC.Types.Char v) #)
                                 (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newSmallArray#
                                         @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                         @ GHC.Prim.RealWorld
                                         (GHC.Prim.+# ww4 1#)
                                         (Data.HashMap.Array.undefinedElem
                                            @ (Data.HashMap.Base.Leaf GHC.Types.Char v))
                                         s1 of ds { (#,#) ipv3 ipv4 ->
                                  case GHC.Prim.copySmallArray#
                                         @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                         @ GHC.Prim.RealWorld
                                         ww2
                                         0#
                                         ipv4
                                         0#
                                         ww4
                                         ipv3 of s2 { DEFAULT ->
                                  case GHC.Prim.writeSmallArray#
                                         @ GHC.Prim.RealWorld
                                         @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                         ipv4
                                         ww4
                                         (Data.HashMap.Base.L
                                            @ GHC.Types.Char
                                            @ v
                                            (GHC.Types.C# ww1)
                                            w3)
                                         s2 of s' { DEFAULT ->
                                  case GHC.Prim.unsafeFreezeSmallArray#
                                         @ GHC.Prim.RealWorld
                                         @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                         ipv4
                                         s' of ds2 { (#,#) ipv5 ipv6 ->
                                  (# ipv5,
                                     Data.HashMap.Array.Array
                                       @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                                       ipv6 #) } } } }) of ds1 { (#,#) ipv3 ipv4 ->
                          ipv4 } }
                 } in
                 $wgo12
                   ww
                   w1
                   w2
                   0#
                   (GHC.Prim.sizeofSmallArray#
                      @ (Data.HashMap.Base.Leaf GHC.Types.Char v)
                      w2)) -}
0ba2884833d557df63c5191d42fdc0d9
  $w$sident' :: GHC.Prim.Int# -> [[GHC.Types.Double]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                 } in
                 case GHC.Prim.># 0# y1 of lwild {
                   DEFAULT
                   -> let {
                        m :: [GHC.Types.Double]
                        = case GHC.Prim.<# 0# ww of lwild1 {
                            DEFAULT -> GHC.Types.[] @ GHC.Types.Double
                            1# -> AronModule.$wxs5 ww }
                      } in
                      letrec {
                        go29 :: GHC.Prim.Int# -> [[GHC.Types.Double]]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ [GHC.Types.Double]
                            (let {
                               n :: [GHC.Types.Double]
                               = let {
                                   y2 :: GHC.Prim.Int# = GHC.Prim.-# y1 x1
                                 } in
                                 case GHC.Prim.<# 0# y2 of lwild1 {
                                   DEFAULT -> GHC.Types.[] @ GHC.Types.Double
                                   1# -> GHC.List.$wunsafeTake @ GHC.Types.Double y2 m }
                             } in
                             let {
                               n1 :: [GHC.Types.Double]
                               = GHC.Types.: @ GHC.Types.Double AronModule.ident'1 n
                             } in
                             case GHC.Prim.<# 0# x1 of lwild1 {
                               DEFAULT -> n1
                               1#
                               -> letrec {
                                    $wgo12 :: [GHC.Types.Double]
                                              -> GHC.Prim.Int# -> [GHC.Types.Double]
                                      {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2] -}
                                    = \ (w :: [GHC.Types.Double]) (ww1 :: GHC.Prim.Int#) ->
                                      case w of wild {
                                        [] -> n1
                                        : y2 ys
                                        -> case ww1 of ds1 {
                                             DEFAULT
                                             -> GHC.Types.:
                                                  @ GHC.Types.Double
                                                  y2
                                                  ($wgo12 ys (GHC.Prim.-# ds1 1#))
                                             1# -> GHC.Types.: @ GHC.Types.Double y2 n1 } }
                                  } in
                                  $wgo12 m x1 })
                            (case GHC.Prim.==# x1 y1 of lwild1 {
                               DEFAULT -> go29 (GHC.Prim.+# x1 1#)
                               1# -> GHC.Types.[] @ [GHC.Types.Double] })
                      } in
                      go29 0#
                   1# -> GHC.Types.[] @ [GHC.Types.Double] }) -}
ceb510fe665e3ed669690efdcfa8cef1
  $waddR ::
    GHC.Base.String
    -> GHC.Base.String -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Base.String) (w1 :: GHC.Base.String) ->
                 let {
                   n2 :: [GHC.Integer.Type.Integer] = AronModule.splitR w1
                 } in
                 let {
                   n1 :: [GHC.Integer.Type.Integer] = AronModule.splitR w
                 } in
                 let {
                   nn1 :: [GHC.Integer.Type.Integer]
                   = let {
                       lvl264 :: GHC.Integer.Type.Integer
                       = AronModule.addR_go1
                           n2
                           (GHC.List.lastError @ GHC.Integer.Type.Integer)
                     } in
                     GHC.Base.map
                       @ GHC.Integer.Type.Integer
                       @ GHC.Integer.Type.Integer
                       (\ (x1 :: GHC.Integer.Type.Integer) ->
                        GHC.Integer.Type.timesInteger x1 lvl264)
                       n1
                 } in
                 case AronModule.reduce
                        (GHC.Types.:
                           @ GHC.Integer.Type.Integer
                           (case nn1 of wild {
                              [] -> case GHC.List.badHead ret_ty GHC.Integer.Type.Integer of {}
                              : x1 ds1
                              -> case n2 of wild1 {
                                   [] -> case GHC.List.badHead ret_ty GHC.Integer.Type.Integer of {}
                                   : y1 ys
                                   -> let {
                                        exit9 :: GHC.Integer.Type.Integer
                                                 -> GHC.Integer.Type.Integer
                                          <join 1> {- Arity: 1, Strictness: <S,U> -}
                                        = \ (eta :: GHC.Integer.Type.Integer)[OneShot] ->
                                          GHC.Integer.Type.plusInteger
                                            x1
                                            (GHC.Integer.Type.timesInteger y1 eta)
                                      } in
                                      letrec {
                                        go29 :: [GHC.Integer.Type.Integer]
                                                -> GHC.Integer.Type.Integer
                                                -> GHC.Integer.Type.Integer
                                          <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                                        = \ (ds :: [GHC.Integer.Type.Integer])
                                            (eta :: GHC.Integer.Type.Integer) ->
                                          case ds of wild2 {
                                            [] -> exit9 eta : y2 ys1 -> go29 ys1 y2 }
                                      } in
                                      go29 n1 (GHC.List.lastError @ GHC.Integer.Type.Integer) } })
                           (GHC.List.tail @ GHC.Integer.Type.Integer nn1)) of wild {
                   []
                   -> case GHC.List.badHead
                      ret_ty (# GHC.Types.Char, [GHC.Types.Char] #)
                      of {}
                   : x1 ds1
                   -> case GHC.Show.$w$cshowsPrec4
                             0#
                             x1
                             (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                      case GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (GHC.CString.unpackAppendCString#
                                AronModule.addR1
                                (AronModule.addR_go
                                   wild
                                   (GHC.List.lastError @ GHC.Integer.Type.Integer)))
                             ww3
                             ww4 of ww { : ww1 ww5 ->
                      (# ww1, ww5 #) } } }) -}
c5e55437782c17289aecdad758cdfe13
  $wbinsert ::
    AronModule.Tree GHC.Integer.Type.Integer
    -> AronModule.Tree GHC.Integer.Type.Integer
    -> (# GHC.Integer.Type.Integer,
          AronModule.Tree GHC.Integer.Type.Integer,
          AronModule.Tree GHC.Integer.Type.Integer #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [2] -}
ea52b3ca91faa8e83d9f4b5930b962cf
  $wcharToStrictByteString ::
    GHC.Prim.Char# -> Data.ByteString.Internal.ByteString
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Char#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.ByteString.Internal.ByteString #)
                        (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newPinnedByteArray#
                                @ GHC.Prim.RealWorld
                                1#
                                s of ds { (#,#) ipv ipv1 ->
                         let {
                           ipv2 :: GHC.Prim.Addr#
                           = GHC.Prim.byteArrayContents#
                               ipv1
                                 `cast`
                               (UnsafeCo representational (GHC.Prim.MutableByteArray#
                                                             GHC.Prim.RealWorld) GHC.Prim.ByteArray#)
                         } in
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                ipv2
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.int2Word# (GHC.Prim.ord# ww)))
                                ipv of s2 { DEFAULT ->
                         let {
                           ipv3 :: GHC.ForeignPtr.ForeignPtrContents
                           = GHC.ForeignPtr.PlainPtr ipv1
                         } in
                         case GHC.Prim.touch#
                                @ 'GHC.Types.LiftedRep
                                @ GHC.ForeignPtr.ForeignPtrContents
                                ipv3
                                s2 of s' { DEFAULT ->
                         (# s',
                            Data.ByteString.Internal.PS
                              ipv2
                              ipv3
                              0#
                              1# #) } } }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
bb2aa77063f04f3f654391cbae965bf5
  $wcontainsTries ::
    GHC.Base.String
    -> Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: [2] -}
cf4fe65fc030e8455782bd1539bcf612
  $wdf ::
    GHC.Num.Num a =>
    (a -> a -> a) -> (GHC.Real.Rational -> a) -> (a -> a) -> a -> a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A)><C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,C(U)><L,U>,
     Inline: [2],
     Unfolding: (\ @ a1
                   (ww :: GHC.Num.Num a1)
                   (ww1 :: a1 -> a1 -> a1)
                   (ww2 :: GHC.Real.Rational -> a1)
                   (w :: a1 -> a1)
                   (w1 :: a1) ->
                 let {
                   h :: a1 = ww2 AronModule.df1
                 } in
                 ww1
                   (case ww of ww3 { GHC.Num.C:Num ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                    ww5 (w (ww4 w1 h)) (w w1) })
                   h) -}
4a668340416ed30eaeae35a2b30934ba
  $wdiag1 :: [[a]] -> (# a, [a] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
3ac8cdcdc4d87d2177f40e9ffa64852e
  $wdivI ::
    GHC.Num.Num a =>
    (a -> a -> a)
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a1
                   (ww :: GHC.Num.Num a1)
                   (ww1 :: a1 -> a1 -> a1)
                   (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 ww1
                   (GHC.Num.fromInteger @ a1 ww w)
                   (GHC.Num.fromInteger @ a1 ww w1)) -}
33905c6623858d0a47c6143daaeb7a32
  $wdrop' :: (n -> GHC.Integer.Type.Integer) -> n -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ n
                   @ a1
                   (ww :: n -> GHC.Integer.Type.Integer)
                   (w :: n)
                   (w1 :: [a1]) ->
                 case GHC.Integer.Type.integerToInt (ww w) of wild { DEFAULT ->
                 case GHC.Prim.<=# wild 0# of lwild {
                   DEFAULT -> AronModule.$wunsafeDrop @ a1 wild w1 1# -> w1 } }) -}
ac955821914a11f1dbe1bfb9d84664ae
  $wf' ::
    GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [2] -}
2969b6ec4f10bca5270b97fc8e2956fa
  $wfail ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (GHC.Magic.noinline
                    @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                    GHC.IO.failIO1
                      `cast`
                    (forall (a1 :: <*>_N).
                     <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                    @ [GHC.Base.String]
                    AronModule.compileHaskellToBin9)
                   `cast`
                 (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)
                   w) -}
f0e54303ed2c8cd4769af02d6ad928b3
  $wfindBalance ::
    [(GHC.Integer.Type.Integer, GHC.Base.String)]
    -> GHC.Base.String
    -> (# [(GHC.Integer.Type.Integer, GHC.Base.String)],
          GHC.Types.Bool #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
6c3203d04e8e4e818210cece28bcbb81
  $wgo1 ::
    [GHC.Types.Double]
    -> [GHC.Types.Double] -> GHC.Prim.Double# -> GHC.Types.Double
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><S,U>m,
     Inline: [2] -}
c06069db475fad34a0bf1e6237340480
  $wgo2 ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><S,U>,
     Inline: [2] -}
cb07ec7bf19ecaf1b87bc42495beb922
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set GHC.Base.String
    -> [GHC.Base.String]
    -> Data.Set.Internal.Set GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [2] -}
db5019af8ce7a55328e2d12c14012feb
  $wgo5 ::
    [GHC.Types.Int]
    -> [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><S,U>m,
     Inline: [2] -}
caf018d99702480ee431627f95a83b4d
  $wgo6 ::
    [GHC.Real.Ratio GHC.Integer.Type.Integer]
    -> [GHC.Real.Ratio GHC.Integer.Type.Integer]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Real.Rational
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,U><L,U>m, Inline: [2] -}
c20fdfcb36b2794025b7fd3c7df0b655
  $wgo7 ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><S,U>,
     Inline: [2] -}
a32c8bc67d32271928c6fb96b063ea72
  $wgo8 ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><S,U>,
     Inline: [2] -}
0a08bb7184bca0ea61fc01f9c7b20494
  $wident' :: GHC.Num.Num a => GHC.Prim.Int# -> [[a]]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [2],
     Unfolding: (\ @ a1 (w :: GHC.Num.Num a1) (ww :: GHC.Prim.Int#) ->
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                 } in
                 case GHC.Prim.># 0# y1 of lwild {
                   DEFAULT
                   -> let {
                        lvl264 :: a1 = GHC.Num.fromInteger @ a1 w AronModule.df3
                      } in
                      let {
                        m :: [a1]
                        = case GHC.Prim.<# 0# ww of lwild1 {
                            DEFAULT -> GHC.Types.[] @ a1
                            1#
                            -> let {
                                 x1 :: a1 = GHC.Num.fromInteger @ a1 w AronModule.$fDnumDoubleInt1
                               } in
                               let {
                                 lvl265 :: [a1] = GHC.Types.: @ a1 x1 (GHC.Types.[] @ a1)
                               } in
                               letrec {
                                 $wxs9 :: GHC.Prim.Int# -> [a1]
                                   {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
                                 = \ (ww1 :: GHC.Prim.Int#) ->
                                   case ww1 of ds1 {
                                     DEFAULT -> GHC.Types.: @ a1 x1 ($wxs9 (GHC.Prim.-# ds1 1#))
                                     1# -> lvl265 }
                               } in
                               $wxs9 ww }
                      } in
                      letrec {
                        go29 :: GHC.Prim.Int# -> [[a1]] {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ [a1]
                            (let {
                               n :: [a1]
                               = let {
                                   y2 :: GHC.Prim.Int# = GHC.Prim.-# y1 x1
                                 } in
                                 case GHC.Prim.<# 0# y2 of lwild1 {
                                   DEFAULT -> GHC.Types.[] @ a1
                                   1# -> GHC.List.$wunsafeTake @ a1 y2 m }
                             } in
                             let {
                               n1 :: [a1] = GHC.Types.: @ a1 lvl264 n
                             } in
                             case GHC.Prim.<# 0# x1 of lwild1 {
                               DEFAULT -> n1
                               1#
                               -> letrec {
                                    $wgo12 :: [a1] -> GHC.Prim.Int# -> [a1]
                                      {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2] -}
                                    = \ (w1 :: [a1]) (ww1 :: GHC.Prim.Int#) ->
                                      case w1 of wild {
                                        [] -> n1
                                        : y2 ys
                                        -> case ww1 of ds1 {
                                             DEFAULT
                                             -> GHC.Types.: @ a1 y2 ($wgo12 ys (GHC.Prim.-# ds1 1#))
                                             1# -> GHC.Types.: @ a1 y2 n1 } }
                                  } in
                                  $wgo12 m x1 })
                            (case GHC.Prim.==# x1 y1 of lwild1 {
                               DEFAULT -> go29 (GHC.Prim.+# x1 1#) 1# -> GHC.Types.[] @ [a1] })
                      } in
                      go29 0#
                   1# -> GHC.Types.[] @ [a1] }) -}
c33d54e49f47588fcbabd325ced9b6bb
  $winsertNode ::
    GHC.Classes.Ord a =>
    AronModule.Tree a
    -> a -> (# a, AronModule.Tree a, AronModule.Tree a #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>,
     Inline: [2] -}
d030dda90b90d559550f1c993782416f
  $winsertTries ::
    GHC.Base.String
    -> Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode
    -> GHC.Types.Bool
    -> (# Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode,
          GHC.Types.Bool #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [2] -}
4e29753f450e42686bb9355be037614d
  $winsertTriesList ::
    [GHC.Base.String]
    -> Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode
    -> GHC.Types.Bool
    -> (# Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode,
          GHC.Types.Bool #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [2] -}
2bb8b28769b224f1642f15c89e51abf7
  $winverse ::
    [[GHC.Types.Double]]
    -> (# [[GHC.Types.Double]], [[GHC.Base.String]] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
b29a05cc1b950cbb287f7c467a3c02f3
  $wisBalanced2 ::
    GHC.Base.String
    -> GHC.Base.String -> (# GHC.Base.String, GHC.Types.Bool #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
196df3dda8db300c8a8b75ab15e8c7dd
  $wlvl :: GHC.Prim.Char# -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Char#) ->
                 let {
                   x1 :: GHC.Prim.Word# = GHC.Prim.int2Word# (GHC.Prim.ord# ww)
                 } in
                 case GHC.Prim.leWord# x1 887## of lwild {
                   DEFAULT
                   -> case {__pkg_ccall base-4.12.0.0 GHC.Prim.Int#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Int# #)}
                             (GHC.Prim.ord# ww)
                             GHC.Prim.realWorld# of wild { (#,#) ds ds1 ->
                      case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } }
                   1#
                   -> case x1 of wild {
                        DEFAULT
                        -> case GHC.Prim.leWord#
                                  (GHC.Prim.minusWord# wild 9##)
                                  4## of lwild1 {
                             DEFAULT
                             -> case wild of wild1 {
                                  DEFAULT -> GHC.Types.True 160## -> GHC.Types.False }
                             1# -> GHC.Types.False }
                        32## -> GHC.Types.False } }) -}
902aa06e065475ac23632a201f40ccad
  $wlvl1 :: GHC.Prim.Char# -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Char#) ->
                 let {
                   x1 :: GHC.Prim.Word# = GHC.Prim.int2Word# (GHC.Prim.ord# ww)
                 } in
                 case GHC.Prim.leWord# x1 887## of lwild {
                   DEFAULT
                   -> case {__pkg_ccall base-4.12.0.0 GHC.Prim.Int#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            GHC.Prim.Int# #)}
                             (GHC.Prim.ord# ww)
                             GHC.Prim.realWorld# of wild { (#,#) ds ds1 ->
                      case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } }
                   1#
                   -> case x1 of wild {
                        DEFAULT
                        -> case GHC.Prim.leWord#
                                  (GHC.Prim.minusWord# wild 9##)
                                  4## of lwild1 {
                             DEFAULT
                             -> case wild of wild1 {
                                  DEFAULT -> GHC.Types.True 160## -> GHC.Types.False }
                             1# -> GHC.Types.False }
                        32## -> GHC.Types.False } }) -}
c99e5ae1647698c3a0f3d03a088dc923
  $wmultR ::
    GHC.Base.String
    -> GHC.Base.String -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Base.String) (w1 :: GHC.Base.String) ->
                 case AronModule.reduce
                        (AronModule.multR_go2
                           (AronModule.splitR w)
                           (AronModule.splitR w1)) of wild {
                   []
                   -> case GHC.List.badHead
                      ret_ty (# GHC.Types.Char, [GHC.Types.Char] #)
                      of {}
                   : x1 ds1
                   -> case GHC.Show.$w$cshowsPrec4
                             0#
                             x1
                             (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                      case GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (GHC.CString.unpackAppendCString#
                                AronModule.addR1
                                (AronModule.addR_go
                                   wild
                                   (GHC.List.lastError @ GHC.Integer.Type.Integer)))
                             ww3
                             ww4 of ww { : ww1 ww5 ->
                      (# ww1, ww5 #) } } }) -}
8a20184c415f9ab238dccac8b30534b8
  $woneRoot ::
    (GHC.Types.Double -> GHC.Types.Double)
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Prim.Double#
    -> GHC.Maybe.Maybe GHC.Types.Double
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(S(S)),C(U(U))><L,U(U)><L,U(U)><S,U>, Inline: [2] -}
9ece6c6f71bda48c677baedde825bf24
  $wouter ::
    GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Text.Internal.Text #)
  {- Arity: 5, Strictness: <L,U><S,U><S,1*U><S,U><S,U>,
     Inline: [2] -}
416511e54e0a93e528cd73fdd5fc8202
  $wouter1 ::
    GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Text.Internal.Text #)
  {- Arity: 5, Strictness: <L,U><S,U><S,1*U><S,U><S,U>,
     Inline: [2] -}
8eb49c9530669218941c5ba690a5c2a8
  $wouter2 ::
    GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Text.Internal.Text #)
  {- Arity: 5, Strictness: <L,U><S,U><S,1*U><S,U><S,U>,
     Inline: [2] -}
4c7c295f0778a2b3bb51ddcae0772f89
  $wpad :: [GHC.Types.Char] -> GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
4c64eef53f54bec8e692b81533158c28
  $wpad1 :: [GHC.Types.Char] -> GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
b8916af482f9716ca7c83d92d1d85068
  $wpoly_go1 ::
    GHC.Prim.Word#
    -> GHC.Prim.Char#
    -> v
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap GHC.Types.Char v
    -> Data.HashMap.Base.HashMap GHC.Types.Char v
  {- Arity: 5, Strictness: <S,U><L,U><L,U><L,U><S,1*U>,
     Inline: [2] -}
77269c856b86e7a9dcc5362c801fd6a2
  $wpoly_go2 ::
    GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> v
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
  {- Arity: 5, Strictness: <S,U><S,1*U><L,U><L,U><S,1*U>,
     Inline: [2] -}
ee7ce33b7580b676fdd6e6751353b1f5
  $wpoly_go3 ::
    GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
    -> (# (# #) | v #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U><S,1*U>,
     Inline: [2] -}
94097584a2e8a55a1e79f2d61895427e
  $wpoly_go4 ::
    GHC.Prim.Word#
    -> GHC.Prim.Char#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap GHC.Types.Char v
    -> (# (# #) | v #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [2] -}
8b948cdf44c5b13f573de2a0e31bb98e
  $wpoly_go5 ::
    GHC.Prim.Word#
    -> GHC.Base.String
    -> v
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap GHC.Base.String v
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.HashMap.Base.HashMap GHC.Base.String v #)
  {- Arity: 6, Strictness: <L,U><S,1*U><L,U><L,U><S,1*U><L,U>,
     Inline: [2] -}
9e1f4fe656ee57246a6906c14d9f8aa3
  $wpp :: GHC.Prim.Int# -> [a] -> [[a]]
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
68bb4eb99471d2492c4d3a8b43b0c428
  $wqrDecompose' ::
    [[GHC.Types.Double]]
    -> (# [[GHC.Types.Double]], [[GHC.Types.Double]] #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [2],
     Unfolding: (\ (w :: [[GHC.Types.Double]]) ->
                 let {
                   vx :: [[[GHC.Types.Double]]]
                   = GHC.Base.map
                       @ [GHC.Types.Double]
                       @ [[GHC.Types.Double]]
                       AronModule.qrDecompose'2
                       (AronModule.tran @ GHC.Types.Double w)
                 } in
                 let {
                   ex :: [[[GHC.Types.Double]]]
                   = case vx of wild {
                       [] -> case GHC.List.scanl2 ret_ty [[[GHC.Types.Double]]] of {}
                       : ds1 xs
                       -> GHC.List.reverse1
                            @ [[GHC.Types.Double]]
                            (GHC.Base.map
                               @ [[GHC.Types.Double]]
                               @ [[GHC.Types.Double]]
                               AronModule.normList_$snormList
                               (AronModule.qrDecompose'_$srejection
                                  (GHC.List.$wunsafeTake @ [[GHC.Types.Double]] 1# wild)
                                  xs))
                            (GHC.Types.[] @ [[GHC.Types.Double]]) }
                 } in
                 (# AronModule.tran
                      @ GHC.Types.Double
                      (GHC.Base.map
                         @ [[GHC.Types.Double]]
                         @ [GHC.Types.Double]
                         AronModule.qrDecompose'1
                         ex),
                    AronModule.qrDecompose'_go
                      0#
                      (AronModule.qrDecompose'_$srMatrixUpperTri ex vx) #)) -}
acc14721a2509522001f59fdedb89ae2
  $wrandomDouble ::
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Double] #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.<# 0# ww of lwild {
                   DEFAULT -> (# w, GHC.Types.[] @ GHC.Types.Double #)
                   1# -> AronModule.$wxs6 ww w }) -}
a98007fcdd3962a37fa4453955eeb745
  $wrandomFloat ::
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Float] #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.<# 0# ww of lwild {
                   DEFAULT -> (# w, GHC.Types.[] @ GHC.Types.Float #)
                   1# -> AronModule.$wxs7 ww w }) -}
c85cf10efd4c246b4258166585e49384
  $wrandomFrac ::
    GHC.Real.Fractional a =>
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
  {- Arity: 3, Strictness: <L,U(A,A,A,C(U))><S,U><S,U>, Inline: [2],
     Unfolding: (\ @ a1
                   (w :: GHC.Real.Fractional a1)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.<# 0# ww of lwild {
                   DEFAULT -> (# w1, GHC.Types.[] @ a1 #)
                   1#
                   -> letrec {
                        $wxs9 :: GHC.Prim.Int#
                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a1] #)
                          {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2] -}
                        = \ (ww1 :: GHC.Prim.Int#)
                            (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case ww1 of ds1 {
                            DEFAULT
                            -> case AronModule.drawInteger1
                                      AronModule.$fDnumDoubleInt1
                                      AronModule.randomFrac2
                                      w2 of ds { (#,#) ipv ipv1 ->
                               case $wxs9 (GHC.Prim.-# ds1 1#) ipv of ds2 { (#,#) ipv2 ipv3 ->
                               (# ipv2,
                                  GHC.Types.:
                                    @ a1
                                    (case w of ww2 { GHC.Real.C:Fractional ww3 ww4 ww5 ww6 ->
                                     ww6
                                       (case ipv1 of wild { GHC.Types.I# i ->
                                        case GHC.Float.$w$ctoRational
                                               (GHC.Prim./##
                                                  (GHC.Prim.int2Double# i)
                                                  100.0##) of ww7 { (#,#) ww8 ww9 ->
                                        GHC.Real.:% @ GHC.Integer.Type.Integer ww8 ww9 } }) })
                                    ipv3 #) } }
                            1#
                            -> case AronModule.drawInteger1
                                      AronModule.$fDnumDoubleInt1
                                      AronModule.randomFrac2
                                      w2 of ds { (#,#) ipv ipv1 ->
                               (# ipv,
                                  GHC.Types.:
                                    @ a1
                                    (case w of ww2 { GHC.Real.C:Fractional ww3 ww4 ww5 ww6 ->
                                     ww6
                                       (case ipv1 of wild { GHC.Types.I# i ->
                                        case GHC.Float.$w$ctoRational
                                               (GHC.Prim./##
                                                  (GHC.Prim.int2Double# i)
                                                  100.0##) of ww7 { (#,#) ww8 ww9 ->
                                        GHC.Real.:% @ GHC.Integer.Type.Integer ww8 ww9 } }) })
                                    (GHC.Types.[] @ a1) #) } }
                      } in
                      $wxs9 ww w1 }) -}
59d4309a2d58e7f8d76cb0d8c930c7c1
  $wrandomList ::
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [GHC.Integer.Type.Integer] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2] -}
d8b7bb00729b86b8657cc8f08e60760d
  $wrandomMatrix ::
    GHC.Num.Num a =>
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [[a]] #)
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S,1*U><L,1*U(1*U)><S,U>,
     Inline: [2],
     Unfolding: (\ @ a1
                   (w :: GHC.Num.Num a1)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ww of ds {
                   DEFAULT
                   -> case w1 of wild { GHC.Types.I# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> letrec {
                             $wloop :: GHC.Prim.Int#
                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                             [[GHC.Integer.Type.Integer]] #)
                               {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
                             = \ (ww1 :: GHC.Prim.Int#)
                                 (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                               case GHC.Prim.<=# ww1 0# of lwild {
                                 DEFAULT
                                 -> case AronModule.$wrandomList ds2 w3 of ds3 { (#,#) ipv ipv1 ->
                                    case $wloop (GHC.Prim.-# ww1 1#) ipv of ds4 { (#,#) ipv2 ipv3 ->
                                    (# ipv2,
                                       GHC.Types.: @ [GHC.Integer.Type.Integer] ipv1 ipv3 #) } }
                                 1# -> (# w3, GHC.Types.[] @ [GHC.Integer.Type.Integer] #) }
                           } in
                           case $wloop ds w2 of ds3 { (#,#) ipv ipv1 ->
                           (# ipv,
                              GHC.Base.map
                                @ [GHC.Integer.Type.Integer]
                                @ [a1]
                                (GHC.Base.map
                                   @ GHC.Integer.Type.Integer
                                   @ a1
                                   (\ (w3 :: GHC.Integer.Type.Integer) ->
                                    case w of ww1 { GHC.Num.C:Num ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                                    ww8 w3 }))
                                ipv1 #) }
                        0# -> (# w2, GHC.Types.[] @ [a1] #) } }
                   0# -> (# w2, GHC.Types.[] @ [a1] #) }) -}
be0faff6ee36e556ffd8b1b59d15442f
  $wrep2d ::
    (n1 -> GHC.Integer.Type.Integer)
    -> GHC.Real.Integral n2 => [[a]] -> n1 -> n2 -> a -> [[a]]
  {- Arity: 6,
     Strictness: <C(S),C(U)><L,U(A,A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ n
                   @ n1
                   @ a1
                   (ww :: n -> GHC.Integer.Type.Integer)
                   (w :: GHC.Real.Integral n1)
                   (w1 :: [[a1]])
                   (w2 :: n)
                   (w3 :: n1)
                   (w4 :: a1) ->
                 case GHC.Integer.Type.integerToInt (ww w2) of wild { DEFAULT ->
                 let {
                   karg :: [a1]
                   = case GHC.Integer.Type.integerToInt
                            (GHC.Real.toInteger @ n1 w w3) of wild1 { DEFAULT ->
                     let {
                       s :: [a1]
                       = case AronModule.$wdrop' @ n @ [a1] ww w2 w1 of wild2 {
                           [] -> GHC.List.badHead @ [a1] : x1 ds1 -> x1 }
                     } in
                     case GHC.Prim.<# 0# wild1 of lwild {
                       DEFAULT
                       -> GHC.Base.++
                            @ a1
                            (GHC.Types.[] @ a1)
                            (GHC.Types.:
                               @ a1
                               w4
                               (case w of ww1 { GHC.Real.C:Integral ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                                case AronModule.$wdrop' @ n1 @ a1 ww10 w3 s of wild2 {
                                  [] -> GHC.List.scanl2 @ a1 : ds1 xs -> xs } }))
                       1#
                       -> GHC.Base.++
                            @ a1
                            (GHC.List.$wunsafeTake @ a1 wild1 s)
                            (GHC.Types.:
                               @ a1
                               w4
                               (case w of ww1 { GHC.Real.C:Integral ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                                case AronModule.$wdrop' @ n1 @ a1 ww10 w3 s of wild2 {
                                  [] -> GHC.List.scanl2 @ a1 : ds1 xs -> xs } })) } }
                 } in
                 case GHC.Prim.<# 0# wild of lwild {
                   DEFAULT
                   -> GHC.Base.++
                        @ [a1]
                        (GHC.Types.[] @ [a1])
                        (GHC.Types.:
                           @ [a1]
                           karg
                           (case AronModule.$wdrop' @ n @ [a1] ww w2 w1 of wild1 {
                              [] -> GHC.List.scanl2 @ [a1] : ds1 xs -> xs }))
                   1#
                   -> GHC.Base.++
                        @ [a1]
                        (GHC.List.$wunsafeTake @ [a1] wild w1)
                        (GHC.Types.:
                           @ [a1]
                           karg
                           (case AronModule.$wdrop' @ n @ [a1] ww w2 w1 of wild1 {
                              [] -> GHC.List.scanl2 @ [a1] : ds1 xs -> xs })) } }) -}
5f393966dc811593173347e4aebbac1f
  $wreplicate' :: GHC.Prim.Int# -> a -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [2],
     Unfolding: (\ @ a1 (ww :: GHC.Prim.Int#) (w :: a1) ->
                 case GHC.Prim.<# 0# ww of lwild {
                   DEFAULT -> GHC.Types.[] @ a1
                   1#
                   -> let {
                        lvl264 :: [a1] = GHC.Types.: @ a1 w (GHC.Types.[] @ a1)
                      } in
                      letrec {
                        $wxs9 :: GHC.Prim.Int# -> [a1]
                          {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
                        = \ (ww1 :: GHC.Prim.Int#) ->
                          case ww1 of ds1 {
                            DEFAULT -> GHC.Types.: @ a1 w ($wxs9 (GHC.Prim.-# ds1 1#))
                            1# -> lvl264 }
                      } in
                      $wxs9 ww }) -}
bc66647385cded2fbf7f3741a2ba051e
  $wsieve ::
    [GHC.Integer.Type.Integer]
    -> (# GHC.Integer.Type.Integer, [GHC.Integer.Type.Integer] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
487c4b9d6d9eb16caa1bab22974f27ee
  $wsplitList ::
    [GHC.Base.String] -> (# [GHC.Base.String], [GHC.Base.String] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
573f0e3979f2cf2811bb6c39b3af67aa
  $wsplitStrT ::
    GHC.Base.String
    -> GHC.Base.String -> (# GHC.Base.String, GHC.Base.String #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [2] -}
236b02df344f409afe280ef38c623206
  $wsqVec ::
    GHC.Classes.Ord a =>
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> GHC.Prim.Array# a -> Data.Vector.Vector a
  {- Arity: 4,
     Strictness: <L,U(A,A,C(C1(U)),A,C(C1(U)),A,A,A)><S,U><S,1*U><L,U>,
     Inline: [2] -}
3b5aa035061651858eb16ff407b1e166
  $wsqrtC :: AronModule.C -> (# GHC.Types.Float, GHC.Types.Float #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: (\ (w :: AronModule.C) ->
                 let {
                   ds :: (GHC.Types.Float, GHC.Types.Float)
                   = case w of wild { AronModule.C x1 y1 ->
                     let {
                       r :: GHC.Types.Float
                       = case x1 of wild1 { GHC.Types.F# x2 ->
                         case y1 of wild2 { GHC.Types.F# x3 ->
                         GHC.Types.F#
                           (GHC.Prim.sqrtFloat#
                              (GHC.Prim.plusFloat#
                                 (GHC.Prim.timesFloat# x2 x2)
                                 (GHC.Prim.timesFloat# x3 x3))) } }
                     } in
                     (r,
                      case x1 of wild1 { GHC.Types.F# x2 ->
                      case r of wild2 { GHC.Types.F# y2 ->
                      case GHC.Prim.divideFloat# x2 y2 of wild3 { DEFAULT ->
                      case GHC.Prim.acosFloat# wild3 of wild4 { DEFAULT ->
                      GHC.Types.F# wild4 } } } }) }
                 } in
                 let {
                   r :: GHC.Types.Float
                   = case ds of wild { (,) r1 a1 ->
                     case r1 of wild1 { GHC.Types.F# x1 ->
                     GHC.Types.F# (GHC.Prim.sqrtFloat# x1) } }
                 } in
                 let {
                   a1 :: GHC.Types.Float
                   = case ds of wild { (,) r1 a2 ->
                     case a2 of wild1 { GHC.Types.F# x1 ->
                     GHC.Types.F# (GHC.Prim.divideFloat# x1 2.0#) } }
                 } in
                 (# case r of wild { GHC.Types.F# x1 ->
                    case a1 of wild1 { GHC.Types.F# x2 ->
                    GHC.Types.F# (GHC.Prim.timesFloat# x1 (GHC.Prim.cosFloat# x2)) } },
                    case r of wild { GHC.Types.F# x1 ->
                    case a1 of wild1 { GHC.Types.F# x2 ->
                    GHC.Types.F#
                      (GHC.Prim.timesFloat# x1 (GHC.Prim.sinFloat# x2)) } } #)) -}
3bda8083aaafeefcfb226c39b6e6169c
  $wsqrtC' :: AronModule.C -> (# GHC.Types.Float, GHC.Types.Float #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: (\ (w :: AronModule.C) ->
                 let {
                   ds :: (GHC.Types.Float, GHC.Types.Float)
                   = case w of wild { AronModule.C x1 y1 ->
                     let {
                       r :: GHC.Types.Float
                       = case x1 of wild1 { GHC.Types.F# x2 ->
                         case y1 of wild2 { GHC.Types.F# x3 ->
                         GHC.Types.F#
                           (GHC.Prim.sqrtFloat#
                              (GHC.Prim.plusFloat#
                                 (GHC.Prim.timesFloat# x2 x2)
                                 (GHC.Prim.timesFloat# x3 x3))) } }
                     } in
                     (r,
                      case x1 of wild1 { GHC.Types.F# x2 ->
                      case r of wild2 { GHC.Types.F# y2 ->
                      case GHC.Prim.divideFloat# x2 y2 of wild3 { DEFAULT ->
                      case GHC.Prim.acosFloat# wild3 of wild4 { DEFAULT ->
                      GHC.Types.F# wild4 } } } }) }
                 } in
                 let {
                   r :: GHC.Types.Float
                   = case ds of wild { (,) r1 a1 ->
                     case r1 of wild1 { GHC.Types.F# x1 ->
                     GHC.Types.F# (GHC.Prim.negateFloat# (GHC.Prim.sqrtFloat# x1)) } }
                 } in
                 let {
                   a1 :: GHC.Types.Float
                   = case ds of wild { (,) r1 a2 ->
                     case a2 of wild1 { GHC.Types.F# x1 ->
                     GHC.Types.F# (GHC.Prim.divideFloat# x1 2.0#) } }
                 } in
                 (# case r of wild { GHC.Types.F# x1 ->
                    case a1 of wild1 { GHC.Types.F# x2 ->
                    GHC.Types.F# (GHC.Prim.timesFloat# x1 (GHC.Prim.cosFloat# x2)) } },
                    case r of wild { GHC.Types.F# x1 ->
                    case a1 of wild1 { GHC.Types.F# x2 ->
                    GHC.Types.F#
                      (GHC.Prim.timesFloat# x1 (GHC.Prim.sinFloat# x2)) } } #)) -}
63b8739dfd63c3dafab3b3a88fb57aae
  $wstrictBSToString ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,U>, Inline: [2] -}
0fb1aefdcc1ba0d52940f12ac8722679
  $wtake' :: (n -> GHC.Integer.Type.Integer) -> n -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ n
                   @ a1
                   (ww :: n -> GHC.Integer.Type.Integer)
                   (w :: n)
                   (w1 :: [a1]) ->
                 case GHC.Integer.Type.integerToInt (ww w) of wild { DEFAULT ->
                 case GHC.Prim.<# 0# wild of lwild {
                   DEFAULT -> GHC.Types.[] @ a1
                   1# -> GHC.List.$wunsafeTake @ a1 wild w1 } }) -}
276101c002b00d344426d747661cb235
  $wtangent ::
    (a -> a -> a)
    -> (a -> a -> a)
    -> (a -> a -> a)
    -> (a -> a -> a)
    -> (GHC.Real.Rational -> a)
    -> (a -> a)
    -> a
    -> a
    -> a
  {- Arity: 8,
     Strictness: <C(C(S)),C(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,1*C1(C1(U))><L,1*C1(U)><L,C(U)><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a1
                   (ww :: a1 -> a1 -> a1)
                   (ww1 :: a1 -> a1 -> a1)
                   (ww2 :: a1 -> a1 -> a1)
                   (ww3 :: a1 -> a1 -> a1)
                   (ww4 :: GHC.Real.Rational -> a1)
                   (w :: a1 -> a1)
                   (w1 :: a1)
                   (w2 :: a1) ->
                 ww
                   (ww2
                      (AronModule.$wdf
                         @ a1
                         (GHC.Num.C:Num
                            @ a1
                            ww
                            ww1
                            ww2
                            (AronModule.tangent3 @ a1)
                            (AronModule.tangent3 @ a1)
                            (AronModule.tangent3 @ a1)
                            (AronModule.tangent1 @ a1))
                         ww3
                         ww4
                         w
                         w2)
                      (ww1 w1 w2))
                   (w w2)) -}
abc9b01817138c0c23db88a34045fda7
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [2] -}
b612f071506e26774f4708675ec8500c
  $wup ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Prim.Int# -> GHC.Types.Int -> [GHC.Integer.Type.Integer]
  {- Arity: 3, Strictness: <L,U><S,U><L,1*U(U)>, Inline: [2] -}
2519cdab49f8f9c9fac245b2b292250d
  $wup1 ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Prim.Int# -> GHC.Types.Int -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <L,U><S,U><L,1*U(U)>, Inline: [2] -}
709e3a7dcb28352e366025c1169fa696
  $wuptri :: [[a]] -> (# [a], [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
007f0d49ae2153ce0842bbabbe7ec7e5
  $wvrow :: [[a]] -> GHC.Prim.Int# -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,U>, Inline: [2],
     Unfolding: (\ @ a1 (w :: [[a1]]) (ww :: GHC.Prim.Int#) ->
                 let {
                   x1 :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                 } in
                 case GHC.Prim.<=# x1 0# of lwild {
                   DEFAULT
                   -> case GHC.Prim.<# 0# ww of lwild1 {
                        DEFAULT -> AronModule.$wunsafeDrop @ [a1] x1 (GHC.Types.[] @ [a1])
                        1#
                        -> AronModule.$wunsafeDrop
                             @ [a1]
                             x1
                             (GHC.List.$wunsafeTake @ [a1] ww w) }
                   1#
                   -> case GHC.Prim.<# 0# ww of lwild1 {
                        DEFAULT -> GHC.Types.[] @ [a1]
                        1# -> GHC.List.$wunsafeTake @ [a1] ww w } }) -}
9104261c8221316b2b111d1dc0e9a569
  $wword :: GHC.Base.String -> (# GHC.Base.String, GHC.Base.String #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
69e47039e886dc74b0442a85443f8f33
  $wwriteToFile2dMat ::
    GHC.Show.Show a =>
    GHC.IO.FilePath
    -> [[a]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,U(A,C(U),A)><L,U><L,U><S,U>,
     Inline: [2],
     Unfolding: (\ @ a1
                   (w :: GHC.Show.Show a1)
                   (w1 :: GHC.IO.FilePath)
                   (w2 :: [[a1]])
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.IO.appendFile2
                   @ ()
                   w1
                   GHC.IO.IOMode.WriteMode
                   (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot] ->
                    GHC.IO.Handle.Text.hPutStr'
                      hdl
                      (Data.OldList.unlines
                         (GHC.Base.map
                            @ [[GHC.Types.Char]]
                            @ [GHC.Types.Char]
                            AronModule.writeToFile2dMat2
                            (AronModule.ppad @ a1 w w2)))
                      GHC.Types.False)
                   w3) -}
19fcc0864fc10b10d8905ae9aac57aa1
  $wxs :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
e1533efdbc149b5511e19f5bfc78e139
  $wxs1 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
cdfcec6a0d9d9585e729c41b1c002a68
  $wxs2 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
0833db4f1fd2483c0510252e56b21372
  $wxs3 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
f2cfc63a19252d9cc17b50937900143d
  $wxs4 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
5d1518cd1bc9a818522f8cef9fb7fd90
  $wxs5 :: GHC.Prim.Int# -> [GHC.Types.Double]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m2, Inline: [2] -}
e93e50c5ace15a3d2f34a975f5fb1629
  $wxs6 ::
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Double] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2] -}
721b770253242ca63b442a70a5ffc53e
  $wxs7 ::
    GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Float] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2] -}
e502c71a3920a531f5ade69ee4c2dba5
  $wzipWith2 :: (a -> a -> a) -> [[a]] -> [[a]] -> [[a]]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ a1
                   (w :: a1 -> a1 -> a1)
                   (w1 :: [[a1]])
                   (w2 :: [[a1]]) ->
                 letrec {
                   go29 :: [a1] -> [a1] -> [a1]
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [a1]) (ds1 :: [a1]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ a1
                       : ipv ipv1
                       -> case ds1 of wild1 {
                            [] -> GHC.Types.[] @ a1
                            : ipv2 ipv3 -> GHC.Types.: @ a1 (w ipv ipv2) (go29 ipv1 ipv3) } }
                 } in
                 letrec {
                   go30 :: [[a1]] -> [[a1]] -> [[a1]]
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [[a1]]) (ds1 :: [[a1]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [a1]
                       : ipv ipv1
                       -> case ds1 of wild1 {
                            [] -> GHC.Types.[] @ [a1]
                            : ipv2 ipv3
                            -> GHC.Types.: @ [a1] (go29 ipv ipv2) (go30 ipv1 ipv3) } }
                 } in
                 go30 w1 w2) -}
8953435ac95f04f496d198d563377119
  (<<<) :: GHC.Show.Show a => GHC.Base.String -> a -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(U),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   ($dShow :: GHC.Show.Show a1)
                   (s :: GHC.Base.String)
                   (a2 :: a1) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b1
                      (c1 :: GHC.Types.Char -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b1 c1 n s)
                   (GHC.Show.show @ a1 $dShow a2)) -}
09de7967b7fa68ac333932f144982214
  class Add a b where
    type family SumTy a b :: * open
    addd :: a -> b -> AronModule.SumTy a b
    {-# MINIMAL addd #-}
333978fdd88953d8934bc07531783829
  data C = C {x :: GHC.Types.Float, y :: GHC.Types.Float}
1ab116b66d03e62dd6e88c3c7847d493
  class Cnum a where
    _sqrt :: a -> GHC.Types.Float
    _sin :: a -> GHC.Types.Float
    _cos :: a -> GHC.Types.Float
    {-# MINIMAL _sqrt, _sin, _cos #-}
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeDoubleInt::
      AronModule.DivType GHC.Types.Double GHC.Types.Int
        = GHC.Integer.Type.Integer
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeDoubleInteger::
      AronModule.DivType GHC.Types.Double GHC.Integer.Type.Integer
        = GHC.Integer.Type.Integer
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeFloatInt::
      AronModule.DivType GHC.Types.Float GHC.Types.Int
        = GHC.Integer.Type.Integer
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeFloatInteger::
      AronModule.DivType GHC.Types.Float GHC.Integer.Type.Integer
        = GHC.Integer.Type.Integer
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeIntFloat::
      AronModule.DivType GHC.Types.Int GHC.Types.Float
        = GHC.Integer.Type.Integer
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeIntegerDouble::
      AronModule.DivType GHC.Integer.Type.Integer GHC.Types.Double
        = GHC.Integer.Type.Integer
69d92da5d2e845bc4c67d166769fda73
  axiom AronModule.D:R:DivTypeIntegerFloat::
      AronModule.DivType GHC.Integer.Type.Integer GHC.Types.Float
        = GHC.Integer.Type.Integer
09de7967b7fa68ac333932f144982214
  axiom AronModule.D:R:SumTyDoubleInt::
      AronModule.SumTy GHC.Types.Double GHC.Types.Int = GHC.Types.Double
09de7967b7fa68ac333932f144982214
  axiom AronModule.D:R:SumTyDoubleInteger::
      AronModule.SumTy GHC.Types.Double GHC.Integer.Type.Integer
        = GHC.Types.Double
09de7967b7fa68ac333932f144982214
  axiom AronModule.D:R:SumTyIntDouble::
      AronModule.SumTy GHC.Types.Int GHC.Types.Double = GHC.Types.Double
09de7967b7fa68ac333932f144982214
  axiom AronModule.D:R:SumTyIntegerDouble::
      AronModule.SumTy GHC.Integer.Type.Integer GHC.Types.Double
        = GHC.Types.Double
09de7967b7fa68ac333932f144982214
  axiom AronModule.D:R:SumTyaa:: AronModule.SumTy a a = a
69d92da5d2e845bc4c67d166769fda73
  class Dnum a b where
    type family DivType a b :: * open
    _div :: a -> b -> AronModule.DivType a b
    {-# MINIMAL _div #-}
efd6cfe0d370ebb78e58dd9620cdc749
  data GPoint = GPoint GHC.Types.Int GHC.Types.Int
b123ffdff179d1a677fe517ac0551fa0
  data Mat = Zero | Id
4c45874df1274e5eea47b5815f9124ec
  data Quaternion
    = Quaternion {a :: GHC.Types.Float,
                  b :: GHC.Types.Float,
                  c :: GHC.Types.Float,
                  d :: GHC.Types.Float}
ee7f704147a2417a2e9d7ca38b6754ab
  data Tree a
    = Empty | Node a (AronModule.Tree a) (AronModule.Tree a)
0d31fabbd5aab0bc13d215e2b158ef0a
  data XNode
    = XNode (Data.HashMap.Base.HashMap GHC.Types.Char AronModule.XNode)
            GHC.Types.Bool
4c45874df1274e5eea47b5815f9124ec
  a :: AronModule.Quaternion -> GHC.Types.Float
  RecSel Left AronModule.Quaternion
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U(U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.Quaternion) ->
                 case ds of wild { AronModule.Quaternion ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
cb0508f99f46fcfd66fb92c77ec8c9e6
  addR :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m2, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: GHC.Base.String) ->
                 case AronModule.$waddR w w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Char ww1 ww2 }) -}
64781bcc3b3b93e46d544fc4372ea5b3
  addR1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
d36562476377e1fe74d42977ea5b09af
  addRL ::
    [GHC.Base.String] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (ds :: [GHC.Base.String])
                   (ds1 :: [GHC.Base.String]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ipv ipv1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.[] @ GHC.Base.String
                        : ipv2 ipv3 -> AronModule.addRL_go2 wild wild1 } }) -}
43f22a32b6eba5d4ec350fd218549986
  addRL_go2 ::
    [[GHC.Types.Char]] -> [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
998db3838018b6235776c7876253b13a
  addR_go ::
    [GHC.Integer.Type.Integer]
    -> GHC.Integer.Type.Integer -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,U>m2 -}
b7bb0d8ac6d45173ea4eda1886892853
  addR_go1 ::
    [GHC.Integer.Type.Integer]
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
f54ae038b5947693e76356e542106c37
  anagram ::
    GHC.Base.String -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s :: GHC.Base.String) (cx :: [GHC.Base.String]) ->
                 let {
                   k1 :: [GHC.Types.Char]
                   = Data.OldList.sortBy
                       @ GHC.Types.Char
                       GHC.Classes.$fOrdChar_$ccompare
                       s
                 } in
                 let {
                   exit9 :: GHC.Prim.Int# -> GHC.Prim.Int# -> [GHC.Base.String]
                     <join 2> {- Arity: 2, Strictness: <S,U><S,U> -}
                   = \ (ww :: GHC.Prim.Int#)[OneShot]
                       (ww1 :: GHC.Prim.Int#)[OneShot] ->
                     case AronModule.$wpoly_go3
                            @ [GHC.Base.String]
                            (GHC.Prim.int2Word#
                               (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) ww1))
                            k1
                            0#
                            (AronModule.anagram_insertMap
                               (Data.HashMap.Base.Empty @ GHC.Base.String @ [GHC.Base.String])
                               cx) of ds {
                       (#_|#) ds1 -> GHC.Types.[] @ GHC.Base.String (#|_#) a1 -> a1 }
                 } in
                 letrec {
                   $wgo12 :: [GHC.Types.Char]
                             -> GHC.Prim.Int# -> GHC.Prim.Int# -> [GHC.Base.String]
                     <join 3> {- Arity: 3, Strictness: <S,1*U><S,U><S,U>, Inline: [2] -}
                   = \ (w1 :: [GHC.Types.Char])
                       (ww :: GHC.Prim.Int#)
                       (ww1 :: GHC.Prim.Int#) ->
                     case w1 of wild {
                       [] -> exit9 ww ww1
                       : y1 ys
                       -> case y1 of wild1 { GHC.Types.C# c# ->
                          $wgo12
                            ys
                            (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) (GHC.Prim.ord# c#))
                            (GHC.Prim.+# ww1 1#) } }
                 } in
                 $wgo12 k1 -2578643520546668380# 0#) -}
afee6d1e113d2aa7d3695362a355d7b4
  anagram_insertMap ::
    Data.HashMap.Base.HashMap GHC.Base.String [GHC.Base.String]
    -> [GHC.Base.String]
    -> Data.HashMap.Base.HashMap GHC.Base.String [GHC.Base.String]
  {- Arity: 2, Strictness: <S,U><S,1*U> -}
6cf57ff3242ac43a2450fed8b9f47365
  asplitPath :: GHC.IO.FilePath -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.IO.FilePath) ->
                 GHC.Base.build
                   @ [GHC.Types.Char]
                   (\ @ b1
                      (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.List.filterFB
                         @ [GHC.Types.Char]
                         @ b1
                         c1
                         AronModule.asplitPath1)
                      n
                      (Text.Regex.splitRegex AronModule.splitR2 s))) -}
eb99cef687f5246a7818ea3e7b19e701
  asplitPath1 :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: [GHC.Types.Char]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char x1 0# of ww2 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># ww2 0#) }) -}
4c45874df1274e5eea47b5815f9124ec
  b :: AronModule.Quaternion -> GHC.Types.Float
  RecSel Left AronModule.Quaternion
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.Quaternion) ->
                 case ds of wild { AronModule.Quaternion ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
9c99813fed2bdbe5d19054f4281db798
  baseName :: GHC.IO.FilePath -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>,
     Unfolding: InlineRule (0, True, True)
                System.FilePath.Posix.takeBaseName -}
bad1fa014a1f03d6b85ad7d5925bbf49
  baseNameT :: Data.Text.Internal.Text -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <L,1*U(U,U,U)>,
     Unfolding: (\ (s :: Data.Text.Internal.Text) ->
                 case System.FilePath.Posix.$wsplitExtension
                        (case System.FilePath.Posix.$wsplitFileName_
                                (case s of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                                 let {
                                   end :: GHC.Prim.Int# = GHC.Prim.+# dt1 dt2
                                 } in
                                 letrec {
                                   $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                                     {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                                   = \ (ww :: GHC.Prim.Int#) ->
                                     case GHC.Prim.>=# ww end of lwild {
                                       DEFAULT
                                       -> case GHC.Prim.indexWord16Array# dt ww of r# { DEFAULT ->
                                          case GHC.Prim.geWord# r# 55296## of lwild1 {
                                            DEFAULT
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 (GHC.Types.C#
                                                    (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                                 ($wunfold (GHC.Prim.+# ww 1#))
                                            1#
                                            -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                                 DEFAULT
                                                 -> GHC.Types.:
                                                      @ GHC.Types.Char
                                                      (GHC.Types.C#
                                                         (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                                      ($wunfold (GHC.Prim.+# ww 1#))
                                                 1#
                                                 -> case GHC.Prim.indexWord16Array#
                                                           dt
                                                           (GHC.Prim.+# ww 1#) of r#1 { DEFAULT ->
                                                    GHC.Types.:
                                                      @ GHC.Types.Char
                                                      (GHC.Types.C#
                                                         (GHC.Prim.chr#
                                                            (GHC.Prim.+#
                                                               9216#
                                                               (GHC.Prim.+#
                                                                  (GHC.Prim.uncheckedIShiftL#
                                                                     (GHC.Prim.-#
                                                                        (GHC.Prim.word2Int# r#)
                                                                        55296#)
                                                                     10#)
                                                                  (GHC.Prim.word2Int# r#1)))))
                                                      ($wunfold (GHC.Prim.+# ww 2#)) } } } }
                                       1# -> GHC.Types.[] @ GHC.Types.Char }
                                 } in
                                 $wunfold dt1 }) of ww { (#,#) ww1 ww2 ->
                         ww2 }) of ww { (#,#) ww1 ww2 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Text.Internal.Text #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         AronModule.$wouter ipv1 4# ww1 0# ipv }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 } }) -}
c5c49845aac54e2bdacbfd50e892c551
  binarySearch :: GHC.Classes.Ord a => a -> [a] -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A)><L,U><S,1*U> -}
1409894abeade7c277571e53a430a3c9
  binsert ::
    AronModule.Tree GHC.Integer.Type.Integer
    -> AronModule.Tree GHC.Integer.Type.Integer
    -> AronModule.Tree GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m2, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: AronModule.Tree GHC.Integer.Type.Integer)
                   (w1 :: AronModule.Tree GHC.Integer.Type.Integer) ->
                 case AronModule.$wbinsert w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 AronModule.Node @ GHC.Integer.Type.Integer ww1 ww2 ww3 }) -}
998907f0d4bbb6e37218df27585c6b8a
  bs ::
    [[GHC.Types.Double]]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U>,
     Unfolding: (\ (ds :: [[GHC.Types.Double]])
                   (ds1 :: [GHC.Types.Double])
                   (ds2 :: [GHC.Types.Double]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Double
                   : ipv ipv1
                   -> case ds2 of wild1 {
                        [] -> GHC.Types.[] @ GHC.Types.Double
                        : ipv2 ipv3
                        -> AronModule.bs_f
                             (GHC.List.reverse1
                                @ [GHC.Types.Double]
                                wild
                                (GHC.Types.[] @ [GHC.Types.Double]))
                             ds1
                             (GHC.List.reverse1
                                @ GHC.Types.Double
                                wild1
                                (GHC.Types.[] @ GHC.Types.Double)) } }) -}
2459dd980987e19dc4359c78e746b1dc
  bs_f ::
    [[GHC.Types.Double]]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U> -}
3e336ee5a1799286b46cf4c12f7351db
  buildTree ::
    [GHC.Types.Char]
    -> [GHC.Types.Char] -> AronModule.Tree GHC.Types.Char
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
4c45874df1274e5eea47b5815f9124ec
  c :: AronModule.Quaternion -> GHC.Types.Float
  RecSel Left AronModule.Quaternion
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSL),1*U(A,A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.Quaternion) ->
                 case ds of wild { AronModule.Quaternion ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
b78fa0d43425d6974cc5c72df526f833
  c2w_ :: GHC.Types.Char -> GHC.Word.Word8
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.Internal.c2w -}
4558faf1b762bd877a42cf5a16b4e64c
  cat :: [GHC.Base.String] -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b1d7309b8e7a8acf3350b50138294f30
  catMaybe ::
    GHC.Maybe.Maybe [a] -> GHC.Maybe.Maybe [a] -> GHC.Maybe.Maybe [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1
                   (ds :: GHC.Maybe.Maybe [a1])
                   (ds1 :: GHC.Maybe.Maybe [a1]) ->
                 case ds of wild {
                   GHC.Maybe.Nothing -> ds1
                   GHC.Maybe.Just list
                   -> case ds1 of wild1 {
                        GHC.Maybe.Nothing -> GHC.Maybe.Just @ [a1] list
                        GHC.Maybe.Just list2
                        -> GHC.Maybe.Just
                             @ [a1]
                             (GHC.Base.augment
                                @ a1
                                (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                                 GHC.Base.foldr @ a1 @ b1 c1 n list)
                                list2) } }) -}
a0bc8e4776d0aa1c82d22adb557ce611
  cc :: GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Process.callCommand1
                  `cast`
                (<GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
86704159eef553683302f3b57438a679
  cd :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Posix.Directory.changeWorkingDirectory1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
c31c1a4da988377ff8e88d3923d0c293
  charToStrictByteString ::
    GHC.Types.Char -> Data.ByteString.Internal.ByteString
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Char) ->
                 case w of ww { GHC.Types.C# ww1 ->
                 AronModule.$wcharToStrictByteString ww1 }) -}
779a071c51a8506bf2f0b2897b85884b
  clear :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: (GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout
                   AronModule.clear1
                   GHC.Types.False) -}
adfb862a49c1430cec378f49789052a3
  clear1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.clear2) -}
733e68aa755f6b39636ec26ceb543671
  clear2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\ESC[2J"#) -}
e999814845456c1e8c4b291dbf94f1be
  cmd :: [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.cmd1
                  `cast`
                (<[GHC.Base.String]>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
5e02221cffbcd5a159e79631599966bc
  cmd1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
6aec7d0ff9e4992c7ac624d36d556ac1
  co :: AronModule.C -> (GHC.Types.Float, GHC.Types.Float)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 -> (x1, y1) }) -}
d72cc1570848213a6996d97445d7b72a
  codeCapture :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (str :: GHC.Base.String) ->
                 Text.Regex.subRegex
                   AronModule.codeCapture3
                   str
                   AronModule.codeCapture1) -}
aea1e84815c8ff378ddf8986c12309ff
  codeCapture1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.codeCapture2) -}
5da6c27709035010a5430937fe47cf3d
  codeCapture2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<cool>\\1</cool>"#) -}
7a7a47852eeed4c5f73c0200b6838160
  codeCapture3 :: Text.Regex.Posix.Wrap.Regex
  {- Unfolding: (Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                   Text.Regex.mkRegex1
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                   Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                   (GHC.CString.unpackCString# AronModule.codeCapture4)) -}
d77a98a453825474ea6a9d19cbf4f9c6
  codeCapture4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("(([^`]|`[^[]]*|\n\
                 \*)*)"#) -}
63e58c7742ac8b6bbaf7e0397f6bf35b
  compileHaskellToBin ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.compileHaskellToBin1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
af71e0a0a73ea75bdb80c2820ba42d06
  compileHaskellToBin1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (file :: GHC.Base.String)
                   (sym1 :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 let {
                   bin :: GHC.IO.FilePath
                   = case Text.Regex.splitRegex
                            AronModule.compileHaskellToBin14
                            file of wild {
                       [] -> case GHC.List.init2 ret_ty GHC.IO.FilePath of {}
                       : x1 xs
                       -> System.FilePath.Posix.combine
                            AronModule.compileHaskellToBin12
                            (AronModule.cat (GHC.List.init1 @ GHC.Base.String x1 xs)) }
                 } in
                 case AronModule.compileHaskellToBin11
                        bin
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case AronModule.compileHaskellToBin8
                        (GHC.CString.unpackAppendCString#
                           AronModule.compileHaskellToBin7
                           (GHC.Base.++
                              @ GHC.Types.Char
                              file
                              (GHC.CString.unpackAppendCString#
                                 AronModule.compileHaskellToBin6
                                 bin)))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case AronModule.compileHaskellToBin8
                        (GHC.CString.unpackAppendCString#
                           AronModule.compileHaskellToBin5
                           (GHC.Base.++
                              @ GHC.Types.Char
                              bin
                              (GHC.CString.unpackAppendCString#
                                 AronModule.compileHaskellToBin4
                                 (System.FilePath.Posix.combine
                                    AronModule.compileHaskellToBin2
                                    sym1))))
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4, GHC.Tuple.() #) } } }) -}
1b984567c2a0fb8896d24a01af68733f
  compileHaskellToBin10 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Pattern match failure in do expression at src/AronModule.hs:3439:5-37"#) -}
cd50c0b0b63779fb8786d129df00b461
  compileHaskellToBin11 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (s :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ GHC.Types.Bool
                        @ GHC.Exception.Type.SomeException
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case System.Directory.createDirectoryIfMissing6
                                s
                                s1 of ds6 { (#,#) ipv ipv1 ->
                         (# ipv, GHC.Classes.not ipv1 #) })
                        System.Directory.doesDirectoryExist2
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   GHC.Types.False -> (# ipv, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case System.Posix.Files.getFileStatus1
                             s
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      case ipv3
                             `cast`
                           (System.Posix.Files.Common.N:FileStatus[0]) of ww { GHC.ForeignPtr.ForeignPtr ww1 ww2 ->
                      case GHC.Magic.runRW#
                             @ ('GHC.Types.TupleRep
                                  '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                             @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                  System.Posix.Types.FileMode #)
                             (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case GHC.Prim.noDuplicate#
                                     @ GHC.Prim.RealWorld
                                     s1 of s' { DEFAULT ->
                              case GHC.Prim.readWord16OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# ww1 4#)
                                     0#
                                     s' of ds3 { (#,#) ipv4 ipv5 ->
                              case GHC.Prim.touch#
                                     @ 'GHC.Types.LiftedRep
                                     @ GHC.ForeignPtr.ForeignPtrContents
                                     ww2
                                     ipv4 of s'1 { DEFAULT ->
                              (# s'1,
                                 (GHC.Word.W16# ipv5)
                                   `cast`
                                 (Sym (System.Posix.Types.N:CMode[0])) #) } } }) of ds { (#,#) ipv4 ipv5 ->
                      case ipv5
                             `cast`
                           (System.Posix.Types.N:CMode[0]) of wild1 { GHC.Word.W16# x# ->
                      case GHC.Prim.and# x# 61440## of wild2 {
                        DEFAULT -> (# ipv2, GHC.Tuple.() #)
                        32768## -> System.Posix.Files.removeLink1 s ipv2 } } } } } } }) -}
8ad23dc1420c2d089eedc218c64ced7c
  compileHaskellToBin12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.compileHaskellToBin13) -}
737f276d4b073af7b6904f60a8c60d12
  compileHaskellToBin13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/Users/cat/myfile/mybin"#) -}
d9fcb137f3fae7236e2888fda7508d10
  compileHaskellToBin14 :: Text.Regex.Posix.Wrap.Regex
  {- Unfolding: (Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                   Text.Regex.mkRegex1
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                   Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                   (GHC.CString.unpackCString# AronModule.compileHaskellToBin15)) -}
8a8a8b47280bad4013335d74d649a6ca
  compileHaskellToBin15 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\."#) -}
23b7edf6975396ad779cd2ce61bca5da
  compileHaskellToBin2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.compileHaskellToBin3) -}
8f2876f52c3883b9f2f297a87c1ece91
  compileHaskellToBin3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/Users/cat/myfile/symbin"#) -}
77ca9107cc8ea23793a3ceb5f49dcb34
  compileHaskellToBin4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" "#) -}
3e90599c9425f78880c4991272938811
  compileHaskellToBin5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ln -f -s "#) -}
b6a63ae2804ad32b1375406a210b16b0
  compileHaskellToBin6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" -o "#) -}
f6ca23337f9cc7e8e01baae7c8b3d409
  compileHaskellToBin7 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("ghc -i/Users/cat/myfile/bitbucket/haskell -O2 /Users/cat/myfile/bitbucket/haskell/"#) -}
4b94a6eacc5dbc40d1dde5f09ed38564
  compileHaskellToBin8 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (cmd4 :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Process.createProcess1
                        (System.Process.Common.CreateProcess
                           (System.Process.Common.ShellCommand cmd4)
                           (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                           (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                           System.Process.Common.Inherit
                           System.Process.Common.CreatePipe
                           System.Process.Common.Inherit
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                           (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                           GHC.Types.False)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,,) ds ds2 ds3 ph ->
                 case ds of wild1 {
                   GHC.Maybe.Nothing
                   -> case ds2 of wild2 {
                        GHC.Maybe.Nothing -> AronModule.$wfail ipv
                        GHC.Maybe.Just hout
                        -> case ds3 of wild3 {
                             GHC.Maybe.Nothing
                             -> case ph of ww { System.Process.Common.ProcessHandle ww1 ww2 ww3 ->
                                case System.Process.$wwaitForProcess
                                       ww1
                                       ww2
                                       ww3
                                       ipv of ds4 { (#,#) ipv2 ipv3 ->
                                case ipv3 of wild4 {
                                  GHC.IO.Exception.ExitSuccess
                                  -> case GHC.IO.Handle.Text.hGetContents1
                                            hout
                                            ipv2 of ds5 { (#,#) ipv4 ipv5 ->
                                     (# ipv4, Data.OldList.lines ipv5 #) }
                                  GHC.IO.Exception.ExitFailure a1
                                  -> case (GHC.IO.Handle.Text.hPutStr'
                                             GHC.IO.Handle.FD.stdout
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.$fShow(,)3
                                                (GHC.Show.showLitString
                                                   (GHC.CString.unpackAppendCString#
                                                      GHC.IO.Exception.$fExceptionExitCode1
                                                      (case a1 of ww4 { GHC.Types.I# ww5 ->
                                                       case GHC.Show.$wshowSignedInt
                                                              11#
                                                              ww5
                                                              (GHC.Types.[]
                                                                 @ GHC.Types.Char) of ww6 { (#,#) ww7 ww8 ->
                                                       GHC.Types.: @ GHC.Types.Char ww7 ww8 } }))
                                                   GHC.Show.$fShow[]1))
                                             GHC.Types.True)
                                            `cast`
                                          (GHC.Types.N:IO[0] <()>_R)
                                            ipv2 of ds5 { (#,#) ipv4 ipv5 ->
                                     System.Exit.exitFailure1 @ [GHC.Base.String] ipv4 } } } }
                             GHC.Maybe.Just ipv2 -> AronModule.$wfail ipv } }
                   GHC.Maybe.Just ipv2 -> AronModule.$wfail ipv } } }) -}
0f7fb4767ecbdeaae2c18977a074e98c
  compileHaskellToBin9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.compileHaskellToBin10) -}
6c88a5fa06d15514134df7ee4cdb1193
  con :: AronModule.C -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 ->
                 AronModule.C x1 (GHC.Float.negateFloat y1) }) -}
9e1a6473a523e011c96abbba1e5350f5
  concatStr ::
    [GHC.Base.String] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) (s :: GHC.Base.String) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                      letrec {
                        go29 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [[GHC.Types.Char]]) ->
                          case ds1 of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : y1 ys
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 y1
                                 (GHC.Base.++ @ GHC.Types.Char s (go29 ys)) }
                      } in
                      AronModule.dropEnd
                        @ GHC.Types.Char
                        (GHC.Integer.Type.smallInteger ww2)
                        (go29 wild) } }) -}
ff6a63280e4134606bacbd7eaa221614
  containPrefix ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (sub :: GHC.Base.String) (str :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char sub 0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char str 0# of ww1 { DEFAULT ->
                 case GHC.Prim.<=# ww2 ww1 of lwild {
                   DEFAULT -> GHC.Types.False
                   1#
                   -> case GHC.Prim.<# 0# ww2 of lwild1 {
                        DEFAULT -> GHC.Base.eqString sub (GHC.Types.[] @ GHC.Types.Char)
                        1#
                        -> GHC.Base.eqString
                             sub
                             (GHC.List.$wunsafeTake @ GHC.Types.Char ww2 str) } } } }) -}
38220b02c4ef17d114bf1057a04c482f
  containStr :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (p1 :: GHC.Base.String) (s :: GHC.Base.String) ->
                 case Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                        Text.Regex.mkRegex1
                          `cast`
                        (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                        Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                          `cast`
                        (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                        p1 of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                 Text.Regex.Posix.String.$w$cmatchTest ww1 ww3 s }) -}
0c2b54fa4b9ba783c44798df455f0bfa
  containSuffix ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (sub :: GHC.Base.String) (str :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char str 0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char sub 0# of ww1 { DEFAULT ->
                 let {
                   m :: GHC.Integer.Type.Integer = GHC.Integer.Type.smallInteger ww1
                 } in
                 case GHC.Integer.Type.leInteger#
                        m
                        (GHC.Integer.Type.smallInteger ww2) of wild {
                   DEFAULT -> GHC.Types.False
                   1#
                   -> GHC.Base.eqString
                        sub
                        (AronModule.takeEnd @ GHC.Types.Char m str) } } }) -}
28cd79c414913a0803296c2920273601
  containsTries ::
    GHC.Base.String -> AronModule.XNode -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U(1*U,A)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: AronModule.XNode) ->
                 case w1 of ww { AronModule.XNode ww1 ww2 ->
                 AronModule.$wcontainsTries w ww1 }) -}
5db02b85364ceab4c56950a24377605e
  copyDir :: GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.copyDir1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
9b8f500f5bedb19e41f7679f6edc2395
  copyDir1 ::
    GHC.IO.FilePath
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U> -}
f8666c64026ae798fd89566162803e8b
  copyFileToDir ::
    GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.copyFileToDir1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
40fb7a75eb62919ede592bf102131d8d
  copyFileToDir1 ::
    GHC.IO.FilePath
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: GHC.IO.FilePath)
                   (d1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.Directory.copyFile1
                   s
                   (System.FilePath.Posix.combine d1 (AronModule.pathBase s))
                   eta) -}
be746293fcea6d52273ae883bb7e3a76
  copyRename :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.copyRename1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
04bbf007a269c6527d5624916ebcfc1b
  copyRename1 ::
    GHC.IO.FilePath
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (fp :: GHC.IO.FilePath)
                   (newName :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Directory.copyFile1
                        fp
                        (System.FilePath.Posix.combine
                           AronModule.copyRename2
                           (AronModule.pathBase fp))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 let {
                   s :: GHC.IO.FilePath
                   = case System.FilePath.Posix.$wsplitFileName_
                            fp of ww { (#,#) ww1 ww2 ->
                     System.FilePath.Posix.combine AronModule.copyRename2 ww2 }
                 } in
                 case System.Posix.Files.getFileStatus1
                        s
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3
                        `cast`
                      (System.Posix.Files.Common.N:FileStatus[0]) of ww { GHC.ForeignPtr.ForeignPtr ww1 ww2 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             System.Posix.Types.FileMode #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.noDuplicate#
                                @ GHC.Prim.RealWorld
                                s1 of s' { DEFAULT ->
                         case GHC.Prim.readWord16OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# ww1 4#)
                                0#
                                s' of ds3 { (#,#) ipv4 ipv5 ->
                         case GHC.Prim.touch#
                                @ 'GHC.Types.LiftedRep
                                @ GHC.ForeignPtr.ForeignPtrContents
                                ww2
                                ipv4 of s'1 { DEFAULT ->
                         (# s'1,
                            (GHC.Word.W16# ipv5)
                              `cast`
                            (Sym (System.Posix.Types.N:CMode[0])) #) } } }) of ds { (#,#) ipv4 ipv5 ->
                 case ipv5
                        `cast`
                      (System.Posix.Types.N:CMode[0]) of wild { GHC.Word.W16# x# ->
                 case GHC.Prim.and# x# 61440## of wild1 {
                   DEFAULT
                   -> case System.Directory.renameDirectory1
                             s
                             (System.FilePath.Posix.combine
                                (System.FilePath.Posix.takeDirectory fp)
                                newName)
                             ipv2 of ds3 { (#,#) ipv6 ipv7 ->
                      AronModule.compileHaskellToBin11 s ipv6 }
                   32768##
                   -> case System.Directory.copyFile2
                             s
                             (System.FilePath.Posix.combine
                                (System.FilePath.Posix.takeDirectory fp)
                                newName)
                             ipv2 of ds3 { (#,#) ipv6 ipv7 ->
                      AronModule.compileHaskellToBin11 s ipv6 } } } } } } }) -}
9e45d39aa66607214e6f4d93647c34e0
  copyRename2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.copyRename3) -}
f2ec48cf1fe7da8760a33339e205b196
  copyRename3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/tmp"#) -}
530f099195e04ef90c2bcbe88bf05232
  createFile :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.createFile1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
3475e6e8bbe6fd3833e4aee9541f80d2
  createFile1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (f :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.IO.appendFile2
                   @ ()
                   f
                   GHC.IO.IOMode.WriteMode
                   AronModule.createFile2
                     `cast`
                   (<GHC.IO.Handle.Types.Handle>_R
                    ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                   eta) -}
3c6fcacf142b1855f27bed44956311b1
  createFile2 ::
    GHC.IO.Handle.Types.Handle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot]
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (GHC.IO.Handle.Text.hPutStr'
                    hdl
                    (GHC.Types.[] @ GHC.Types.Char)
                    GHC.Types.False)
                   `cast`
                 (GHC.Types.N:IO[0] <()>_R)
                   eta) -}
4c45874df1274e5eea47b5815f9124ec
  d :: AronModule.Quaternion -> GHC.Types.Float
  RecSel Left AronModule.Quaternion
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLS),1*U(A,A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.Quaternion) ->
                 case ds of wild { AronModule.Quaternion ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
ca08b8ce945ca6701baa6f8b7f54dd97
  degreeToRadian :: GHC.Types.Float -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: GHC.Types.Float) ->
                 case x1 of wild { GHC.Types.F# x2 ->
                 GHC.Types.F# (GHC.Prim.timesFloat# x2 1.7453292e-2#) }) -}
ddf9aade41680511f334d32eebfdeca6
  det :: GHC.Num.Num a => [[a]] -> a
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),A,A,C(U))><S,U> -}
ed29d13c95794d4fa1a8f3bfc48c0d8c
  df :: GHC.Real.Fractional a => (a -> a) -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A),1*C1(C1(U)),A,1*C1(U))><L,C(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: GHC.Real.Fractional a1)
                   (w1 :: a1 -> a1)
                   (w2 :: a1) ->
                 case w of ww { GHC.Real.C:Fractional ww1 ww2 ww3 ww4 ->
                 AronModule.$wdf @ a1 ww1 ww2 ww4 w1 w2 }) -}
6d88f0b4f23380651f617c6696073de8
  df1 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Real.:%
                   @ GHC.Integer.Type.Integer
                   AronModule.df3
                   AronModule.df2) -}
a4aa64d729d5273c78c4047682fcf962
  df2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1000) -}
bae46b46e6a7e72d66005ec45e4b6f44
  df3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
566b1029e5bdb21ea7f7476920436ef2
  diag1 :: GHC.Num.Num a => [[a]] -> [a]
  {- Arity: 2, Strictness: <L,A><S,1*U>m2, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (w :: GHC.Num.Num a1) (w1 :: [[a1]]) ->
                 case AronModule.$wdiag1 @ a1 w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ a1 ww1 ww2 }) -}
93c3494f900f69ac40e2702c394095ce
  dim :: [[a]] -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 (w :: [[a1]]) ->
                 case w of wild {
                   [] -> (AronModule.$fShowC6, AronModule.$fShowC6)
                   : x1 xs
                   -> (case GHC.List.$wlenAcc
                              @ [a1]
                              (GHC.Types.: @ [a1] x1 xs)
                              0# of ww2 { DEFAULT ->
                       GHC.Types.I# ww2 },
                       case GHC.List.$wlenAcc @ a1 x1 0# of ww2 { DEFAULT ->
                       GHC.Types.I# ww2 }) }) -}
f97929372d84edb166725d1a32cd201d
  dirModified ::
    GHC.IO.FilePath -> GHC.Types.IO [System.Posix.Types.EpochTime]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.dirModified1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[System.Posix.Types.EpochTime]>_R)) -}
5d5245d49419b05ea524c3f05b521334
  dirModified1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [System.Posix.Types.EpochTime] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case AronModule.dirModified3 p1 eta of ds1 { (#,#) ipv ipv1 ->
                 AronModule.dirModified2 ipv1 ipv }) -}
2bac4e38d75c97131dc90750e6202ee7
  dirModified2 ::
    [GHC.IO.FilePath]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [System.Posix.Types.EpochTime] #)
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
f6e873372a46addbb281da7730af6c91
  dirModified3 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.IO.Error.modifyIOError1
                        @ GHC.IO.FilePath
                        System.Directory.getCurrentDirectory6
                        System.Directory.getCurrentDirectory2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 let {
                   path :: GHC.IO.FilePath
                   = case GHC.Base.eqString s AronModule.dirModified6 of wild {
                       GHC.Types.False -> s GHC.Types.True -> ipv1 }
                 } in
                 case System.Process.createProcess1
                        (System.Process.Common.CreateProcess
                           (System.Process.Common.RawCommand
                              AronModule.dirModified4
                              (GHC.Types.:
                                 @ GHC.Base.String
                                 path
                                 (GHC.Types.[] @ GHC.Base.String)))
                           (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                           (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                           System.Process.Common.Inherit
                           System.Process.Common.CreatePipe
                           System.Process.Common.Inherit
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                           (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                           GHC.Types.False)
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild { (,,,) ds hout ds3 ds4 ->
                 case hout of wild1 {
                   GHC.Maybe.Nothing
                   -> (# ipv2,
                         GHC.Base.map
                           @ [GHC.Types.Char]
                           @ [GHC.Types.Char]
                           (\ (x1 :: GHC.IO.FilePath) ->
                            System.FilePath.Posix.combine path x1)
                           (GHC.Types.[] @ GHC.Base.String) #)
                   GHC.Maybe.Just out
                   -> case GHC.IO.Handle.Text.hGetContents1
                             out
                             ipv2 of ds5 { (#,#) ipv4 ipv5 ->
                      (# ipv4,
                         GHC.Base.map
                           @ [GHC.Types.Char]
                           @ [GHC.Types.Char]
                           (\ (x1 :: GHC.IO.FilePath) ->
                            System.FilePath.Posix.combine path x1)
                           (Data.OldList.lines ipv5) #) } } } } }) -}
ba595e3ead190d6941d26533527d148d
  dirModified4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.dirModified5) -}
75cb53b342784c73463bbad098251f7b
  dirModified5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ls"#) -}
36ba766a6a0102638c3ac728151420c5
  dirModified6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.dirModified7) -}
3fd57182d4c4c75796fc67426382586d
  dirModified7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("."#) -}
839367455276781d4fd2f081bcd5c819
  dirWalk ::
    GHC.IO.FilePath
    -> (GHC.IO.FilePath -> GHC.Types.IO [GHC.Base.String])
    -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U(U,U)))><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.dirWalk1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath -> GHC.Types.IO [GHC.Base.String]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
530b5e9e1ef9d81ab82767f1f7618d21
  dirWalk1 ::
    GHC.IO.FilePath
    -> (GHC.IO.FilePath -> GHC.Types.IO [GHC.Base.String])
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U(U,U)))><S,U> -}
243ff3c3bf188b7a9054c21701537d3a
  div' :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Types.Int) (m :: GHC.Types.Int) ->
                 case n of wild { GHC.Types.I# i ->
                 case m of wild1 { GHC.Types.I# i1 ->
                 case GHC.Prim./##
                        (GHC.Prim.int2Double# i)
                        (GHC.Prim.int2Double# i1) of wild2 { DEFAULT ->
                 GHC.Types.D# wild2 } } }) -}
09f2c0d0474b7bb66d6faec7f5cd233c
  divI ::
    GHC.Real.Fractional a =>
    GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LL),1*U(U(A,A,A,A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: GHC.Real.Fractional a1)
                   (w1 :: GHC.Integer.Type.Integer)
                   (w2 :: GHC.Integer.Type.Integer) ->
                 case w of ww { GHC.Real.C:Fractional ww1 ww2 ww3 ww4 ->
                 AronModule.$wdivI @ a1 ww1 ww2 w1 w2 }) -}
558d2da019dda1f3c812e90e7c76f40c
  divR :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (s1 :: GHC.Base.String) (s2 :: GHC.Base.String) ->
                 AronModule.multR s1 (AronModule.invR s2)) -}
256938b7a9aa7f0284307c51efd2debe
  divR' ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (m :: GHC.Integer.Type.Integer)
                   (n :: GHC.Integer.Type.Integer) ->
                 AronModule.multR
                   (GHC.Show.$fShowInteger_$cshowsPrec
                      GHC.Show.$fShow(,)1
                      m
                      (GHC.Types.[] @ GHC.Types.Char))
                   (AronModule.invR
                      (GHC.Show.$fShowInteger_$cshowsPrec
                         GHC.Show.$fShow(,)1
                         n
                         (GHC.Types.[] @ GHC.Types.Char)))) -}
29e763c675aaf17893fa8bf020086a9a
  drawInt ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><S,U>m,
     Unfolding: InlineRule (0, True, True)
                AronModule.drawInt1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Int>_R)) -}
577c509a228cf360c60c8d524a72a0d3
  drawInt1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><S,U>m,
     Unfolding: (\ (x1 :: GHC.Types.Int)
                   (y1 :: GHC.Types.Int)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 let {
                   f :: System.Random.StdGen -> (GHC.Types.Int, System.Random.StdGen)
                   = System.Random.$w$crandomR20
                       @ System.Random.StdGen
                       System.Random.$fRandomGenStdGen
                       x1
                       y1
                 } in
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, GHC.Types.Int)
                        @ GHC.Types.Int
                        r#
                        (\ (a1 :: System.Random.StdGen) ->
                         case f a1 of wild1 { (,) v g4 ->
                         case g4 of a'1 { System.Random.StdGen ipv ipv1 -> (a'1, v) } })
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { GHC.Types.I# ipv2 -> ds1 } } }) -}
0eb224d2e97203f46e588977c0e04cc1
  drawInteger ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Types.IO GHC.Types.Int
  {- Arity: 3, Strictness: <L,1*U><L,1*U><S,U>m,
     Unfolding: InlineRule (0, True, True)
                AronModule.drawInteger1
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R <GHC.Integer.Type.Integer>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Int>_R)) -}
605f142d3963db1ead8d042d9971cdb5
  drawInteger1 ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><S,U>m,
     Unfolding: (\ (x1 :: GHC.Integer.Type.Integer)
                   (y1 :: GHC.Integer.Type.Integer)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case GHC.Integer.Type.integerToInt y1 of wild1 { DEFAULT ->
                     GHC.Integer.Type.smallInteger wild1 }
                 } in
                 let {
                   w2 :: GHC.Integer.Type.Integer
                   = case GHC.Integer.Type.integerToInt x1 of wild1 { DEFAULT ->
                     GHC.Integer.Type.smallInteger wild1 }
                 } in
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, GHC.Types.Int)
                        @ GHC.Types.Int
                        r#
                        (\ (a1 :: System.Random.StdGen) ->
                         case System.Random.$wrandomIvalInteger
                                @ System.Random.StdGen
                                @ GHC.Types.Int
                                System.Random.$fRandomGenStdGen
                                GHC.Num.$fNumInt
                                w2
                                w1
                                a1 of ww2 { (#,#) ww3 ww4 ->
                         case ww4 of a'1 { System.Random.StdGen ipv ipv1 -> (a'1, ww3) } })
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { GHC.Types.I# ipv2 -> ds1 } } }) -}
0ef3c1d61910d1218d98f5b87076b54e
  drop' :: GHC.Real.Integral n => n -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLLLLLC(S)),1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,U><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ n @ a1 (w :: GHC.Real.Integral n) (w1 :: n) (w2 :: [a1]) ->
                 case w of ww { GHC.Real.C:Integral ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 AronModule.$wdrop' @ n @ a1 ww9 w1 w2 }) -}
b1f674409f526be86878d384db041c99
  dropBS ::
    GHC.Integer.Type.Integer
    -> Data.ByteString.Internal.ByteString
    -> Data.ByteString.Internal.ByteString
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,U,U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: Data.ByteString.Internal.ByteString) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 case GHC.Integer.Type.integerToInt w of wild { DEFAULT ->
                 case GHC.Prim.<=# wild 0# of lwild {
                   DEFAULT
                   -> case GHC.Prim.>=# wild ww4 of lwild1 {
                        DEFAULT
                        -> Data.ByteString.Internal.PS
                             ww1
                             ww2
                             (GHC.Prim.+# ww3 wild)
                             (GHC.Prim.-# ww4 wild)
                        1#
                        -> Data.ByteString.Internal.PS
                             __NULL
                             Data.ByteString.Internal.$fMonoidByteString1
                             0#
                             0# }
                   1# -> Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 } } }) -}
423614de4a872aabd1f0621187794ecd
  dropEnd :: GHC.Integer.Type.Integer -> [a] -> [a]
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ @ a1 (n :: GHC.Integer.Type.Integer) (s :: [a1]) ->
                 case GHC.List.$wlenAcc @ a1 s 0# of ww2 { DEFAULT ->
                 case GHC.Integer.Type.integerToInt
                        (GHC.Integer.Type.minusInteger
                           (GHC.Integer.Type.smallInteger ww2)
                           n) of wild { DEFAULT ->
                 case GHC.Prim.<# 0# wild of lwild {
                   DEFAULT -> GHC.Types.[] @ a1
                   1# -> GHC.List.$wunsafeTake @ a1 wild s } } }) -}
26a2d2513965d6bfbcdab6da0e4385d5
  eightQueen ::
    [[GHC.Integer.Type.Integer]]
    -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> [[GHC.Integer.Type.Integer]]
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
76384e72079c5ee04a6537e653a91436
  en :: GHC.Base.String -> GHC.Types.IO GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Environment.getEnv1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
db37cdfb75d08dd620b4be8cc536af3d
  eps ::
    (GHC.Num.Num a, GHC.Classes.Ord a) => a -> a -> a -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,1*C1(C1(U)),A,A,1*C1(U),A,A)><S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   ($dOrd :: GHC.Classes.Ord a1)
                   (a2 :: a1)
                   (b1 :: a1)
                   (e :: a1) ->
                 GHC.Classes.<
                   @ a1
                   $dOrd
                   (GHC.Num.abs @ a1 $dNum (GHC.Num.- @ a1 $dNum a2 b1))
                   e) -}
532923faa65b6ac20148df3849f24dc1
  escapeHtml :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c03c36765a693c5f2398fd3691e858b3
  evens :: [a] -> [a]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a1 (cx :: [a1]) ->
                 AronModule.evens1 @ a1 AronModule.df3 cx) -}
6447452f620f2fde188007eb5dad699c
  evens1 :: GHC.Integer.Type.Integer -> [a] -> [a]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
2f3a50fbca15126b3005bd8b69f3d7aa
  fExist :: GHC.IO.FilePath -> GHC.Types.IO GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Directory.doesFileExist1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R)) -}
a9b436d60590fc64c15915eb898dd11e
  fe :: GHC.IO.FilePath -> GHC.Types.IO GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Directory.doesFileExist1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R)) -}
bfabcc01895947d6fa9f141f2087c4ae
  ff ::
    GHC.Show.Show var => GHC.Base.String -> var -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,U>,
     Unfolding: (\ @ var
                   ($dShow :: GHC.Show.Show var)
                   (msg :: GHC.Base.String)
                   (var1 :: var) ->
                 GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout
                   (case GHC.List.$wlenAcc @ GHC.Types.Char msg 0# of ww2 { DEFAULT ->
                    let {
                      ww1 :: GHC.Prim.Int# = GHC.Prim.-# 80# ww2
                    } in
                    let {
                      x1 :: GHC.Prim.Int# = GHC.Prim.uncheckedIShiftRA# ww1 1#
                    } in
                    let {
                      y1 :: GHC.Prim.Int# = GHC.Prim.+# x1 (GHC.Prim.andI# ww1 1#)
                    } in
                    let {
                      arg :: [GHC.Types.Char]
                      = GHC.Base.++
                          @ GHC.Types.Char
                          msg
                          (let {
                             arg1 :: [GHC.Types.Char]
                             = GHC.CString.unpackAppendCString#
                                 AronModule.ff2
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    (GHC.Show.show @ var $dShow var1)
                                    AronModule.ff1)
                           } in
                           case GHC.Prim.<# 0# x1 of lwild {
                             DEFAULT -> arg1
                             1# -> GHC.Base.++ @ GHC.Types.Char (AronModule.$wxs1 x1) arg1 })
                    } in
                    case GHC.Prim.<# 0# y1 of lwild {
                      DEFAULT -> arg
                      1# -> GHC.Base.++ @ GHC.Types.Char (AronModule.$wxs y1) arg } })
                   GHC.Types.False) -}
483f239a6e10566d230a37c6c9199e63
  ff1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.ff2) -}
c54053380aa2eba0cbf20b196c60e2ff
  ff2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
cf2fb64ec7054a1df16b8f3c5b6cc348
  filtermap :: (a -> GHC.Maybe.Maybe b) -> [a] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
bebfaf48bebba4293991e8efa0af4069
  findBalance ::
    [(GHC.Integer.Type.Integer, GHC.Base.String)]
    -> GHC.Base.String
    -> ([(GHC.Integer.Type.Integer, GHC.Base.String)], GHC.Types.Bool)
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [(GHC.Integer.Type.Integer, GHC.Base.String)])
                   (w1 :: GHC.Base.String) ->
                 case AronModule.$wfindBalance w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
092bbd131cf27c1346c2c8412f52be8b
  fl :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: (GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout
                   AronModule.fl1
                   GHC.Types.True) -}
5556f5b4d87ec61cfab355a462f9078c
  fl1 :: [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)3
                   AronModule.fl2) -}
88337dd67f85e7a3c9908f028fb8a561
  fl2 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showLitString
                   (AronModule.$wxs2 80#)
                   GHC.Show.$fShow[]1) -}
3c24b51deb1d6a0f640d8d5705982819
  fpp :: GHC.Show.Show s => GHC.Base.String -> s -> GHC.Types.IO ()
  {- Arity: 4, Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.fpp1
                  `cast`
                (forall (s :: <*>_N).
                 <GHC.Show.Show s>_R
                 ->_R <GHC.Base.String>_R
                 ->_R <s>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
756dcb0697ce2f79fb39474faadb42d8
  fpp1 ::
    GHC.Show.Show s =>
    GHC.Base.String
    -> s
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ s
                   ($dShow :: GHC.Show.Show s)
                   (msg :: GHC.Base.String)
                   (s1 :: s)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (AronModule.fw msg) `cast` (GHC.Types.N:IO[0] <()>_R)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (GHC.IO.Handle.Text.hPutStr'
                    GHC.IO.Handle.FD.stdout
                    (GHC.Show.show @ s $dShow s1)
                    GHC.Types.True)
                   `cast`
                 (GHC.Types.N:IO[0] <()>_R)
                   ipv }) -}
40196b6ac716faaffb6b9949d40bebf0
  fs ::
    [[GHC.Types.Double]]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: [[GHC.Types.Double]])
                   (ds1 :: [GHC.Types.Double])
                   (ds2 :: [GHC.Types.Double]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Double
                   : ipv ipv1
                   -> case ds2 of wild1 {
                        [] -> GHC.Types.[] @ GHC.Types.Double
                        : ipv2 ipv3 -> AronModule.fs_f wild ds1 wild1 } }) -}
91e69539b3b218c9d8e54800a9d50170
  fs_f ::
    [[GHC.Types.Double]]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U> -}
41bed13906cded1b2011cdf3c2ab72cd
  fw :: GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (msg :: GHC.Base.String) ->
                 GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout
                   (case GHC.List.$wlenAcc @ GHC.Types.Char msg 0# of ww2 { DEFAULT ->
                    let {
                      ww1 :: GHC.Prim.Int# = GHC.Prim.-# 80# ww2
                    } in
                    let {
                      x1 :: GHC.Prim.Int# = GHC.Prim.uncheckedIShiftRA# ww1 1#
                    } in
                    let {
                      y1 :: GHC.Prim.Int# = GHC.Prim.+# x1 (GHC.Prim.andI# ww1 1#)
                    } in
                    let {
                      arg :: [GHC.Types.Char]
                      = GHC.Base.++
                          @ GHC.Types.Char
                          msg
                          (case GHC.Prim.<# 0# x1 of lwild {
                             DEFAULT -> AronModule.ff1
                             1#
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  (AronModule.$wxs4 x1)
                                  AronModule.ff1 })
                    } in
                    case GHC.Prim.<# 0# y1 of lwild {
                      DEFAULT -> arg
                      1# -> GHC.Base.++ @ GHC.Types.Char (AronModule.$wxs3 y1) arg } })
                   GHC.Types.False) -}
bd7196c4a428b37b2ec46f0bedca24e1
  g :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.g1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
3f0a41e7a5582d757aa70ead155a4b21
  g1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (GHC.Magic.noinline
                         @ (GHC.Types.IO GHC.IO.Encoding.Types.TextEncoding)
                         GHC.IO.Encoding.getForeignEncoding)
                        `cast`
                      (GHC.Types.N:IO[0] <GHC.IO.Encoding.Types.TextEncoding>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Foreign.charIsRepresentable3
                        @ (GHC.Maybe.Maybe GHC.Base.String)
                        ipv1
                        AronModule.g_name
                        System.Environment.getEnv3
                          `cast`
                        (<Foreign.C.String.CString>_R
                         ->_R Sym (GHC.Types.N:IO[0] <GHC.Maybe.Maybe GHC.Base.String>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild {
                   GHC.Maybe.Nothing
                   -> case System.Environment.getEnv2 AronModule.g_name ipv2
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                      of {}
                   GHC.Maybe.Just x1
                   -> case (GHC.IO.Handle.Text.hPutStr'
                              GHC.IO.Handle.FD.stdout
                              (GHC.Show.$fShow[]_$s$cshow1 x1)
                              GHC.Types.True)
                             `cast`
                           (GHC.Types.N:IO[0] <()>_R)
                             ipv2 of ds4 { (#,#) ipv4 ipv5 ->
                      (# ipv4, GHC.Tuple.() #) } } } }) -}
47c27df018ae3b05d6427c5546681abc
  g2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("g"#) -}
5b93cd651e5b4cbbfa504941654e6f59
  g_name :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# AronModule.g2) -}
5ce7dc9142b677dfa22043a114f5cf34
  geneMat ::
    GHC.Integer.Type.Integer
    -> AronModule.Mat -> [[GHC.Integer.Type.Integer]]
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer)
                   (m :: AronModule.Mat) ->
                 case m of wild {
                   AronModule.Zero
                   -> let {
                        lvl264 :: [GHC.Integer.Type.Integer]
                        = letrec {
                            go29 :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                              {- Arity: 1, Strictness: <S,U> -}
                            = \ (x1 :: GHC.Integer.Type.Integer) ->
                              case GHC.Integer.Type.gtInteger# x1 n of wild1 {
                                DEFAULT
                                -> GHC.Types.:
                                     @ GHC.Integer.Type.Integer
                                     AronModule.$fDnumDoubleInt1
                                     (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                                1# -> GHC.Types.[] @ GHC.Integer.Type.Integer }
                          } in
                          go29 AronModule.df3
                      } in
                      letrec {
                        go29 :: GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
                          {- Arity: 1, Strictness: <S,U> -}
                        = \ (x1 :: GHC.Integer.Type.Integer) ->
                          case GHC.Integer.Type.gtInteger# x1 n of wild1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ [GHC.Integer.Type.Integer]
                                 lvl264
                                 (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                            1# -> GHC.Types.[] @ [GHC.Integer.Type.Integer] }
                      } in
                      go29 AronModule.df3
                   AronModule.Id -> AronModule.ident n }) -}
a5bdbf34bcafe52b577e902f6fe50bd8
  geneMat1ToN ::
    GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer) ->
                 let {
                   lim :: GHC.Integer.Type.Integer
                   = GHC.Integer.Type.minusInteger n AronModule.df3
                 } in
                 letrec {
                   go29 :: GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Integer.Type.Integer) ->
                     case GHC.Integer.Type.gtInteger# x1 lim of wild {
                       DEFAULT
                       -> GHC.Types.:
                            @ [GHC.Integer.Type.Integer]
                            (let {
                               lvl264 :: GHC.Integer.Type.Integer
                               = GHC.Integer.Type.timesInteger n x1
                             } in
                             letrec {
                               go30 :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                                 {- Arity: 1, Strictness: <S,U> -}
                               = \ (x2 :: GHC.Integer.Type.Integer) ->
                                 case GHC.Integer.Type.gtInteger# x2 n of wild1 {
                                   DEFAULT
                                   -> GHC.Types.:
                                        @ GHC.Integer.Type.Integer
                                        (GHC.Integer.Type.plusInteger x2 lvl264)
                                        (go30 (GHC.Integer.Type.plusInteger x2 AronModule.df3))
                                   1# -> GHC.Types.[] @ GHC.Integer.Type.Integer }
                             } in
                             go30 AronModule.df3)
                            (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                       1# -> GHC.Types.[] @ [GHC.Integer.Type.Integer] }
                 } in
                 go29 AronModule.$fDnumDoubleInt1) -}
265d255bc20e620cbb5f472ae2514059
  geneMatMN ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (m :: GHC.Integer.Type.Integer)
                   (n :: GHC.Integer.Type.Integer) ->
                 let {
                   lim :: GHC.Integer.Type.Integer
                   = GHC.Integer.Type.minusInteger m AronModule.df3
                 } in
                 letrec {
                   go29 :: GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Integer.Type.Integer) ->
                     case GHC.Integer.Type.gtInteger# x1 lim of wild {
                       DEFAULT
                       -> GHC.Types.:
                            @ [GHC.Integer.Type.Integer]
                            (let {
                               lvl264 :: GHC.Integer.Type.Integer
                               = GHC.Integer.Type.timesInteger n x1
                             } in
                             letrec {
                               go30 :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                                 {- Arity: 1, Strictness: <S,U> -}
                               = \ (x2 :: GHC.Integer.Type.Integer) ->
                                 case GHC.Integer.Type.gtInteger# x2 n of wild1 {
                                   DEFAULT
                                   -> GHC.Types.:
                                        @ GHC.Integer.Type.Integer
                                        (GHC.Integer.Type.plusInteger x2 lvl264)
                                        (go30 (GHC.Integer.Type.plusInteger x2 AronModule.df3))
                                   1# -> GHC.Types.[] @ GHC.Integer.Type.Integer }
                             } in
                             go30 AronModule.df3)
                            (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                       1# -> GHC.Types.[] @ [GHC.Integer.Type.Integer] }
                 } in
                 go29 AronModule.$fDnumDoubleInt1) -}
99626891bc9c73e938aca8b905d6d380
  getLocalDate :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.getLocalDate1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
d98e8445045bd3af3fc1e7a502a81235
  getLocalDate1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Data.Time.Clock.POSIX.getCurrentTime1
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of ww { Data.Time.Clock.Internal.UTCTime.UTCTime ww1 ww2 ->
                 case Data.Time.LocalTime.Internal.TimeZone.$wgetTimeZone
                        ww1
                        ww2
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    case Data.Time.LocalTime.Internal.LocalTime.$wutcToLocalTime
                           ipv3
                           ww1
                           ww2 of ww3 { (#,#) ww4 ww5 ->
                    Data.Time.LocalTime.Internal.ZonedTime.$w$cshow
                      ww4
                      ww5
                      ipv3 } #) } } }) -}
5f1efcd28320080ed2ed1c74ef60c43e
  getOS :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.getOS1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
7ad9afd7a00cc2bec6f1daa5bfda430d
  getOS1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (GHC.Magic.noinline
                         @ (GHC.Types.IO GHC.IO.Encoding.Types.TextEncoding)
                         GHC.IO.Encoding.getForeignEncoding)
                        `cast`
                      (GHC.Types.N:IO[0] <GHC.IO.Encoding.Types.TextEncoding>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Foreign.charIsRepresentable3
                        @ (GHC.Maybe.Maybe GHC.Base.String)
                        ipv1
                        AronModule.getOS_name
                        System.Environment.getEnv3
                          `cast`
                        (<Foreign.C.String.CString>_R
                         ->_R Sym (GHC.Types.N:IO[0] <GHC.Maybe.Maybe GHC.Base.String>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild {
                   GHC.Maybe.Nothing
                   -> System.Environment.getEnv2 AronModule.getOS_name ipv2
                   GHC.Maybe.Just x1
                   -> (# ipv2,
                         case Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                                Text.Regex.mkRegex1
                                  `cast`
                                (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                                Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                                  `cast`
                                (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                                AronModule.getOS_macOS of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                         case Text.Regex.Posix.String.$w$cmatchTest ww1 ww3 x1 of wild1 {
                           GHC.Types.False
                           -> case Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                                     Text.Regex.mkRegex1
                                       `cast`
                                     (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                                     Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                                       `cast`
                                     (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                                     AronModule.getOS_freeBSD of ww4 { Text.Regex.Posix.Wrap.Regex ww5 ww6 ww7 ->
                              case Text.Regex.Posix.String.$w$cmatchTest ww5 ww7 x1 of wild2 {
                                GHC.Types.False -> AronModule.getOS2
                                GHC.Types.True -> AronModule.getOS_freeBSD } }
                           GHC.Types.True -> AronModule.getOS_macOS } } #) } } }) -}
021a37260ff7745f91f4ede175c5a684
  getOS2 :: [GHC.Types.Char]
  {- Strictness: x -}
fdf6b78557fd9c16fcc199263e85b28d
  getOS3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("freebsd"#) -}
2d6dad944d0b5cc41a509bb904db1283
  getOS4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("darwin"#) -}
c34ad6203c40a90c5617ae552b7d2df1
  getOS5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("OSTYPE"#) -}
d4689712666e193b9db981bacf7c6f96
  getOS_freeBSD :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.getOS3) -}
d4ec43fe54a243dbe08970f3a0bd79af
  getOS_macOS :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.getOS4) -}
122ada729c50914ef9597622bb4b5b35
  getOS_name :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# AronModule.getOS5) -}
c2efc2a4305438210128527acbdbe404
  getPwd :: GHC.Types.IO GHC.IO.FilePath
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                System.Directory.getCurrentDirectory1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R)) -}
277ed7cf77f099c7760a7a412d8eb269
  getTime :: GHC.Types.IO GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.getTime1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
138ca42f19794d2bb9a322a0e6d8ad1a
  getTime1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Data.Time.Clock.POSIX.getCurrentTime1
                        s of ds1 { (#,#) ipv ipv1 ->
                 case Data.Time.LocalTime.Internal.TimeZone.getCurrentTimeZone1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    case ipv1 of ww { Data.Time.Clock.Internal.UTCTime.UTCTime ww1 ww2 ->
                    case Data.Time.LocalTime.Internal.LocalTime.$wutcToLocalTime
                           ipv3
                           ww1
                           ww2 of ww3 { (#,#) ww4 ww5 ->
                    case ww5 of wild { Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay hour minute second ->
                    case hour of ww7 { GHC.Types.I# ww8 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww8
                           (GHC.Types.[] @ GHC.Types.Char) of ww9 { (#,#) ww10 ww6 ->
                    GHC.Base.++_$s++
                      @ GHC.Types.Char
                      (GHC.CString.unpackAppendCString#
                         AronModule.getTime2
                         (case minute of ww11 { GHC.Types.I# ww12 ->
                          case GHC.Show.$wshowSignedInt
                                 0#
                                 ww12
                                 (GHC.Types.[] @ GHC.Types.Char) of ww13 { (#,#) ww14 ww15 ->
                          GHC.Base.++_$s++
                            @ GHC.Types.Char
                            (GHC.CString.unpackAppendCString#
                               AronModule.getTime2
                               (Data.Fixed.$fShowFixed_$sshowFixed
                                  @ Data.Fixed.E12
                                  second
                                  Data.Fixed.$fHasResolutionE12_$cresolution
                                    `cast`
                                  (Sym (Data.Fixed.N:HasResolution[0] <Data.Fixed.E12>_N))))
                            ww14
                            ww15 } }))
                      ww10
                      ww6 } } } } } #) } }) -}
8d3661f60b48a9d79a6584c04e45e4c5
  getTime2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
8b48339f11d23a9645ba12a967ce1ca3
  getVec :: GHC.Types.Int -> [[a]] -> [[a]]
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (n :: GHC.Types.Int) (m :: [[a1]]) ->
                 GHC.Base.build
                   @ [a1]
                   (\ @ b1 (c1 :: [a1] -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [a1]
                      @ b1
                      (GHC.Base.mapFB
                         @ [a1]
                         @ b1
                         @ [a1]
                         c1
                         (\ (x1 :: [a1]) ->
                          GHC.Types.: @ a1 (GHC.List.!! @ a1 x1 n) (GHC.Types.[] @ a1)))
                      n1
                      m)) -}
db63d70a7382a3b1a66bf64ba8f9491e
  getX :: AronModule.GPoint -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.GPoint) ->
                 case ds of wild { AronModule.GPoint x1 ds1 -> x1 }) -}
8c42771c30cb6aabea017df9cd560f0f
  getY :: AronModule.GPoint -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.GPoint) ->
                 case ds of wild { AronModule.GPoint ds1 y1 -> y1 }) -}
3a6bf41a7cb4e274f8f2a0a9135e7c22
  gotoCurrDir :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.gotoCurrDir1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
9140faffcee450a1f49d898649ddae64
  gotoCurrDir1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.IO.Error.modifyIOError1
                        @ GHC.IO.FilePath
                        System.Directory.getCurrentDirectory6
                        System.Directory.getCurrentDirectory2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R))
                        s of ds1 { (#,#) ipv ipv1 ->
                 System.Posix.Directory.changeWorkingDirectory1 ipv1 ipv }) -}
53b2d6cbe64707bcd80ed3acf209aab9
  groupCount ::
    [GHC.Base.String] -> [(GHC.Base.String, GHC.Integer.Type.Integer)]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ (GHC.Base.String, GHC.Integer.Type.Integer)
                   : ipv ipv1
                   -> let {
                        n :: [[GHC.Base.String]]
                        = Data.OldList.groupBy
                            @ GHC.Base.String
                            GHC.Base.eqString
                            (Data.OldList.sortBy
                               @ GHC.Base.String
                               GHC.Classes.$fOrd[]_$s$ccompare1
                               wild)
                      } in
                      AronModule.qqsort
                        @ (GHC.Base.String, GHC.Integer.Type.Integer)
                        AronModule.groupCount2
                        (AronModule.groupCount_go
                           n
                           (GHC.Base.map
                              @ [GHC.Base.String]
                              @ GHC.Integer.Type.Integer
                              AronModule.groupCount1
                              n)) }) -}
a239f4eff674aad3fddd16c613c07354
  groupCount1 :: [GHC.Base.String] -> GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (a1 :: [GHC.Base.String]) ->
                 case GHC.List.$wlenAcc @ [GHC.Types.Char] a1 0# of ww2 { DEFAULT ->
                 GHC.Integer.Type.smallInteger ww2 }) -}
a6fbb9f469918c7b4cd4e079d60bbe3e
  groupCount2 ::
    (GHC.Base.String, GHC.Integer.Type.Integer)
    -> (GHC.Base.String, GHC.Integer.Type.Integer) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,U)><S(LS),1*U(A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: (GHC.Base.String, GHC.Integer.Type.Integer))
                   (y1 :: (GHC.Base.String, GHC.Integer.Type.Integer)) ->
                 case x1 of wild { (,) ds1 y2 ->
                 case y1 of wild1 { (,) ds2 y3 ->
                 case GHC.Integer.Type.gtInteger# y2 y3 of wild2 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 } } }) -}
1eaa45fbbfea392b898131544fbea222
  groupCount_go ::
    [[GHC.Base.String]]
    -> [GHC.Integer.Type.Integer]
    -> [([GHC.Types.Char], GHC.Integer.Type.Integer)]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
7152aed9be3ac76a6387d80695d68abe
  head' :: [a] -> a
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ @ a1 (cx :: [a1]) ->
                 case GHC.List.$wlenAcc @ a1 cx 0# of ww2 { DEFAULT ->
                 case GHC.Prim.># ww2 0# of lwild {
                   DEFAULT -> AronModule.head'1 @ a1
                   1# -> GHC.List.head @ a1 cx } }) -}
72d51efc1bada9f67372e55a46f96484
  head'1 :: a
  {- Strictness: x -}
5e9cd1419b422dc702361ba9db644583
  help :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.help1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
71de6eb6d30ca760dd27fc8a4082db0d
  help1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
b7dfcd8acaa82bc52f0e1c4e94de1b4c
  ident :: GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer) ->
                 let {
                   lim :: GHC.Integer.Type.Integer
                   = GHC.Integer.Type.minusInteger n AronModule.df3
                 } in
                 let {
                   m :: [GHC.Integer.Type.Integer]
                   = letrec {
                       go29 :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x1 :: GHC.Integer.Type.Integer) ->
                         case GHC.Integer.Type.gtInteger# x1 n of wild {
                           DEFAULT
                           -> GHC.Types.:
                                @ GHC.Integer.Type.Integer
                                AronModule.$fDnumDoubleInt1
                                (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                           1# -> GHC.Types.[] @ GHC.Integer.Type.Integer }
                     } in
                     go29 AronModule.df3
                 } in
                 letrec {
                   go29 :: GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Integer.Type.Integer) ->
                     case GHC.Integer.Type.gtInteger# x1 lim of wild {
                       DEFAULT
                       -> GHC.Types.:
                            @ [GHC.Integer.Type.Integer]
                            (case GHC.Integer.Type.integerToInt x1 of wild1 { DEFAULT ->
                             let {
                               karg :: [GHC.Integer.Type.Integer]
                               = case GHC.Integer.Type.integerToInt
                                        (GHC.Integer.Type.minusInteger lim x1) of wild2 { DEFAULT ->
                                 case GHC.Prim.<# 0# wild2 of lwild {
                                   DEFAULT -> GHC.Types.[] @ GHC.Integer.Type.Integer
                                   1#
                                   -> GHC.List.$wunsafeTake @ GHC.Integer.Type.Integer wild2 m } }
                             } in
                             case GHC.Prim.<# 0# wild1 of lwild {
                               DEFAULT
                               -> GHC.Base.++
                                    @ GHC.Integer.Type.Integer
                                    (GHC.Types.[] @ GHC.Integer.Type.Integer)
                                    (GHC.Types.: @ GHC.Integer.Type.Integer AronModule.df3 karg)
                               1#
                               -> GHC.Base.++
                                    @ GHC.Integer.Type.Integer
                                    (GHC.List.$wunsafeTake @ GHC.Integer.Type.Integer wild1 m)
                                    (GHC.Types.:
                                       @ GHC.Integer.Type.Integer
                                       AronModule.df3
                                       karg) } })
                            (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                       1# -> GHC.Types.[] @ [GHC.Integer.Type.Integer] }
                 } in
                 go29 AronModule.$fDnumDoubleInt1) -}
d4cc349ae08ccc0209347ad4250a0db5
  ident' :: GHC.Num.Num a => GHC.Types.Int -> [[a]]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (w :: GHC.Num.Num a1) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 AronModule.$wident' @ a1 w ww1 }) -}
588c9bfe3dbd9e2b84faf94b863bd2bb
  ident'1 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0##) -}
c4fc316c100cf62a5232f3aa7b6ac14c
  identS :: GHC.Integer.Type.Integer -> [[GHC.Base.String]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer) ->
                 let {
                   lim :: GHC.Integer.Type.Integer
                   = GHC.Integer.Type.minusInteger n AronModule.df3
                 } in
                 let {
                   m :: [[GHC.Types.Char]]
                   = letrec {
                       go29 :: GHC.Integer.Type.Integer -> [[GHC.Types.Char]]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x1 :: GHC.Integer.Type.Integer) ->
                         case GHC.Integer.Type.gtInteger# x1 n of wild {
                           DEFAULT
                           -> GHC.Types.:
                                @ [GHC.Types.Char]
                                AronModule.identS3
                                (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                           1# -> GHC.Types.[] @ [GHC.Types.Char] }
                     } in
                     go29 AronModule.df3
                 } in
                 letrec {
                   go29 :: GHC.Integer.Type.Integer -> [[GHC.Base.String]]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Integer.Type.Integer) ->
                     case GHC.Integer.Type.gtInteger# x1 lim of wild {
                       DEFAULT
                       -> GHC.Types.:
                            @ [GHC.Base.String]
                            (case GHC.Integer.Type.integerToInt x1 of wild1 { DEFAULT ->
                             let {
                               karg :: [[GHC.Types.Char]]
                               = case GHC.Integer.Type.integerToInt
                                        (GHC.Integer.Type.minusInteger lim x1) of wild2 { DEFAULT ->
                                 case GHC.Prim.<# 0# wild2 of lwild {
                                   DEFAULT -> GHC.Types.[] @ [GHC.Types.Char]
                                   1# -> GHC.List.$wunsafeTake @ [GHC.Types.Char] wild2 m } }
                             } in
                             case GHC.Prim.<# 0# wild1 of lwild {
                               DEFAULT
                               -> GHC.Base.++
                                    @ [GHC.Types.Char]
                                    (GHC.Types.[] @ [GHC.Types.Char])
                                    (GHC.Types.: @ [GHC.Types.Char] AronModule.identS1 karg)
                               1#
                               -> GHC.Base.++
                                    @ [GHC.Types.Char]
                                    (GHC.List.$wunsafeTake @ [GHC.Types.Char] wild1 m)
                                    (GHC.Types.: @ [GHC.Types.Char] AronModule.identS1 karg) } })
                            (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                       1# -> GHC.Types.[] @ [GHC.Base.String] }
                 } in
                 go29 AronModule.$fDnumDoubleInt1) -}
20cf5b89fb042174f1cf6958c13ac7e6
  identS1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.identS2) -}
697d2f171715cab468cb2a2e8a11339e
  identS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("1"#) -}
e6472cc78688c98a5c11002f8e450027
  identS3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.identS4) -}
c423602c963aa3bce06d7214de44fcd8
  identS4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("0"#) -}
69ba97fca465dbd337c31fb92a43f069
  im :: AronModule.C -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C ds1 y1 -> y1 }) -}
cfa5a5964333d178636f5eec92871838
  inorder :: AronModule.Tree a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b2a8ecf4da09929e23145042b9aa8d07
  insertFromList ::
    GHC.Classes.Ord a => AronModule.Tree a -> [a] -> AronModule.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U> -}
ced77d9ada4db0cb907abe8c92344592
  insertNode ::
    GHC.Classes.Ord a => AronModule.Tree a -> a -> AronModule.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U><L,U>m2,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: GHC.Classes.Ord a1)
                   (w1 :: AronModule.Tree a1)
                   (w2 :: a1) ->
                 case AronModule.$winsertNode
                        @ a1
                        w
                        w1
                        w2 of ww { (#,,#) ww1 ww2 ww3 ->
                 AronModule.Node @ a1 ww1 ww2 ww3 }) -}
3e8a8c51292e2c6de5ff868ea992ab8c
  insertTries ::
    GHC.Base.String -> AronModule.XNode -> AronModule.XNode
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: AronModule.XNode) ->
                 case w1 of ww { AronModule.XNode ww1 ww2 ->
                 case AronModule.$winsertTries w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 AronModule.XNode ww4 ww5 } }) -}
bc7e7e9963e64241ac7390fb0dda939e
  insertTriesList ::
    [GHC.Base.String] -> AronModule.XNode -> AronModule.XNode
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Base.String]) (w1 :: AronModule.XNode) ->
                 case w1 of ww { AronModule.XNode ww1 ww2 ->
                 case AronModule.$winsertTriesList
                        w
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 AronModule.XNode ww4 ww5 } }) -}
1c8e22a20fd04c070e846a40875db55f
  intToString :: GHC.Integer.Type.Integer -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShowInteger_$cshow -}
fdb61f06d5bca6d8bd409dbeefd9ccd3
  interleave :: [a] -> [a] -> [a]
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ @ a1 (xs :: [a1]) (ys :: [a1]) ->
                 AronModule.interleave1
                   @ a1
                   (AronModule.tran
                      @ a1
                      (GHC.Types.:
                         @ [a1]
                         xs
                         (GHC.Types.: @ [a1] ys (GHC.Types.[] @ [a1]))))) -}
5cf8f84373687998cb30a6d185905ea2
  interleave1 :: [[a]] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
18bbce9543a564d60e2f6758bde67f83
  invR :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case AronModule.splitR s of wild {
                   [] -> case GHC.List.badHead ret_ty [GHC.Types.Char] of {}
                   : x1 ds1
                   -> case GHC.Integer.Type.eqInteger#
                             x1
                             AronModule.$fDnumDoubleInt1 of wild1 {
                        DEFAULT
                        -> let {
                             cx' :: [GHC.Base.String]
                             = GHC.Base.map
                                 @ GHC.Integer.Type.Integer
                                 @ [GHC.Types.Char]
                                 GHC.Show.$fShowInteger_$cshow
                                 wild
                           } in
                           let {
                             exit9 :: GHC.Base.String -> [GHC.Types.Char]
                               <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (eta :: GHC.Base.String)[OneShot] ->
                               GHC.Base.++
                                 @ GHC.Types.Char
                                 eta
                                 (GHC.CString.unpackAppendCString#
                                    AronModule.addR1
                                    (case cx' of wild2 {
                                       [] -> GHC.List.badHead @ GHC.Base.String : x2 ds2 -> x2 }))
                           } in
                           letrec {
                             go29 :: [GHC.Base.String] -> GHC.Base.String -> [GHC.Types.Char]
                               <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                             = \ (ds :: [GHC.Base.String]) (eta :: GHC.Base.String) ->
                               case ds of wild2 { [] -> exit9 eta : y1 ys -> go29 ys y1 }
                           } in
                           go29 cx' (GHC.List.lastError @ GHC.Base.String)
                        1# -> AronModule.invR1 } }) -}
6b3ab99f7ad6d680d6206ff8c6682002
  invR1 :: [GHC.Types.Char]
  {- Strictness: x -}
8c4719c88f719571ff6d4dc44ee19078
  inverse ::
    [[GHC.Types.Double]] -> ([[GHC.Types.Double]], [[GHC.Base.String]])
  {- Arity: 1, Strictness: <S,U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [[GHC.Types.Double]]) ->
                 case AronModule.$winverse w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
e2618b2ba9cff436b807e6cab2a37801
  isBST :: GHC.Classes.Ord a => AronModule.Tree a -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A)><S,1*U> -}
b06f165a1a30b6ccb3530e2dbfb10c5d
  isBalanced :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ss :: GHC.Base.String) ->
                 AronModule.isBalanced_checkBalance
                   ss
                   (GHC.Types.[] @ GHC.Types.Char)) -}
91687b6a16ab2d5b0764a9f2c27bfd08
  isBalanced2 ::
    GHC.Base.String
    -> GHC.Base.String -> (GHC.Base.String, GHC.Types.Bool)
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: GHC.Base.String) ->
                 case AronModule.$wisBalanced2 w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
fecd13f875678251f849f7cbff8fc438
  isBalanced_checkBalance ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
bb504aeb974ccb2b9b894b7b33c074db
  isDir :: GHC.IO.FilePath -> GHC.Types.IO GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Directory.doesDirectoryExist1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R)) -}
f57b6bcef7de0ac54b951a1f30667268
  isEmpty :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Char]) ->
                 case ds of wild {
                   [] -> GHC.Types.True : ipv ipv1 -> GHC.Types.False }) -}
c44e7cc38916dcb073806f3f5422724e
  isFile :: GHC.IO.FilePath -> GHC.Types.IO GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.isFile1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R)) -}
d59ef716650bf30dba4c1a407956bcd2
  isFile1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (s :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Posix.Files.getFileStatus1
                        s
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, System.Posix.Files.Common.isRegularFile ipv1 #) }) -}
54585fd917174e82fdbf9d0d3330e389
  isInver ::
    (GHC.Real.Fractional a, GHC.Classes.Ord a) =>
    [[a]] -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,1*C1(U))><L,U(A,A,C(C1(U)),A,A,A,A,A)><S,U> -}
166a436cf12e808c3483d55f926622cc
  isInvertible :: [[GHC.Integer.Type.Integer]] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [[GHC.Integer.Type.Integer]]) ->
                 case ds of wild {
                   [] -> GHC.Types.False
                   : ipv ipv1
                   -> AronModule.isInvertible_go
                        (AronModule.upperTri wild)
                        AronModule.df3 }) -}
2ca38c4c9d7412da3ce9e173ad9b53c4
  isInvertible_go ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Integer.Type.Integer -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
4a069366d900fb0a05cf8e13af24fa0c
  isWord :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 Text.Regex.Posix.String.$fRegexLikeRegex[]_$cmatchTest
                   AronModule.isWord1
                   s) -}
f90160ed102e39d87d4761fddb4d6266
  isWord1 :: Text.Regex.Posix.Wrap.Regex
  {- Unfolding: (Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                   Text.Regex.mkRegex1
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                   Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                   (GHC.CString.unpackCString# AronModule.isWord2)) -}
10a2aaf7268577f19ce3d31273ee85b0
  isWord2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("^[[:alpha:]]+$"#) -}
c9d1f2ad4109dc1fee317f367c4ac4ce
  iterateList :: [a] -> (a -> GHC.Types.IO ()) -> GHC.Types.IO ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,C(C1(U(U,A)))><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.iterateList1
                  `cast`
                (forall (a1 :: <*>_N).
                 <[a1]>_R
                 ->_R <a1 -> GHC.Types.IO ()>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
7212ab5ab21c15502900a360db6459d2
  iterateList1 ::
    [a]
    -> (a -> GHC.Types.IO ())
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,C(C1(U(U,A)))><S,U> -}
eb942d8fc005d1315d924b5c50d264e9
  lazyByteStringToLazyText ::
    Data.ByteString.Lazy.Internal.ByteString
    -> Data.Text.Internal.Lazy.Text
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Text.Lazy.Encoding.decodeUtf8 -}
c351e26c06e716ffe794d12a568acf8b
  lazyByteStringToStrictByteString ::
    Data.ByteString.Lazy.Internal.ByteString
    -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.Lazy.toStrict -}
9e08667c0a6fa6c94b1b54c6d2ffbc17
  lazyTextToLazyByteString ::
    Data.Text.Internal.Lazy.Text
    -> Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Data.Text.Lazy.Encoding.encodeUtf8 -}
27db05f689b33ecbbacd841b9605ede3
  lazyTextToStr :: Data.Text.Internal.Lazy.Text -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) Data.Text.Lazy.unpack -}
defd63c330bb7c1674c574474ea81438
  lazyTextToStrictText ::
    Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) Data.Text.Lazy.toStrict -}
98a2c2143507eb11d8975951b9cf9202
  lca ::
    GHC.Classes.Eq a =>
    AronModule.Tree a -> a -> a -> GHC.Maybe.Maybe a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U><L,U> -}
4cc857ee2b0e95a97c1e6a4a81548045
  leftDiagonal ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer]
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*U> -}
551b37e0ae9c916ad59cdb40c7ece76d
  len :: (Data.Foldable.Foldable t, GHC.Num.Num b) => t a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U(U)),A,A,A,A,A)><S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t :: * -> *
                   @ b1
                   @ a1
                   ($dFoldable :: Data.Foldable.Foldable t)
                   ($dNum :: GHC.Num.Num b1)
                   (a2 :: t a1) ->
                 case $dNum of ww { GHC.Num.C:Num ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 ww7
                   (case Data.Foldable.length
                           @ t
                           $dFoldable
                           @ a1
                           a2 of wild { GHC.Types.I# i ->
                    GHC.Integer.Type.smallInteger i }) }) -}
1ae714129f6cec1957405b9e8e847c57
  listAdd :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: [a1])
                   (ds1 :: [a1]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.[] @ a1
                        : ipv2 ipv3
                        -> letrec {
                             go29 :: [a1] -> [a1] -> [a1]
                               {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                             = \ (ds2 :: [a1]) (ds3 :: [a1]) ->
                               case ds2 of wild2 {
                                 [] -> GHC.Types.[] @ a1
                                 : ipv4 ipv5
                                 -> case ds3 of wild3 {
                                      [] -> GHC.Types.[] @ a1
                                      : ipv6 ipv7
                                      -> GHC.Types.:
                                           @ a1
                                           (GHC.Num.+ @ a1 $dNum ipv4 ipv6)
                                           (go29 ipv5 ipv7) } }
                           } in
                           go29 wild wild1 } }) -}
918e4bd1642a0cade545e39a068d03a0
  listDirFilter ::
    GHC.IO.FilePath
    -> GHC.Base.String -> GHC.Types.IO [GHC.IO.FilePath]
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.listDirFilter1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.IO.FilePath]>_R)) -}
eff9d5cc9a9e07865df6a22feea2732f
  listDirFilter1 ::
    GHC.IO.FilePath
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.IO.FilePath] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (regex :: GHC.Base.String)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Directory.getDirectoryContents1
                        p1
                        s of ds6 { (#,#) ipv ipv1 ->
                 (# ipv,
                    let {
                      w :: Text.Regex.Posix.Wrap.Regex
                      = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                          Text.Regex.mkRegexWithOpts2
                            `cast`
                          (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                          Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                            `cast`
                          (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                          regex
                    } in
                    GHC.List.filter
                      @ [GHC.Types.Char]
                      (\ (x1 :: [GHC.Types.Char]) ->
                       case GHC.Classes.$fEqModule_$s$c==
                              x1
                              System.Directory.listDirectory5 of wild {
                         GHC.Types.False
                         -> case GHC.Classes.$fEqModule_$s$c==
                                   x1
                                   System.Directory.listDirectory3 of wild1 {
                              GHC.Types.False
                              -> case w of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                                 Text.Regex.Posix.String.$w$cmatchTest ww1 ww3 x1 }
                              GHC.Types.True -> GHC.Types.False }
                         GHC.Types.True -> GHC.Types.False })
                      ipv1 #) }) -}
2dc09b1c90274a7a8d5a833811388416
  listDot :: GHC.Num.Num a => [a] -> [a] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U))><S,1*U><L,1*U>,
     Unfolding: (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: [a1])
                   (y1 :: [a1]) ->
                 case ds of wild {
                   [] -> GHC.Num.fromInteger @ a1 $dNum AronModule.$fDnumDoubleInt1
                   : ipv ipv1
                   -> case y1 of wild1 {
                        [] -> GHC.Num.fromInteger @ a1 $dNum AronModule.$fDnumDoubleInt1
                        : ipv2 ipv3
                        -> letrec {
                             go29 :: [a1] -> [a1] -> a1 -> a1
                               <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                             = \ (ds1 :: [a1]) (_ys :: [a1]) (eta :: a1) ->
                               case ds1 of wild2 {
                                 [] -> eta
                                 : ipv4 ipv5
                                 -> case _ys of wild3 {
                                      [] -> eta
                                      : ipv6 ipv7
                                      -> go29
                                           ipv5
                                           ipv7
                                           (GHC.Num.+
                                              @ a1
                                              $dNum
                                              eta
                                              (GHC.Num.* @ a1 $dNum ipv4 ipv6)) } }
                           } in
                           go29
                             wild
                             wild1
                             (GHC.Num.fromInteger
                                @ a1
                                $dNum
                                AronModule.$fDnumDoubleInt1) } }) -}
ab89173d7ef87603d4b9e9c1da502665
  listDots :: GHC.Num.Num a => [[a]] -> [[a]] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,1*C(C1(U)),A,A,A,1*C1(U))><S,1*U><L,1*U>,
     Unfolding: (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (x1 :: [[a1]])
                   (y1 :: [[a1]]) ->
                 let {
                   f :: a1 -> a1 -> a1 = GHC.Num.* @ a1 $dNum
                 } in
                 letrec {
                   go29 :: [[a1]] -> [[a1]] -> a1 -> a1
                     <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                   = \ (ds :: [[a1]]) (_ys :: [[a1]]) (eta :: a1) ->
                     case ds of wild {
                       [] -> eta
                       : ipv ipv1
                       -> case _ys of wild1 {
                            [] -> eta
                            : ipv2 ipv3
                            -> let {
                                 exit9 :: a1 -> a1 <join 1> {- Arity: 1, Strictness: <L,U> -}
                                 = \ (eta1 :: a1)[OneShot] -> go29 ipv1 ipv3 eta1
                               } in
                               letrec {
                                 go30 :: [a1] -> a1 -> a1
                                   <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                                 = \ (ds1 :: [a1]) (eta1 :: a1) ->
                                   case ds1 of wild2 {
                                     [] -> exit9 eta1
                                     : y2 ys -> go30 ys (GHC.Num.+ @ a1 $dNum eta1 y2) }
                               } in
                               go30 (GHC.List.zipWith @ a1 @ a1 @ a1 f ipv ipv2) eta } }
                 } in
                 go29
                   x1
                   y1
                   (GHC.Num.fromInteger @ a1 $dNum AronModule.$fDnumDoubleInt1)) -}
9179e39da169244399f38cc522b1f5c6
  listDots_$slistDots ::
    [[GHC.Types.Double]] -> [[GHC.Types.Double]] -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [[GHC.Types.Double]]) (w1 :: [[GHC.Types.Double]]) ->
                 case AronModule.$wgo2 w w1 0.0## of ww { DEFAULT ->
                 GHC.Types.D# ww }) -}
66d491de060e679ee078a0fb2d60951c
  listMul :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: [a1])
                   (ds1 :: [a1]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.[] @ a1
                        : ipv2 ipv3
                        -> letrec {
                             go29 :: [a1] -> [a1] -> [a1]
                               {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                             = \ (ds2 :: [a1]) (ds3 :: [a1]) ->
                               case ds2 of wild2 {
                                 [] -> GHC.Types.[] @ a1
                                 : ipv4 ipv5
                                 -> case ds3 of wild3 {
                                      [] -> GHC.Types.[] @ a1
                                      : ipv6 ipv7
                                      -> GHC.Types.:
                                           @ a1
                                           (GHC.Num.* @ a1 $dNum ipv4 ipv6)
                                           (go29 ipv5 ipv7) } }
                           } in
                           go29 wild wild1 } }) -}
bbde32f1c925ef0ddeddbe22bb80d797
  listNeg :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U),A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (ds :: [a1]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> GHC.Base.build
                        @ a1
                        (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ a1
                           @ b1
                           (GHC.Base.mapFB
                              @ a1
                              @ b1
                              @ a1
                              c1
                              (\ (x1 :: a1) -> GHC.Num.negate @ a1 $dNum x1))
                           n
                           wild) }) -}
e5029965917579af0e082d785667d056
  listScale :: GHC.Num.Num a => [a] -> a -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (ds :: [a1]) (ds1 :: a1) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> GHC.Base.build
                        @ a1
                        (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ a1
                           @ b1
                           (GHC.Base.mapFB
                              @ a1
                              @ b1
                              @ a1
                              c1
                              (\ (x1 :: a1) -> GHC.Num.* @ a1 $dNum ds1 x1))
                           n
                           wild) }) -}
fa0661a09e56dc58c07f09d4b01bb4f7
  listSub :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: [a1])
                   (ds1 :: [a1]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.[] @ a1
                        : ipv2 ipv3
                        -> letrec {
                             go29 :: [a1] -> [a1] -> [a1]
                               {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                             = \ (ds2 :: [a1]) (ds3 :: [a1]) ->
                               case ds2 of wild2 {
                                 [] -> GHC.Types.[] @ a1
                                 : ipv4 ipv5
                                 -> case ds3 of wild3 {
                                      [] -> GHC.Types.[] @ a1
                                      : ipv6 ipv7
                                      -> GHC.Types.:
                                           @ a1
                                           (GHC.Num.- @ a1 $dNum ipv4 ipv6)
                                           (go29 ipv5 ipv7) } }
                           } in
                           go29 wild wild1 } }) -}
034a91033e15ac564add26560bdf5810
  ls :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.ls1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
5efee41ceef921fae9d5254bbd5220b5
  ls1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Process.createProcess1
                        AronModule.ls2
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
89b660bf0d7f763491e36e97166c09b2
  ls2 :: System.Process.Common.CreateProcess
  {- Unfolding: (System.Process.Common.CreateProcess
                   AronModule.ls3
                   (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                   (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                   System.Process.Common.Inherit
                   System.Process.Common.Inherit
                   System.Process.Common.Inherit
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                   (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                   GHC.Types.False) -}
5e6f4a4edf830fbee8c212c469ea1eab
  ls3 :: System.Process.Common.CmdSpec
  {- Strictness: m2,
     Unfolding: (System.Process.Common.RawCommand
                   AronModule.dirModified4
                   (GHC.Types.[] @ GHC.Base.String)) -}
b8ef780a43125294dedc0df381f41d1d
  lsFile :: GHC.Base.String -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.lsFile1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
b7c16be28c3d2641436525de4e2f932e
  lsFile1 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Process.createProcess1
                        (System.Process.Common.CreateProcess
                           (System.Process.Common.RawCommand
                              AronModule.dirModified4
                              (GHC.Types.: @ GHC.Base.String s (GHC.Types.[] @ GHC.Base.String)))
                           (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                           (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                           System.Process.Common.Inherit
                           System.Process.Common.CreatePipe
                           System.Process.Common.Inherit
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                           (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                           GHC.Types.False)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,,) ds hout ds2 ds3 ->
                 case hout of wild1 {
                   GHC.Maybe.Nothing -> (# ipv, GHC.Types.[] @ GHC.Base.String #)
                   GHC.Maybe.Just out
                   -> case GHC.IO.Handle.Text.hGetContents1
                             out
                             ipv of ds4 { (#,#) ipv2 ipv3 ->
                      (# ipv2, Data.OldList.lines ipv3 #) } } } }) -}
5342fe1f3358250f9a8651a9d20ac001
  lsFileFull :: GHC.Base.String -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.dirModified3
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
ce075c0a45ea580a3a767a518213211c
  lsFullRegex ::
    GHC.Base.String
    -> GHC.Base.String -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.lsFullRegex1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
69d162d3e9b5871e1b3903ad9b86ccde
  lsFullRegex1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (r :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case AronModule.dirModified3 s eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    GHC.List.filter
                      @ [GHC.Types.Char]
                      (let {
                         w :: Text.Regex.Posix.Wrap.Regex
                         = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                             Text.Regex.mkRegexWithOpts1
                               `cast`
                             (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                             Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                               `cast`
                             (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                             r
                       } in
                       \ (w1 :: GHC.Base.String) ->
                       case w of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                       Text.Regex.Posix.String.$w$cmatchTest ww1 ww3 w1 })
                      ipv1 #) }) -}
b784afca6c170cf02341284227949184
  lsRegex ::
    GHC.Base.String
    -> GHC.Base.String -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.lsRegex1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
9286a81d3cfd4262bf704b17ca567fd0
  lsRegex1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (r :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Process.createProcess1
                        (System.Process.Common.CreateProcess
                           (System.Process.Common.RawCommand
                              AronModule.dirModified4
                              (GHC.Types.: @ GHC.Base.String s (GHC.Types.[] @ GHC.Base.String)))
                           (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                           (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                           System.Process.Common.Inherit
                           System.Process.Common.CreatePipe
                           System.Process.Common.Inherit
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                           (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                           GHC.Types.False)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,,) ds hout ds2 ds3 ->
                 let {
                   $j :: GHC.Prim.State# GHC.Prim.RealWorld
                         -> [GHC.Base.String]
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
                     <join 2> {- Arity: 2, Strictness: <S,U><L,1*U> -}
                   = \ (ipv2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot]
                       (ipv3 :: [GHC.Base.String])[OneShot] ->
                     (# ipv2,
                        GHC.List.filter
                          @ [GHC.Types.Char]
                          (let {
                             w :: Text.Regex.Posix.Wrap.Regex
                             = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                                 Text.Regex.mkRegexWithOpts1
                                   `cast`
                                 (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                                 Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                                   `cast`
                                 (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                                 r
                           } in
                           \ (w1 :: GHC.Base.String) ->
                           case w of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                           Text.Regex.Posix.String.$w$cmatchTest ww1 ww3 w1 })
                          ipv3 #)
                 } in
                 case hout of wild1 {
                   GHC.Maybe.Nothing -> $j ipv (GHC.Types.[] @ GHC.Base.String)
                   GHC.Maybe.Just out
                   -> case GHC.IO.Handle.Text.hGetContents1
                             out
                             ipv of ds4 { (#,#) ipv2 ipv3 ->
                      $j ipv2 (Data.OldList.lines ipv3) } } } }) -}
5ec4753bbbe297cf299e14619646de5a
  lsRegexFull ::
    GHC.Base.String
    -> GHC.Base.String -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.lsFullRegex1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
563ce83a2f1906f95e00f113ceaa6dd2
  mag :: AronModule.C -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 y1 ->
                 case x1 of wild1 { GHC.Types.F# x2 ->
                 case y1 of wild2 { GHC.Types.F# x3 ->
                 GHC.Types.F#
                   (GHC.Prim.fabsFloat#
                      (GHC.Prim.sqrtFloat#
                         (GHC.Prim.plusFloat#
                            (GHC.Prim.timesFloat# x2 x2)
                            (GHC.Prim.timesFloat# x3 x3)))) } } }) -}
f094902fc21bf0add30cb988e0e13eac
  mat :: [[GHC.Integer.Type.Integer]]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Integer.Type.Integer]
                   AronModule.mat15
                   AronModule.mat1) -}
4f604b278e525ff4533972c561fadeb7
  mat' :: [[[GHC.Types.Char]]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [[GHC.Types.Char]]
                   AronModule.mat'15
                   AronModule.mat'1) -}
d948a3794c96657da5948c24e709f046
  mat'1 :: [[[GHC.Types.Char]]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [[GHC.Types.Char]]
                   AronModule.mat'8
                   AronModule.mat'2) -}
0d834ee73cc9464b486a02e467a838ba
  mat'10 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.mat'6
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
979d69d92b09935103e7fd05f0274c0a
  mat'11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.mat'12) -}
58e9e6c9745a8bcbcc4abdcede90d1fc
  mat'12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("11/3"#) -}
c108c8a02f226b6e86cb1fb9f893929c
  mat'13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.mat'14) -}
93c78eb1cd602bd1dca1d5046c728253
  mat'14 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-2/3"#) -}
68ecc11fe1e895826be16f36de1c190b
  mat'15 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.mat'13
                   AronModule.mat'16) -}
12628f031eeaa0f3bb58e9e41c70928e
  mat'16 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.mat'17
                   AronModule.mat'5) -}
ef70e907bb945c436350985380336159
  mat'17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.mat'18) -}
998118f80e179a96129f83ee342eb171
  mat'18 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-4/3"#) -}
164aa0740d76cc75c704ce6fdc9e47fe
  mat'2 :: [[[GHC.Types.Char]]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [[GHC.Types.Char]]
                   AronModule.mat'3
                   (GHC.Types.[] @ [[GHC.Types.Char]])) -}
6ef1a6e81c81985fda2e4aad39ae50c7
  mat'3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.identS1
                   AronModule.mat'4) -}
82be56838d2fa057005feea7b8ebfcd1
  mat'4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.mat'6
                   AronModule.mat'5) -}
7fbad76b7179419746cf3e2f5e1f1950
  mat'5 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.identS1
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
08526ee586c160a1f391ff9a6aa48e54
  mat'6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.mat'7) -}
bc3701ba796be4e9f8a75710bacb9c9b
  mat'7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-2"#) -}
59b6172f952fcb03f4cffb8306f15a05
  mat'8 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.mat'13
                   AronModule.mat'9) -}
3a7d9889f15d3623b63ca425185f8cce
  mat'9 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   AronModule.mat'11
                   AronModule.mat'10) -}
9413e4eff9c2d0e5660aa8960ed86a75
  mat1 :: [[GHC.Integer.Type.Integer]]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Integer.Type.Integer]
                   AronModule.mat9
                   AronModule.mat2) -}
73c93ff139fcccc63a5795253d93dcef
  mat10 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat13
                   AronModule.mat11) -}
06594a1b201a66be6389501bf3adb014
  mat11 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat12
                   (GHC.Types.[] @ GHC.Integer.Type.Integer)) -}
88af067bb444c5afdf7b85ef3fdc19ca
  mat12 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (6) -}
d0d44c2b46b568043dfd1e2abe278728
  mat13 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (5) -}
f75105c4242d82eafae9a8ae84f51aab
  mat14 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4) -}
66621d9aab9616ccdbb1478b3f50cfbb
  mat15 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.df3
                   AronModule.mat16) -}
e63dfa05f1691093ee11c0f2ebeaf985
  mat16 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.$seven1
                   AronModule.mat17) -}
f8394b3d22cdd61d98f960034371169d
  mat17 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat18
                   (GHC.Types.[] @ GHC.Integer.Type.Integer)) -}
74c235bf8d1b8b55bc540f955e8ddd7c
  mat18 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (3) -}
155d5485157955e34b63612b51730041
  mat2 :: [[GHC.Integer.Type.Integer]]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Integer.Type.Integer]
                   AronModule.mat3
                   (GHC.Types.[] @ [GHC.Integer.Type.Integer])) -}
73d3935438ba2132b4e21d0aa932c20f
  mat3 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat8
                   AronModule.mat4) -}
373cdce2e7b326da495819da2fee0b1d
  mat4 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat7
                   AronModule.mat5) -}
62ee0a84cdee505d8fa00a53dbaf8382
  mat5 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat6
                   (GHC.Types.[] @ GHC.Integer.Type.Integer)) -}
11e00bce8cfb4ea96648568e9eff1615
  mat6 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (10) -}
db329299547b278e147059ae147b85f6
  mat7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (8) -}
fd33177a74147c922c6111634c1d54c2
  mat8 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (7) -}
1c3966254163980982fa781b3e9b1ace
  mat9 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   AronModule.mat14
                   AronModule.mat10) -}
7fab8739add2c726549873d72dd78156
  matDiv ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Integer.Type.Integer -> [[GHC.Integer.Type.Integer]]
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (m :: [[GHC.Integer.Type.Integer]])
                   (n :: GHC.Integer.Type.Integer) ->
                 let {
                   lvl264 :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
                     {- Arity: 1, Strictness: <S,U>,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (y1 :: GHC.Integer.Type.Integer) ->
                                    GHC.Real.$fIntegralInteger_$cdiv y1 n) -}
                   = \ (y1 :: GHC.Integer.Type.Integer) ->
                     GHC.Real.$fIntegralInteger_$cdiv y1 n
                 } in
                 GHC.Base.map
                   @ [GHC.Integer.Type.Integer]
                   @ [GHC.Integer.Type.Integer]
                   (\ (x1 :: [GHC.Integer.Type.Integer]) ->
                    GHC.Base.map
                      @ GHC.Integer.Type.Integer
                      @ GHC.Integer.Type.Integer
                      lvl264
                      x1)
                   m) -}
e6ffc935cd2128ee84cc7a84c4fe0e16
  matr :: [[GHC.Real.Ratio GHC.Integer.Type.Integer]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Real.Ratio GHC.Integer.Type.Integer]
                   AronModule.matr15
                   AronModule.matr1) -}
75adfe81b0b9b023507107bcbfafe04f
  matr1 :: [[GHC.Real.Ratio GHC.Integer.Type.Integer]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Real.Ratio GHC.Integer.Type.Integer]
                   AronModule.matr9
                   AronModule.matr2) -}
66641af5efb6ed18883fd66b302fcfbd
  matr10 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr13
                   AronModule.matr11) -}
b1c691cf6b2e188598d7eb19d54089b9
  matr11 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr12
                   (GHC.Types.[] @ (GHC.Real.Ratio GHC.Integer.Type.Integer))) -}
a3fa0d586d121f7c6e12f83cf6bd184e
  matr12 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat12
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
9f727cf52d0a38910ba2ac73a1d1e941
  matr13 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat13
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
1a9fb93cef1e2933be6bddf2535c927c
  matr14 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat14
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
38282bedaaef336f45b6baca5d8e0dc6
  matr15 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr20
                   AronModule.matr16) -}
d3ecc68b264c4fa8fd77362acd6da9d7
  matr16 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr19
                   AronModule.matr17) -}
15b688fc8d57644f4fcd48c5e833cf2e
  matr17 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr18
                   (GHC.Types.[] @ (GHC.Real.Ratio GHC.Integer.Type.Integer))) -}
c2c9ea882cb74bdfc99cbbd636a7f400
  matr18 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat18
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
89679e20d2e940bb9b11ff2731270b1d
  matr19 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.$seven1
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
999c8658041bf21f313d3d94cd92a052
  matr2 :: [[GHC.Real.Ratio GHC.Integer.Type.Integer]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Real.Ratio GHC.Integer.Type.Integer]
                   AronModule.matr3
                   (GHC.Types.[] @ [GHC.Real.Ratio GHC.Integer.Type.Integer])) -}
dcf47bb6fa809f47ab3f6b184a3cc924
  matr20 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.df3
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
322911974269d5a974327b9aa6840e0d
  matr3 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr8
                   AronModule.matr4) -}
3158726d30ecc5cfc6088c7bc38e0bdd
  matr4 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr7
                   AronModule.matr5) -}
125756d8df0ef30bcb04d723f8b2a130
  matr5 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr6
                   (GHC.Types.[] @ (GHC.Real.Ratio GHC.Integer.Type.Integer))) -}
bba2329dcac70d270dac70e9c4c6573e
  matr6 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat6
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
e7bcc2381c59f687acf8a3003c8f3355
  matr7 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat7
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
c8c15332cb36aed5f3add73e887ad534
  matr8 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- Unfolding: (case GHC.Real.$w$s$cfromRational
                        AronModule.mat8
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 }) -}
0ea2aa227dca43ff3be634ce1db5ae87
  matr9 :: [GHC.Real.Ratio GHC.Integer.Type.Integer]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   AronModule.matr14
                   AronModule.matr10) -}
a26178e8053130dcd438d65c519f2017
  maxlen :: AronModule.Tree a -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
673c0514691c5e0317173df2b5649660
  mergeList :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
64ead33c9b9122eeb1bd489eb73c4f28
  mergeListLen :: [a] -> [a] -> GHC.Maybe.Maybe [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
a242fa00514c79879d762d42f024131c
  mergeListList ::
    [[GHC.Base.String]] -> [[GHC.Base.String]] -> [[GHC.Base.String]]
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
bd0f9faf4d11f3031522f5bf484154e1
  mergeSort :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U> -}
133dc215ef93bea6085329a30fd4bc56
  mergeSortC :: (a -> a -> GHC.Types.Bool) -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U> -}
0b79f399eeae3d08243f0c00c172204b
  mergeSortList :: GHC.Classes.Ord a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U> -}
f36762dbbf23e0e7b9b3988312dba337
  mergeSortM :: (GHC.Num.Num a, GHC.Classes.Eq a) => [[a]] -> [[a]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U(C(C1(U)),A)><S,1*U> -}
48606ea626ab592b299611aa4bf78faf
  mergeSortM_$smergeSortM ::
    [[GHC.Real.Rational]] -> [[GHC.Real.Rational]]
  {- Arity: 1, Strictness: <S,1*U> -}
009cb98b0084d558c137cc73bfd99e63
  mergeSortM_$smergeSortM1 ::
    [[GHC.Integer.Type.Integer]] -> [[GHC.Integer.Type.Integer]]
  {- Arity: 1, Strictness: <S,1*U> -}
07ea48c9be649907bd87a22883e37129
  mkdir :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.mkdir1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
d9e738eead35dabfeef2e38f579393f4
  mkdir1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Directory.createDirectoryIfMissing_g s of wild1 {
                   []
                   -> System.Directory.createDirectoryIfMissing4
                        System.Directory.createDirectoryIfMissing3
                        eta
                   : x1 xs
                   -> System.Directory.createDirectoryIfMissing4
                        (GHC.List.$wunsafeTake
                           @ [GHC.Types.Char]
                           1#
                           (GHC.List.reverse1
                              @ GHC.IO.FilePath
                              (GHC.Types.:
                                 @ GHC.IO.FilePath
                                 x1
                                 (case GHC.List.$wscanlGo
                                         @ GHC.IO.FilePath
                                         @ GHC.IO.FilePath
                                         @ GHC.IO.FilePath
                                         @ GHC.IO.FilePath
                                         System.FilePath.Posix.combine
                                         x1
                                         xs of ww { (#,#) ww1 ww2 ->
                                  ww2 }))
                              (GHC.Types.[] @ GHC.IO.FilePath)))
                        eta }) -}
60b151bda6c7430fa58d799e49e04506
  mkdirp :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.mkdirp1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
68a4a58a669d6c8eada8308abff6b135
  mkdirp1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Directory.createDirectoryIfMissing_g s of wild1 {
                   []
                   -> System.Directory.createDirectoryIfMissing4
                        System.Directory.createDirectoryIfMissing2
                        eta
                   : x1 xs
                   -> System.Directory.createDirectoryIfMissing4
                        (GHC.List.reverse1
                           @ GHC.IO.FilePath
                           (GHC.Types.:
                              @ GHC.IO.FilePath
                              x1
                              (case GHC.List.$wscanlGo
                                      @ GHC.IO.FilePath
                                      @ GHC.IO.FilePath
                                      @ GHC.IO.FilePath
                                      @ GHC.IO.FilePath
                                      System.FilePath.Posix.combine
                                      x1
                                      xs of ww { (#,#) ww1 ww2 ->
                               ww2 }))
                           (GHC.Types.[] @ GHC.IO.FilePath))
                        eta }) -}
9b0fe257ae63c1f08b98df3bb3ed24c5
  mlist ::
    GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer)
                   (ds :: [GHC.Integer.Type.Integer]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Integer.Type.Integer
                   : ipv ipv1
                   -> let {
                        z2 :: GHC.Integer.Type.Integer
                        = GHC.Integer.Type.timesInteger AronModule.$fDnumDoubleInt1 n
                      } in
                      let {
                        z3 :: [GHC.Integer.Type.Integer]
                        = GHC.Types.:
                            @ GHC.Integer.Type.Integer
                            z2
                            (GHC.Types.[] @ GHC.Integer.Type.Integer)
                      } in
                      letrec {
                        go29 :: [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [GHC.Integer.Type.Integer]) ->
                          case ds1 of wild1 {
                            [] -> z3
                            : y1 ys
                            -> GHC.Types.:
                                 @ GHC.Integer.Type.Integer
                                 (GHC.Integer.Type.timesInteger y1 n)
                                 (go29 ys) }
                      } in
                      AronModule.$wf'
                        AronModule.$fDnumDoubleInt1
                        (go29
                           (GHC.List.reverse1
                              @ GHC.Integer.Type.Integer
                              wild
                              (GHC.Types.[] @ GHC.Integer.Type.Integer))) }) -}
dc9086e717e8845663f2c4300656b583
  multR :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>m2, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: GHC.Base.String) ->
                 case AronModule.$wmultR w w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Char ww1 ww2 }) -}
fd6f0ad84a7d1b7c4a769525aee57486
  multRL :: GHC.Base.String -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (s :: GHC.Base.String) (cx :: [GHC.Base.String]) ->
                 GHC.Base.build
                   @ [GHC.Types.Char]
                   (\ @ b1
                      (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Types.Char]
                         @ b1
                         @ [GHC.Types.Char]
                         c1
                         (\ (x1 :: GHC.Base.String) -> AronModule.multR s x1))
                      n
                      cx)) -}
f1d634dd4e63bccc1bd66cc8fad53785
  multR_go2 ::
    [GHC.Integer.Type.Integer]
    -> [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
24a3a54d0352271e3a1043dad0b81c91
  multiMat :: GHC.Num.Num a => [[a]] -> [[a]] -> [[a]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U))><S,U><L,1*U> -}
c0c7cccf1c9b68db3f5bfde28abbe75b
  multiMatDouble ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]] -> [[GHC.Types.Double]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (a1 :: [[GHC.Types.Double]])
                   (b1 :: [[GHC.Types.Double]]) ->
                 let {
                   lvl264 :: [[GHC.Types.Double]]
                   = Data.OldList.transpose @ GHC.Types.Double b1
                 } in
                 letrec {
                   go29 :: [[GHC.Types.Double]] -> [[GHC.Types.Double]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Types.Double]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [GHC.Types.Double]
                       : y1 ys
                       -> GHC.Types.:
                            @ [GHC.Types.Double]
                            (letrec {
                               go30 :: [[GHC.Types.Double]] -> [GHC.Types.Double]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds1 :: [[GHC.Types.Double]]) ->
                                 case ds1 of wild1 {
                                   [] -> GHC.Types.[] @ GHC.Types.Double
                                   : y2 ys1
                                   -> GHC.Types.:
                                        @ GHC.Types.Double
                                        (AronModule.$wgo1 y1 y2 0.0##)
                                        (go30 ys1) }
                             } in
                             go30 lvl264)
                            (go29 ys) }
                 } in
                 go29 a1) -}
26b843656e28c3f711950ec813f145ac
  multiMatInt ::
    [[GHC.Types.Int]] -> [[GHC.Types.Int]] -> [[GHC.Types.Int]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (a1 :: [[GHC.Types.Int]])
                   (b1 :: [[GHC.Types.Int]]) ->
                 let {
                   lvl264 :: [[GHC.Types.Int]]
                   = Data.OldList.transpose @ GHC.Types.Int b1
                 } in
                 letrec {
                   go29 :: [[GHC.Types.Int]] -> [[GHC.Types.Int]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Types.Int]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [GHC.Types.Int]
                       : y1 ys
                       -> GHC.Types.:
                            @ [GHC.Types.Int]
                            (letrec {
                               go30 :: [[GHC.Types.Int]] -> [GHC.Types.Int]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds1 :: [[GHC.Types.Int]]) ->
                                 case ds1 of wild1 {
                                   [] -> GHC.Types.[] @ GHC.Types.Int
                                   : y2 ys1
                                   -> GHC.Types.:
                                        @ GHC.Types.Int
                                        (AronModule.$wgo5 y1 y2 0#)
                                        (go30 ys1) }
                             } in
                             go30 lvl264)
                            (go29 ys) }
                 } in
                 go29 a1) -}
69b6379ff2644ad0f3d93ff31b71f5b7
  multiMatR ::
    [[GHC.Real.Rational]]
    -> [[GHC.Real.Rational]] -> [[GHC.Real.Rational]]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (mat19 :: [[GHC.Real.Rational]])
                   (mat20 :: [[GHC.Real.Rational]]) ->
                 Data.OldList.transpose
                   @ GHC.Real.Rational
                   (GHC.Base.map
                      @ [GHC.Real.Rational]
                      @ [GHC.Real.Rational]
                      (\ (m2 :: [GHC.Real.Rational]) ->
                       GHC.Base.map
                         @ [GHC.Real.Rational]
                         @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                         (\ (m1 :: [GHC.Real.Rational]) ->
                          AronModule.$wgo6
                            m1
                            m2
                            AronModule.$fDnumDoubleInt1
                            GHC.Real.$fEnumRatio1)
                         mat19)
                      (Data.OldList.transpose @ GHC.Real.Rational mat20))) -}
bf494ed2cd787ab4f578806030f7c200
  multiRatMat ::
    [[GHC.Base.String]] -> [[GHC.Base.String]] -> [[GHC.Base.String]]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (a1 :: [[GHC.Base.String]])
                   (b1 :: [[GHC.Base.String]]) ->
                 let {
                   lvl264 :: [[GHC.Base.String]]
                   = Data.OldList.transpose @ GHC.Base.String b1
                 } in
                 letrec {
                   go29 :: [[GHC.Base.String]] -> [[GHC.Base.String]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Base.String]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [GHC.Base.String]
                       : y1 ys
                       -> GHC.Types.:
                            @ [GHC.Base.String]
                            (letrec {
                               go30 :: [[GHC.Base.String]] -> [GHC.Base.String]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds1 :: [[GHC.Base.String]]) ->
                                 case ds1 of wild1 {
                                   [] -> GHC.Types.[] @ GHC.Base.String
                                   : y2 ys1
                                   -> GHC.Types.:
                                        @ GHC.Base.String
                                        (AronModule.multiRatMat_go2 y1 y2 AronModule.multiRatMat1)
                                        (go30 ys1) }
                             } in
                             go30 lvl264)
                            (go29 ys) }
                 } in
                 go29 a1) -}
6495f9d872cb4d1308e9bc3ae438835d
  multiRatMat1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.multiRatMat2) -}
b1e9af4fe7d40409a28ab6f931618989
  multiRatMat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("0/1"#) -}
7dd004fe516bebc9bc34cb8e6e8726a9
  multiRatMat_go2 ::
    [[GHC.Types.Char]]
    -> [[GHC.Types.Char]] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*U> -}
7b05f39fec744eef208cefaf8582a88c
  mv :: GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.mv1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
3fe848bb501f7a835c1a1fce19653f05
  mv1 ::
    GHC.IO.FilePath
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (s :: GHC.IO.FilePath)
                   (d1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Posix.Files.getFileStatus1
                        s
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1
                        `cast`
                      (System.Posix.Files.Common.N:FileStatus[0]) of ww { GHC.ForeignPtr.ForeignPtr ww1 ww2 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             System.Posix.Types.FileMode #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.noDuplicate#
                                @ GHC.Prim.RealWorld
                                s1 of s' { DEFAULT ->
                         case GHC.Prim.readWord16OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# ww1 4#)
                                0#
                                s' of ds2 { (#,#) ipv2 ipv3 ->
                         case GHC.Prim.touch#
                                @ 'GHC.Types.LiftedRep
                                @ GHC.ForeignPtr.ForeignPtrContents
                                ww2
                                ipv2 of s'1 { DEFAULT ->
                         (# s'1,
                            (GHC.Word.W16# ipv3)
                              `cast`
                            (Sym (System.Posix.Types.N:CMode[0])) #) } } }) of ds { (#,#) ipv2 ipv3 ->
                 case ipv3
                        `cast`
                      (System.Posix.Types.N:CMode[0]) of wild { GHC.Word.W16# x# ->
                 case GHC.Prim.and# x# 61440## of wild1 {
                   DEFAULT -> System.Directory.renameDirectory1 s d1 ipv
                   32768## -> System.Directory.copyFile2 s d1 ipv } } } } }) -}
aa9019ba3327848260fafd96e8cc8f72
  mvFile :: GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Directory.copyFile2
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
b2041879218a4999b3e776072d1279af
  mvFiles :: GHC.Base.String -> GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.mvFiles1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
aefc9d71d5b3dd8069779c9bbbb1dce3
  mvFiles1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.Base.String)
                   (s :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case AronModule.dirModified3 p1 eta of ds1 { (#,#) ipv ipv1 ->
                 letrec {
                   go29 :: [GHC.IO.FilePath]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, [()] #)
                     {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [GHC.IO.FilePath])
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Types.[] @ () #)
                       : y1 ys
                       -> case System.Posix.Files.getFileStatus1
                                 y1
                                 eta1 of ds2 { (#,#) ipv2 ipv3 ->
                          case ipv3
                                 `cast`
                               (System.Posix.Files.Common.N:FileStatus[0]) of ww { GHC.ForeignPtr.ForeignPtr ww1 ww2 ->
                          case GHC.Magic.runRW#
                                 @ ('GHC.Types.TupleRep
                                      '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                                 @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                      System.Posix.Types.FileMode #)
                                 (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.noDuplicate#
                                         @ GHC.Prim.RealWorld
                                         s1 of s' { DEFAULT ->
                                  case GHC.Prim.readWord16OffAddr#
                                         @ GHC.Prim.RealWorld
                                         (GHC.Prim.plusAddr# ww1 4#)
                                         0#
                                         s' of ds3 { (#,#) ipv4 ipv5 ->
                                  case GHC.Prim.touch#
                                         @ 'GHC.Types.LiftedRep
                                         @ GHC.ForeignPtr.ForeignPtrContents
                                         ww2
                                         ipv4 of s'1 { DEFAULT ->
                                  (# s'1,
                                     (GHC.Word.W16# ipv5)
                                       `cast`
                                     (Sym (System.Posix.Types.N:CMode[0])) #) } } }) of ds3 { (#,#) ipv4 ipv5 ->
                          case ipv5
                                 `cast`
                               (System.Posix.Types.N:CMode[0]) of wild1 { GHC.Word.W16# x# ->
                          let {
                            d1 :: GHC.IO.FilePath
                            = case System.FilePath.Posix.$wsplitExtension
                                     y1 of ww4 { (#,#) ww5 ww6 ->
                              GHC.Base.++
                                @ GHC.Types.Char
                                ww5
                                (GHC.Base.++ @ GHC.Types.Char s ww6) }
                          } in
                          case GHC.Prim.and# x# 61440## of wild2 {
                            DEFAULT
                            -> case System.Directory.renameDirectory1
                                      y1
                                      d1
                                      ipv2 of ds4 { (#,#) ipv6 ipv7 ->
                               case go29 ys ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                               (# ipv8, GHC.Types.: @ () ipv7 ipv9 #) } }
                            32768##
                            -> case System.Directory.copyFile2
                                      y1
                                      d1
                                      ipv2 of ds4 { (#,#) ipv6 ipv7 ->
                               case go29 ys ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                               (# ipv8, GHC.Types.: @ () ipv7 ipv9 #) } } } } } } } }
                 } in
                 case go29 ipv1 ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, GHC.Tuple.() #) } }) -}
c496e0e73acb601bb37f4f2c22c701ec
  nToFractMat ::
    (GHC.Real.Real a, GHC.Real.Fractional b) => [[a]] -> [[b]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(U))><L,U(A,A,A,C(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   @ b1
                   ($dReal :: GHC.Real.Real a1)
                   ($dFractional :: GHC.Real.Fractional b1)
                   (eta :: [[a1]]) ->
                 GHC.Base.build
                   @ [b1]
                   (\ @ b2 (c1 :: [b1] -> b2 -> b2)[OneShot] (n :: b2)[OneShot] ->
                    GHC.Base.foldr
                      @ [a1]
                      @ b2
                      (GHC.Base.mapFB
                         @ [b1]
                         @ b2
                         @ [a1]
                         c1
                         (GHC.Base.map
                            @ a1
                            @ b1
                            (GHC.Real.realToFrac @ a1 @ b1 $dReal $dFractional)))
                      n
                      eta)) -}
8a29e4a44dded7b78b51141b2ad0a4dd
  nToNumMat :: GHC.Num.Num b => [[GHC.Integer.Type.Integer]] -> [[b]]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b1
                   ($dNum :: GHC.Num.Num b1)
                   (m :: [[GHC.Integer.Type.Integer]]) ->
                 GHC.Base.build
                   @ [b1]
                   (\ @ b2 (c1 :: [b1] -> b2 -> b2)[OneShot] (n :: b2)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Integer.Type.Integer]
                      @ b2
                      (GHC.Base.mapFB
                         @ [b1]
                         @ b2
                         @ [GHC.Integer.Type.Integer]
                         c1
                         (GHC.Base.map
                            @ GHC.Integer.Type.Integer
                            @ b1
                            (GHC.Num.fromInteger @ b1 $dNum)))
                      n
                      m)) -}
bbd14b9dda6c98238ac5ec0e7678c4b3
  negList :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (cx :: [GHC.Base.String]) ->
                 GHC.Base.build
                   @ [GHC.Types.Char]
                   (\ @ b1
                      (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Types.Char]
                         @ b1
                         @ [GHC.Types.Char]
                         c1
                         AronModule.negR)
                      n
                      cx)) -}
4e5a6efa3a96b6b840aa3da5e69ae1db
  negR :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 AronModule.multR AronModule.negR1 s) -}
4072d00ef5f79ae4b41e710a082dce54
  negR1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.negR2) -}
05e3c73af645c39338aab596a8ec47d5
  negR2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-1"#) -}
fea97e084b6cde6ec4ea073a7db55667
  normList :: GHC.Float.Floating a => [[a]] -> [[a]]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U(C(C1(U)),A,1*C(C1(U)),A,A,A,1*C1(U)),C(C1(U)),A,A),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: (\ @ a1
                   ($dFloating :: GHC.Float.Floating a1)
                   (eta :: [[a1]]) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a1
                   = GHC.Float.$p1Floating @ a1 $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a1 = GHC.Real.$p1Fractional @ a1 $dFractional
                 } in
                 GHC.Base.map
                   @ [a1]
                   @ [a1]
                   (GHC.Base.map
                      @ a1
                      @ a1
                      (let {
                         ds :: a1
                         = GHC.Float.sqrt
                             @ a1
                             $dFloating
                             (let {
                                f :: a1 -> a1 -> a1 = GHC.Num.* @ a1 $dNum
                              } in
                              letrec {
                                go29 :: [[a1]] -> [[a1]] -> a1 -> a1
                                  <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                                = \ (ds1 :: [[a1]]) (_ys :: [[a1]]) (eta1 :: a1) ->
                                  case ds1 of wild {
                                    [] -> eta1
                                    : ipv ipv1
                                    -> case _ys of wild1 {
                                         [] -> eta1
                                         : ipv2 ipv3
                                         -> let {
                                              exit9 :: a1 -> a1
                                                <join 1> {- Arity: 1, Strictness: <L,U> -}
                                              = \ (eta2 :: a1)[OneShot] -> go29 ipv1 ipv3 eta2
                                            } in
                                            letrec {
                                              go30 :: [a1] -> a1 -> a1
                                                <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                                              = \ (ds2 :: [a1]) (eta2 :: a1) ->
                                                case ds2 of wild2 {
                                                  [] -> exit9 eta2
                                                  : y1 ys
                                                  -> go30 ys (GHC.Num.+ @ a1 $dNum eta2 y1) }
                                            } in
                                            go30
                                              (GHC.List.zipWith @ a1 @ a1 @ a1 f ipv ipv2)
                                              eta1 } }
                              } in
                              go29
                                eta
                                eta
                                (GHC.Num.fromInteger @ a1 $dNum AronModule.$fDnumDoubleInt1))
                       } in
                       \ (ds1 :: a1) -> GHC.Real./ @ a1 $dFractional ds1 ds))
                   eta) -}
05323494d4eda8d9f19b7616e479c242
  normList_$snormList :: [[GHC.Types.Double]] -> [[GHC.Types.Double]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (eta :: [[GHC.Types.Double]]) ->
                 GHC.Base.map
                   @ [GHC.Types.Double]
                   @ [GHC.Types.Double]
                   (GHC.Base.map
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      (let {
                         ds :: GHC.Types.Double
                         = case AronModule.$wgo7 eta eta 0.0## of ww { DEFAULT ->
                           GHC.Types.D# (GHC.Prim.sqrtDouble# ww) }
                       } in
                       \ (ds1 :: GHC.Types.Double) -> GHC.Float.divideDouble ds1 ds))
                   eta) -}
0e044c7eae61e0d004f2b5e6f73de290
  normR :: [GHC.Base.String] -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (ds :: [GHC.Base.String])
                   (ds1 :: [GHC.Base.String]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.[] @ GHC.Types.Char
                        : ipv2 ipv3
                        -> AronModule.multiRatMat_go2
                             wild
                             wild1
                             AronModule.multiRatMat1 } }) -}
7b00ea2a064ca204654f5efd886bc8e2
  normalR :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case AronModule.splitR s of wild {
                   [] -> case GHC.List.badHead ret_ty [GHC.Types.Char] of {}
                   : x1 ds1
                   -> case GHC.Integer.Type.ltInteger#
                             x1
                             AronModule.$fDnumDoubleInt1 of wild1 { DEFAULT ->
                      let {
                        dn :: GHC.Integer.Type.Integer
                        = AronModule.addR_go1
                            wild
                            (GHC.List.lastError @ GHC.Integer.Type.Integer)
                      } in
                      let {
                        $j :: [GHC.Types.Char] <join 0>
                        = case GHC.Integer.Type.gtInteger#
                                 x1
                                 AronModule.$fDnumDoubleInt1 of wild2 {
                            DEFAULT -> s
                            1#
                            -> case GHC.Integer.Type.ltInteger#
                                      dn
                                      AronModule.$fDnumDoubleInt1 of wild3 {
                                 DEFAULT -> s
                                 1#
                                 -> case GHC.Show.$w$cshowsPrec4
                                           0#
                                           (GHC.Integer.Type.negateInteger x1)
                                           (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                    GHC.Base.++_$s++
                                      @ GHC.Types.Char
                                      (GHC.CString.unpackAppendCString#
                                         AronModule.addR1
                                         (case GHC.Show.$w$cshowsPrec4
                                                 0#
                                                 (GHC.Integer.Type.negateInteger dn)
                                                 (GHC.Types.[]
                                                    @ GHC.Types.Char) of ww1 { (#,#) ww5 ww6 ->
                                          GHC.Types.: @ GHC.Types.Char ww5 ww6 }))
                                      ww3
                                      ww4 } } }
                      } in
                      case wild1 of lwild {
                        DEFAULT -> $j
                        1#
                        -> case GHC.Integer.Type.ltInteger#
                                  dn
                                  AronModule.$fDnumDoubleInt1 of wild2 {
                             DEFAULT -> $j
                             1#
                             -> case GHC.Show.$w$cshowsPrec4
                                       0#
                                       (GHC.Integer.Type.negateInteger x1)
                                       (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                GHC.Base.++_$s++
                                  @ GHC.Types.Char
                                  (GHC.CString.unpackAppendCString#
                                     AronModule.addR1
                                     (case GHC.Show.$w$cshowsPrec4
                                             0#
                                             (GHC.Integer.Type.negateInteger dn)
                                             (GHC.Types.[]
                                                @ GHC.Types.Char) of ww1 { (#,#) ww5 ww6 ->
                                      GHC.Types.: @ GHC.Types.Char ww5 ww6 }))
                                  ww3
                                  ww4 } } } } }) -}
685587a01a80d67157cd276a4033b934
  odds :: [a] -> [a]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a1 (cx :: [a1]) ->
                 AronModule.odds1 @ a1 AronModule.df3 cx) -}
980163645f89f3d05134e85582641511
  odds1 :: GHC.Integer.Type.Integer -> [a] -> [a]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
e51520b6059cb523a2919c2fe2de6f72
  oneRoot ::
    (GHC.Types.Double -> GHC.Types.Double)
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Maybe.Maybe GHC.Types.Double
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(S(S)),C(U(U))><L,U(U)><L,U(U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Types.Double -> GHC.Types.Double)
                   (w1 :: GHC.Types.Double)
                   (w2 :: GHC.Types.Double)
                   (w3 :: GHC.Types.Double) ->
                 case w3 of ww { GHC.Types.D# ww1 ->
                 AronModule.$woneRoot w w1 w2 ww1 }) -}
3b198ba16908a0354e2089e1499bf6f5
  orgList :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (cs :: [GHC.Base.String]) ->
                 GHC.Types.:
                   @ [GHC.Types.Char]
                   (GHC.Base.build
                      @ GHC.Types.Char
                      (\ @ b1 -> GHC.CString.unpackFoldrCString# @ b1 "|"#))
                   (AronModule.interleave
                      @ GHC.Base.String
                      cs
                      AronModule.orgList_xs)) -}
8e00aedcbaedf566b043dc982519c459
  orgList_xs :: [[GHC.Types.Char]]
  {- Strictness: m2 -}
3c08476619b24e0ed706137769c2a170
  orgTable ::
    GHC.IO.FilePath -> [[GHC.Base.String]] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.orgTable1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[[GHC.Base.String]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
46c9ee523bf71137df9404bf495a9505
  orgTable1 ::
    GHC.IO.FilePath
    -> [[GHC.Base.String]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (cs :: [[GHC.Base.String]])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 letrec {
                   go29 :: [[GHC.Base.String]]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [[GHC.Base.String]])
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y1 ys
                       -> case System.IO.appendFile2
                                 @ ()
                                 p1
                                 GHC.IO.IOMode.AppendMode
                                 (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot] ->
                                  GHC.IO.Handle.Text.hPutStr'
                                    hdl
                                    (Data.OldList.unlines
                                       (GHC.Types.:
                                          @ GHC.Base.String
                                          (AronModule.cat
                                             (GHC.Types.:
                                                @ [GHC.Types.Char]
                                                AronModule.orgTable_x
                                                (AronModule.interleave
                                                   @ GHC.Base.String
                                                   y1
                                                   AronModule.orgList_xs)))
                                          (GHC.Types.[] @ GHC.Base.String)))
                                    GHC.Types.False)
                                 eta1 of ds1 { (#,#) ipv ipv1 ->
                          go29 ys ipv } }
                 } in
                 go29 cs eta) -}
27569259056f3b0b8845f3bdfd72077e
  orgTable2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("|"#) -}
0f9b21e29ee00d549d66d3327b2e0c24
  orgTable_x :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.orgTable2) -}
7b4a1f9b6a64a47295f55c7435a2bbcb
  outer :: GHC.Num.Num a => [a] -> [a] -> [[a]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><S,1*U><L,U>,
     Unfolding: (\ @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (s1 :: [a1])
                   (s2 :: [a1]) ->
                 GHC.Base.map
                   @ a1
                   @ [a1]
                   (\ (x1 :: a1) ->
                    GHC.Base.map
                      @ a1
                      @ a1
                      (\ (x2 :: a1) -> GHC.Num.* @ a1 $dNum x1 x2)
                      s2)
                   s1) -}
f72bb5b9361d8db8eece99788f641869
  outerStr :: (a -> a -> a) -> [[a]] -> [[a]] -> [[a]]
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><L,U>,
     Unfolding: (\ @ a1
                   (f :: a1 -> a1 -> a1)
                   (v :: [[a1]])
                   (r :: [[a1]]) ->
                 letrec {
                   go29 :: [[a1]] -> [[a1]] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[a1]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [a1]
                       : y1 ys
                       -> let {
                            lvl264 :: a1
                            = case y1 of wild1 { [] -> GHC.List.badHead @ a1 : x1 ds1 -> x1 }
                          } in
                          let {
                            lvl265 :: a1 -> a1
                              {- Arity: 1, Strictness: <L,U>,
                                 Unfolding: InlineRule (1, True, False)
                                            (\ (rr :: a1) -> f lvl264 rr) -}
                            = \ (rr :: a1) -> f lvl264 rr
                          } in
                          let {
                            z2 :: [[a1]] = go29 ys
                          } in
                          letrec {
                            go30 :: [[a1]] -> [[a1]] {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [[a1]]) ->
                              case ds1 of wild1 {
                                [] -> z2
                                : y2 ys1
                                -> GHC.Types.:
                                     @ [a1]
                                     (GHC.Base.map @ a1 @ a1 lvl265 y2)
                                     (go30 ys1) }
                          } in
                          go30 r }
                 } in
                 go29 v) -}
84339a66c7e5636fe8183b93f5f85200
  p :: GHC.Show.Show s => s -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (0, True, True) System.IO.print -}
62518ba0bb557474708e056cdc18b0d3
  pa :: GHC.Show.Show a => [[a]] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)))><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.pa1
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Show.Show a1>_R
                 ->_R <[[a1]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
55385588e8d147e553fc3d15c9e83146
  pa1 ::
    GHC.Show.Show a =>
    [[a]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)))><S,1*U><S,U>,
     Unfolding: (\ @ a1
                   ($dShow :: GHC.Show.Show a1)
                   (x1 :: [[a1]])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 letrec {
                   go29 :: [[a1]]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [[a1]]) (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y1 ys
                       -> case (GHC.IO.Handle.Text.hPutStr'
                                  GHC.IO.Handle.FD.stdout
                                  (GHC.Show.$fShow[]_$cshow @ a1 $dShow y1)
                                  GHC.Types.True)
                                 `cast`
                               (GHC.Types.N:IO[0] <()>_R)
                                 eta1 of ds1 { (#,#) ipv ipv1 ->
                          go29 ys ipv } }
                 } in
                 go29 x1 eta) -}
4d1005c4ccf41c7db97e5e8546e8a954
  paa :: GHC.Show.Show a => [[a]] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)))><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.paa1
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Show.Show a1>_R
                 ->_R <[[a1]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
9eceaf8107168a1a11e055edac85c6b3
  paa1 ::
    GHC.Show.Show a =>
    [[a]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)))><S,1*U><S,U>,
     Unfolding: (\ @ a1
                   ($dShow :: GHC.Show.Show a1)
                   (x1 :: [[a1]])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 letrec {
                   go29 :: [[a1]]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [[a1]]) (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y1 ys
                       -> case (GHC.IO.Handle.Text.hPutStr'
                                  GHC.IO.Handle.FD.stdout
                                  (case GHC.Show.showList
                                          @ a1
                                          $dShow
                                          y1
                                          (GHC.Types.[] @ GHC.Types.Char) of wild1 {
                                     [] -> case GHC.List.scanl2 ret_ty GHC.Base.String of {}
                                     : ds1 xs
                                     -> case xs of wild2 {
                                          [] -> GHC.List.init2 @ GHC.Types.Char
                                          : x2 xs1 -> GHC.List.init1 @ GHC.Types.Char x2 xs1 } })
                                  GHC.Types.True)
                                 `cast`
                               (GHC.Types.N:IO[0] <()>_R)
                                 eta1 of ds1 { (#,#) ipv ipv1 ->
                          go29 ys ipv } }
                 } in
                 go29 x1 eta) -}
f6db29b5fd462e872b2827003fc20dee
  parseFileBlock ::
    GHC.Base.String
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [(GHC.Integer.Type.Integer, [GHC.Base.String])]
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>,
     Unfolding: (\ (ds :: GHC.Base.String)
                   (ds1 :: GHC.Base.String)
                   (ds2 :: [GHC.Base.String]) ->
                 case ds2 of wild {
                   [] -> GHC.Types.[] @ (GHC.Integer.Type.Integer, [GHC.Base.String])
                   : ipv ipv1
                   -> letrec {
                        go29 :: [[GHC.Types.Char]] -> [[GHC.Types.Char]]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds3 :: [[GHC.Types.Char]]) ->
                          case ds3 of wild1 {
                            [] -> GHC.Types.[] @ [GHC.Types.Char]
                            : y1 ys
                            -> GHC.Base.++
                                 @ [GHC.Types.Char]
                                 (GHC.List.filter
                                    @ [GHC.Types.Char]
                                    AronModule.parseFileBlock1
                                    (AronModule.splitStrChar ds1 y1))
                                 (go29 ys) }
                      } in
                      letrec {
                        go30 :: [[GHC.Base.String]] -> [[[GHC.Types.Char]]]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds3 :: [[GHC.Base.String]]) ->
                          case ds3 of wild1 {
                            [] -> GHC.Types.[] @ [[GHC.Types.Char]]
                            : y1 ys
                            -> case GHC.List.$wlenAcc
                                      @ [GHC.Types.Char]
                                      y1
                                      0# of ww2 { DEFAULT ->
                               case GHC.Prim.># ww2 0# of lwild {
                                 DEFAULT -> go30 ys
                                 1#
                                 -> GHC.Types.:
                                      @ [[GHC.Types.Char]]
                                      (Data.Set.Internal.$fDataSet_go
                                         @ [GHC.Types.Char]
                                         (GHC.Types.[] @ [GHC.Types.Char])
                                         (AronModule.$sfromList (go29 y1)))
                                      (go30 ys) } } }
                      } in
                      let {
                        lvl264 :: Text.Regex.Posix.Wrap.Regex
                        = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                            Text.Regex.mkRegex1
                              `cast`
                            (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                            Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                              `cast`
                            (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                            ds
                      } in
                      AronModule.parseFileBlock_go
                        AronModule.$fDnumDoubleInt1
                        (go30
                           (Data.List.Split.Internals.splitWhen
                              @ GHC.Base.String
                              (\ (x1 :: GHC.Base.String) ->
                               Text.Regex.Posix.String.$fRegexLikeRegex[]_$cmatchTest lvl264 x1)
                              wild)) }) -}
4739057627aff5142f241f4564979101
  parseFileBlock1 :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (w :: [GHC.Types.Char]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char w 0# of ww2 { DEFAULT ->
                 case GHC.Integer.Type.gtInteger#
                        (GHC.Integer.Type.smallInteger ww2)
                        AronModule.$fDnumDoubleInt1 of wild {
                   DEFAULT -> GHC.Types.False 1# -> AronModule.isWord w } }) -}
f5fff7c656cbfefe7e75914aa0d2bedb
  parseFileBlock_go ::
    GHC.Integer.Type.Integer
    -> [[[GHC.Types.Char]]]
    -> [(GHC.Integer.Type.Integer, [[GHC.Types.Char]])]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
b94f67f2008f188888043892db95b888
  partList :: GHC.Types.Int -> [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U> -}
d3df2055f1c3dffb6e8af9bc02636113
  partList2 :: GHC.Types.Int -> [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ @ a1 (ds :: GHC.Types.Int) (ds1 :: [a1]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ [a1]
                   : ipv ipv1
                   -> GHC.Types.:
                        @ [a1]
                        (case ds of wild1 { GHC.Types.I# y1 ->
                         case GHC.Prim.<# 0# y1 of lwild {
                           DEFAULT -> GHC.Types.[] @ a1
                           1# -> GHC.List.$wunsafeTake @ a1 y1 wild } })
                        (AronModule.partList
                           @ a1
                           ds
                           (AronModule.$wunsafeDrop @ a1 1# wild)) }) -}
02c639e0bbbe3f98933b22a42592d571
  pathBase :: GHC.IO.FilePath -> GHC.IO.FilePath
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.IO.FilePath) ->
                 let {
                   list :: [GHC.Base.String]
                   = GHC.List.filter
                       @ [GHC.Types.Char]
                       AronModule.asplitPath1
                       (Text.Regex.splitRegex AronModule.splitR2 s)
                 } in
                 case GHC.List.$wlenAcc
                        @ [GHC.Types.Char]
                        list
                        0# of ww2 { DEFAULT ->
                 case GHC.Prim.># ww2 0# of lwild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   1# -> GHC.List.last @ GHC.Base.String list } }) -}
e79d16db1732a80ee24a2b4a9a0a387b
  perm :: [a] -> [[[a]]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a1 (ds :: [a1]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ [[a1]]
                   : ipv ipv1
                   -> case GHC.List.$wlenAcc @ a1 wild 0# of ww2 { DEFAULT ->
                      let {
                        y1 :: GHC.Prim.Int# = GHC.Prim.-# ww2 1#
                      } in
                      case GHC.Prim.># 0# y1 of lwild {
                        DEFAULT
                        -> letrec {
                             go29 :: GHC.Prim.Int# -> [[[a1]]] {- Arity: 1, Strictness: <L,U> -}
                             = \ (x1 :: GHC.Prim.Int#) ->
                               GHC.Types.:
                                 @ [[a1]]
                                 (AronModule.$wpp @ a1 x1 wild)
                                 (case GHC.Prim.==# x1 y1 of lwild1 {
                                    DEFAULT -> go29 (GHC.Prim.+# x1 1#)
                                    1# -> GHC.Types.[] @ [[a1]] })
                           } in
                           go29 0#
                        1# -> GHC.Types.[] @ [[a1]] } } }) -}
827f78db98f43da0c5f7075a6ff7e8f8
  perm2 :: GHC.Classes.Eq a => [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(A,C(C1(U)))><S,1*U> -}
8294356e7e0cb8f26491b1957f5170a7
  perm3 :: [a] -> [[a]]
  {- Arity: 1, Strictness: <S,1*U> -}
87d93a9d7331a1da16754a2029e74080
  pf ::
    (Text.Printf.PrintfArg t1, Text.Printf.PrintfType t2) =>
    GHC.Base.String -> t1 -> t2
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(1*C1(U),1*C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ t
                   @ t4
                   ($dPrintfArg :: Text.Printf.PrintfArg t)
                   ($dPrintfType :: Text.Printf.PrintfType t4)
                   (eta :: GHC.Base.String)
                   (eta1 :: t) ->
                 $dPrintfType `cast` (Text.Printf.N:PrintfType[0] <t4>_N)
                   eta
                   (GHC.Types.:
                      @ (Text.Printf.ModifierParser, Text.Printf.FieldFormatter)
                      (Text.Printf.parseFormat @ t $dPrintfArg eta1,
                       Text.Printf.formatArg @ t $dPrintfArg eta1)
                      (GHC.Types.[] @ Text.Printf.UPrintf))) -}
f9157a4bcd971ca89b9e98ff0c1db130
  pm ::
    GHC.Show.Show a => GHC.Base.String -> [[a]] -> GHC.Types.IO ()
  {- Arity: 4, Strictness: <L,U(A,A,C(C1(U)))><L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.pm1
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Show.Show a1>_R
                 ->_R <GHC.Base.String>_R
                 ->_R <[[a1]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
8a1f0bfcbc7a0a910dbf1570d0e30c42
  pm1 ::
    GHC.Show.Show a =>
    GHC.Base.String
    -> [[a]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,U(A,A,C(C1(U)))><L,U><L,1*U><S,U>,
     Unfolding: (\ @ a1
                   ($dShow :: GHC.Show.Show a1)
                   (s :: GHC.Base.String)
                   (x1 :: [[a1]])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (AronModule.fw s) `cast` (GHC.Types.N:IO[0] <()>_R)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 letrec {
                   go29 :: [[a1]]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [[a1]]) (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y1 ys
                       -> case (GHC.IO.Handle.Text.hPutStr'
                                  GHC.IO.Handle.FD.stdout
                                  (GHC.Show.$fShow[]_$cshow @ a1 $dShow y1)
                                  GHC.Types.True)
                                 `cast`
                               (GHC.Types.N:IO[0] <()>_R)
                                 eta1 of ds2 { (#,#) ipv2 ipv3 ->
                          go29 ys ipv2 } }
                 } in
                 go29 x1 ipv }) -}
0624ebd817d7990de8acc0f1d67dfd0c
  pp :: GHC.Show.Show s => s -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (0, True, True) System.IO.print -}
e7726bf0174bb28b4a343d15e9ff733c
  ppad :: GHC.Show.Show a => [[a]] -> [[[GHC.Types.Char]]]
  {- Arity: 2, Strictness: <L,U(A,C(U),A)><S,U>,
     Unfolding: (\ @ a1 ($dShow :: GHC.Show.Show a1) (m :: [[a1]]) ->
                 let {
                   ma :: GHC.Types.Int
                   = let {
                       f :: a1 -> GHC.Base.String = GHC.Show.show @ a1 $dShow
                     } in
                     letrec {
                       go29 :: [[a1]] -> GHC.Types.Int
                         {- Arity: 1, Strictness: <S,1*U>m -}
                       = \ (ds :: [[a1]]) ->
                         case ds of wild {
                           [] -> AronModule.$fShowC6
                           : y1 ys
                           -> case go29 ys of ww { GHC.Types.I# ww1 ->
                              letrec {
                                go30 :: [GHC.Base.String] -> GHC.Types.Int
                                  {- Arity: 1, Strictness: <S,1*U>m -}
                                = \ (ds1 :: [GHC.Base.String]) ->
                                  case ds1 of wild1 {
                                    [] -> ww
                                    : y2 ys1
                                    -> case GHC.List.$wlenAcc
                                              @ GHC.Types.Char
                                              y2
                                              0# of ww2 { DEFAULT ->
                                       case go30 ys1 of wild2 { GHC.Types.I# y3 ->
                                       case GHC.Prim.<=# ww2 y3 of lwild {
                                         DEFAULT -> GHC.Types.I# ww2 1# -> wild2 } } } }
                              } in
                              go30 (GHC.Base.map @ a1 @ GHC.Base.String f y1) } }
                     } in
                     go29 m
                 } in
                 let {
                   lvl264 :: a1 -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <L,U>,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (x1 :: a1) ->
                                    AronModule.ppad_pad1 (GHC.Show.show @ a1 $dShow x1) ma) -}
                   = \ (x1 :: a1) ->
                     case ma of ww { GHC.Types.I# ww1 ->
                     AronModule.$wpad1 (GHC.Show.show @ a1 $dShow x1) ww1 }
                 } in
                 AronModule.tran
                   @ [GHC.Types.Char]
                   (GHC.Base.map
                      @ [a1]
                      @ [[GHC.Types.Char]]
                      (\ (n :: [a1]) -> GHC.Base.map @ a1 @ [GHC.Types.Char] lvl264 n)
                      (AronModule.tran @ a1 m))) -}
be568f2d0067736b380ecc1bd29e2e8e
  ppad_$sppad :: [[GHC.Base.String]] -> [[[GHC.Types.Char]]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (m :: [[GHC.Base.String]]) ->
                 let {
                   ma :: GHC.Types.Int = AronModule.ppad_go m
                 } in
                 let {
                   lvl264 :: GHC.Base.String -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <L,1*U>,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (x1 :: GHC.Base.String) ->
                                    AronModule.ppad_pad
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Show.showLitString x1 GHC.Show.$fShow[]1))
                                      ma) -}
                   = \ (x1 :: GHC.Base.String) ->
                     case ma of ww { GHC.Types.I# ww1 ->
                     AronModule.$wpad
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.$fShow(,)3
                          (GHC.Show.showLitString x1 GHC.Show.$fShow[]1))
                       ww1 }
                 } in
                 AronModule.tran
                   @ [GHC.Types.Char]
                   (GHC.Base.map
                      @ [GHC.Base.String]
                      @ [[GHC.Types.Char]]
                      (\ (n :: [GHC.Base.String]) ->
                       GHC.Base.map @ [GHC.Types.Char] @ [GHC.Types.Char] lvl264 n)
                      (AronModule.tran @ GHC.Base.String m))) -}
8ee286e4d7f4f06c93e9d1f3038e3d7e
  ppad_go :: [[GHC.Base.String]] -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m -}
1807448f5b9bc4d861db58957447db5f
  ppad_pad :: [GHC.Types.Char] -> GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Types.Char]) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 -> AronModule.$wpad w ww1 }) -}
88c33c79d0d55c04f516102d8024fe37
  ppad_pad1 :: [GHC.Types.Char] -> GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Types.Char]) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 -> AronModule.$wpad1 w ww1 }) -}
857ce8302e9122a2dfae7c549f633888
  pre ::
    (Control.Monad.IO.Class.MonadIO m, GHC.Show.Show a) => a -> m ()
  {- Arity: 3,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><L,U(A,C(U),A)><L,U>,
     Unfolding: InlineRule (0, True, True) Text.Pretty.Simple.pPrint -}
01772713736db88ca421aa0b4e020e89
  prefix :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                 case GHC.Prim.># 0# ww2 of lwild {
                   DEFAULT
                   -> letrec {
                        go29 :: GHC.Prim.Int# -> [[GHC.Types.Char]]
                          {- Arity: 1, Strictness: <S,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          let {
                            $j :: [GHC.Types.Char] -> [[GHC.Types.Char]]
                              <join 1> {- Arity: 1, Strictness: <S,U> -}
                            = \ (x2 :: [GHC.Types.Char])[OneShot] ->
                              case GHC.List.$wlenAcc @ GHC.Types.Char x2 0# of ww1 { DEFAULT ->
                              case GHC.Prim.># ww1 0# of lwild1 {
                                DEFAULT
                                -> case GHC.Prim.==# x1 ww2 of lwild2 {
                                     DEFAULT -> go29 (GHC.Prim.+# x1 1#)
                                     1# -> GHC.Types.[] @ [GHC.Types.Char] }
                                1#
                                -> GHC.Types.:
                                     @ [GHC.Types.Char]
                                     x2
                                     (case GHC.Prim.==# x1 ww2 of lwild2 {
                                        DEFAULT -> go29 (GHC.Prim.+# x1 1#)
                                        1# -> GHC.Types.[] @ [GHC.Types.Char] }) } }
                          } in
                          case GHC.Prim.<# 0# x1 of lwild1 {
                            DEFAULT -> $j (GHC.Types.[] @ GHC.Types.Char)
                            1# -> $j (GHC.List.$wunsafeTake @ GHC.Types.Char x1 s) }
                      } in
                      go29 0#
                   1# -> GHC.Types.[] @ [GHC.Types.Char] } }) -}
d508da58159d45cad0aaea45f444c966
  prime :: [GHC.Integer.Type.Integer]
  {- Unfolding: (case GHC.Enum.$wenumDeltaInteger
                        AronModule.$seven1
                        AronModule.df3 of ww { (#,#) ww1 ww2 ->
                 case AronModule.$wsieve
                        (GHC.Types.:
                           @ GHC.Integer.Type.Integer
                           ww1
                           ww2) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Types.: @ GHC.Integer.Type.Integer ww5 ww6 } }) -}
20086b252851ab9766870f0d7959d04f
  principleSubmatrix :: GHC.Types.Int -> [[a]] -> [[a]]
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ @ a1 (n :: GHC.Types.Int) (m :: [[a1]]) ->
                 AronModule.tran
                   @ a1
                   (AronModule.removeIndex
                      @ [a1]
                      n
                      (AronModule.tran @ a1 (AronModule.removeIndex @ [a1] n m)))) -}
258dc1b7343f46420a51c998043d0e01
  proj :: [GHC.Base.String] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,U><L,1*U>,
     Unfolding: (\ (w :: [GHC.Base.String]) (u :: [GHC.Base.String]) ->
                 let {
                   s :: GHC.Base.String
                   = let {
                       karg :: GHC.Base.String
                       = case w of wild {
                           [] -> AronModule.invR (GHC.Types.[] @ GHC.Types.Char)
                           : ipv ipv1
                           -> AronModule.invR
                                (AronModule.multiRatMat_go2 wild wild AronModule.multiRatMat1) }
                     } in
                     case w of wild {
                       []
                       -> case AronModule.$wmultR
                                 (GHC.Types.[] @ GHC.Types.Char)
                                 karg of ww { (#,#) ww1 ww2 ->
                          GHC.Types.: @ GHC.Types.Char ww1 ww2 }
                       : ipv ipv1
                       -> case u of wild1 {
                            []
                            -> case AronModule.$wmultR
                                      (GHC.Types.[] @ GHC.Types.Char)
                                      karg of ww { (#,#) ww1 ww2 ->
                               GHC.Types.: @ GHC.Types.Char ww1 ww2 }
                            : ipv2 ipv3
                            -> case AronModule.$wmultR
                                      (AronModule.multiRatMat_go2
                                         wild
                                         wild1
                                         AronModule.multiRatMat1)
                                      karg of ww { (#,#) ww1 ww2 ->
                               GHC.Types.: @ GHC.Types.Char ww1 ww2 } } }
                 } in
                 GHC.Base.map
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   (\ (x1 :: GHC.Base.String) -> AronModule.multR s x1)
                   w) -}
fd10c2b81c546a1d016f0c375fdb573f
  projn :: GHC.Real.Fractional a => [[a]] -> [[a]] -> [[a]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><L,1*U><S,U>,
     Unfolding: (\ @ a1
                   ($dFractional :: GHC.Real.Fractional a1)
                   (eta :: [[a1]])
                   (eta1 :: [[a1]]) ->
                 let {
                   $dNum :: GHC.Num.Num a1 = GHC.Real.$p1Fractional @ a1 $dFractional
                 } in
                 let {
                   a2 :: a1
                   = let {
                       lvl264 :: a1 -> a1 -> a1 = GHC.Num.* @ a1 $dNum
                     } in
                     let {
                       lvl265 :: a1
                       = GHC.Num.fromInteger @ a1 $dNum AronModule.$fDnumDoubleInt1
                     } in
                     GHC.Real./
                       @ a1
                       $dFractional
                       (letrec {
                          go29 :: [[a1]] -> [[a1]] -> a1 -> a1
                            <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                          = \ (ds :: [[a1]]) (_ys :: [[a1]]) (eta2 :: a1) ->
                            case ds of wild {
                              [] -> eta2
                              : ipv ipv1
                              -> case _ys of wild1 {
                                   [] -> eta2
                                   : ipv2 ipv3
                                   -> let {
                                        exit9 :: a1 -> a1 <join 1> {- Arity: 1, Strictness: <L,U> -}
                                        = \ (eta3 :: a1)[OneShot] -> go29 ipv1 ipv3 eta3
                                      } in
                                      letrec {
                                        go30 :: [a1] -> a1 -> a1
                                          <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                                        = \ (ds1 :: [a1]) (eta3 :: a1) ->
                                          case ds1 of wild2 {
                                            [] -> exit9 eta3
                                            : y1 ys -> go30 ys (GHC.Num.+ @ a1 $dNum eta3 y1) }
                                      } in
                                      go30
                                        (GHC.List.zipWith @ a1 @ a1 @ a1 lvl264 ipv ipv2)
                                        eta2 } }
                        } in
                        go29 eta eta1 lvl265)
                       (letrec {
                          go29 :: [[a1]] -> [[a1]] -> a1 -> a1
                            <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                          = \ (ds :: [[a1]]) (_ys :: [[a1]]) (eta2 :: a1) ->
                            case ds of wild {
                              [] -> eta2
                              : ipv ipv1
                              -> case _ys of wild1 {
                                   [] -> eta2
                                   : ipv2 ipv3
                                   -> let {
                                        exit9 :: a1 -> a1 <join 1> {- Arity: 1, Strictness: <L,U> -}
                                        = \ (eta3 :: a1)[OneShot] -> go29 ipv1 ipv3 eta3
                                      } in
                                      letrec {
                                        go30 :: [a1] -> a1 -> a1
                                          <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                                        = \ (ds1 :: [a1]) (eta3 :: a1) ->
                                          case ds1 of wild2 {
                                            [] -> exit9 eta3
                                            : y1 ys -> go30 ys (GHC.Num.+ @ a1 $dNum eta3 y1) }
                                      } in
                                      go30
                                        (GHC.List.zipWith @ a1 @ a1 @ a1 lvl264 ipv ipv2)
                                        eta2 } }
                        } in
                        go29 eta1 eta1 lvl265)
                 } in
                 GHC.Base.map
                   @ [a1]
                   @ [a1]
                   (GHC.Base.map
                      @ a1
                      @ a1
                      (\ (ds :: a1) -> GHC.Num.* @ a1 $dNum ds a2))
                   eta1) -}
035d39fc2aec674c56e34cd8f776846c
  projn_$sprojn ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]] -> [[GHC.Types.Double]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,U>,
     Unfolding: (\ (eta :: [[GHC.Types.Double]])
                   (eta1 :: [[GHC.Types.Double]]) ->
                 let {
                   a1 :: GHC.Types.Double
                   = case AronModule.$wgo8 eta eta1 0.0## of ww { DEFAULT ->
                     case AronModule.$wgo8 eta1 eta1 0.0## of ww1 { DEFAULT ->
                     case GHC.Prim./## ww ww1 of wild2 { DEFAULT ->
                     GHC.Types.D# wild2 } } }
                 } in
                 GHC.Base.map
                   @ [GHC.Types.Double]
                   @ [GHC.Types.Double]
                   (GHC.Base.map
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      (\ (ds :: GHC.Types.Double) -> GHC.Float.timesDouble ds a1))
                   eta1) -}
5bc23c653749237e7d0db7c81b0291c8
  ps :: [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.ps1
                  `cast`
                (<[GHC.Base.String]>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
263eb0033b7b3b245546a969a6f8c785
  ps1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: [GHC.Base.String])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 letrec {
                   go29 :: [GHC.Base.String]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2 -}
                   = \ (ds :: [GHC.Base.String])
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       [] -> (# eta1, GHC.Tuple.() #)
                       : y1 ys
                       -> case (GHC.IO.Handle.Text.hPutStr'
                                  GHC.IO.Handle.FD.stdout
                                  y1
                                  GHC.Types.True)
                                 `cast`
                               (GHC.Types.N:IO[0] <()>_R)
                                 eta1 of ds1 { (#,#) ipv ipv1 ->
                          go29 ys ipv } }
                 } in
                 go29 x1 eta) -}
db6a1159b84c9e1919347711223c3aba
  putStrBS :: Data.ByteString.Internal.ByteString -> GHC.Types.IO ()
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.putStr1
                  `cast`
                (<Data.ByteString.Internal.ByteString>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
3b925f1e607f9f92412e3684ef94eff7
  putStrLnBS ::
    Data.ByteString.Internal.ByteString -> GHC.Types.IO ()
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.Char8.putStrLn1
                  `cast`
                (<Data.ByteString.Internal.ByteString>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
9b70ee4ab09a34161e0787765673de3a
  pw :: GHC.Show.Show s => GHC.Base.String -> s -> GHC.Types.IO ()
  {- Arity: 4, Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.fpp1
                  `cast`
                (forall (s :: <*>_N).
                 <GHC.Show.Show s>_R
                 ->_R <GHC.Base.String>_R
                 ->_R <s>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
db1073f106033490d4e2fe2776e03afa
  pwd :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.pwd1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
60e848dfbc59e0fd5316bc3b9605d4f6
  pwd1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Process.createProcess1
                        AronModule.pwd2
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
35bb7459ead8588d7f6ca19176ebb58d
  pwd2 :: System.Process.Common.CreateProcess
  {- Unfolding: (System.Process.Common.CreateProcess
                   AronModule.pwd3
                   (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                   (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                   System.Process.Common.Inherit
                   System.Process.Common.Inherit
                   System.Process.Common.Inherit
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   GHC.Types.False
                   (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                   (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                   GHC.Types.False) -}
b7220fab82187d2d6e0ec9aa6722968a
  pwd3 :: System.Process.Common.CmdSpec
  {- Strictness: m2,
     Unfolding: (System.Process.Common.RawCommand
                   AronModule.pwd4
                   (GHC.Types.[] @ GHC.Base.String)) -}
1a7489bb56205be6aa7ffd83f3f364a1
  pwd4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.pwd5) -}
abdcc41d5a96d7e39b7624f01152cf95
  pwd5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pwd"#) -}
4b6406401a6ee79198245489b91dd531
  qqsort :: (a -> a -> GHC.Types.Bool) -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U> -}
7f8aa45abc569837e583f030d7026c08
  qrDecompose' ::
    [[GHC.Types.Double]]
    -> ([[GHC.Types.Double]], [[GHC.Types.Double]])
  {- Arity: 1, Strictness: <L,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [[GHC.Types.Double]]) ->
                 case AronModule.$wqrDecompose' w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
7a617150d940e2a171a486d0b1c31445
  qrDecompose'1 :: [[GHC.Types.Double]] -> [GHC.Types.Double]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (x1 :: [[GHC.Types.Double]]) ->
                 AronModule.qrDecompose'_go1 x1) -}
190545443d8ceb918e9cd7c1ab610b34
  qrDecompose'2 :: [GHC.Types.Double] -> [[GHC.Types.Double]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (r :: [GHC.Types.Double]) ->
                 GHC.Base.build
                   @ [GHC.Types.Double]
                   (\ @ b1
                      (c1 :: [GHC.Types.Double] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Double
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Types.Double]
                         @ b1
                         @ GHC.Types.Double
                         c1
                         AronModule.qrDecompose'3)
                      n
                      r)) -}
ec8018bb1d4f8fab2e5bef2be309280c
  qrDecompose'3 :: GHC.Types.Double -> [GHC.Types.Double]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: GHC.Types.Double) ->
                 GHC.Types.:
                   @ GHC.Types.Double
                   x1
                   (GHC.Types.[] @ GHC.Types.Double)) -}
05f701be8b5f81a78bba5c696ab2c21e
  qrDecompose'_$srMatrixUpperTri ::
    [[[GHC.Types.Double]]]
    -> [[[GHC.Types.Double]]] -> [[GHC.Types.Double]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (ex :: [[[GHC.Types.Double]]])
                   (vx :: [[[GHC.Types.Double]]]) ->
                 case GHC.List.$wlenAcc
                        @ [[GHC.Types.Double]]
                        ex
                        0# of ww2 { DEFAULT ->
                 AronModule.qrDecompose'_go2
                   (GHC.List.reverse1
                      @ GHC.Types.Int
                      (GHC.Enum.eftInt 1# ww2)
                      (GHC.Types.[] @ GHC.Types.Int))
                   ex
                   (case GHC.List.$wlenAcc
                           @ [[GHC.Types.Double]]
                           vx
                           0# of ww1 { DEFAULT ->
                    let {
                      y1 :: GHC.Prim.Int# = GHC.Prim.-# ww1 1#
                    } in
                    case GHC.Prim.># 0# y1 of lwild {
                      DEFAULT
                      -> letrec {
                           go29 :: GHC.Prim.Int# -> [[[[GHC.Types.Double]]]]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ (x1 :: GHC.Prim.Int#) ->
                             GHC.Types.:
                               @ [[[GHC.Types.Double]]]
                               (case GHC.Prim.<=# x1 0# of lwild1 {
                                  DEFAULT -> AronModule.$wunsafeDrop @ [[GHC.Types.Double]] x1 vx
                                  1# -> vx })
                               (case GHC.Prim.==# x1 y1 of lwild1 {
                                  DEFAULT -> go29 (GHC.Prim.+# x1 1#)
                                  1# -> GHC.Types.[] @ [[[GHC.Types.Double]]] })
                         } in
                         go29 0#
                      1# -> GHC.Types.[] @ [[[GHC.Types.Double]]] } }) }) -}
323a56b530f46da037a40a190880bd12
  qrDecompose'_$srejection ::
    [[[GHC.Types.Double]]]
    -> [[[GHC.Types.Double]]] -> [[[GHC.Types.Double]]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
0574808db9019935d08d2862e62a4612
  qrDecompose'_go ::
    GHC.Prim.Int# -> [[GHC.Types.Double]] -> [[GHC.Types.Double]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
e2b1d150bcfddfbed564c83737ad2f84
  qrDecompose'_go1 :: [[GHC.Types.Double]] -> [GHC.Types.Double]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
558f1b2b28def65e9c96eb5664383446
  qrDecompose'_go2 ::
    [GHC.Types.Int]
    -> [[[GHC.Types.Double]]]
    -> [[[[GHC.Types.Double]]]]
    -> [[GHC.Types.Double]]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,1*U> -}
0b868a09232269d0759fe6b5f39cf58b
  quickSort :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U> -}
e8d79ff46a8b0cc33dac2f325cb1a43b
  quickSort' :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
cd5cd10825bb35358d064ced02815094
  quickSort1 :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,C(C1(U)),A,A)><S,1*U> -}
7426b14912b6bff6c5c98eccb2b9ab8d
  quickSortAny :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,C(C1(U)),A,A)><S,1*U>,
     Unfolding: (AronModule.quickSort1) -}
5ce3d918241b2812406e6ee33c2f0cb1
  rMatrixUpperTri :: GHC.Num.Num c => [[[c]]] -> [[[c]]] -> [[c]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,U><L,U> -}
38b3c9d07a370a7c88032bbd1098913e
  rToRatMat :: GHC.Real.Real a => [[a]] -> [[GHC.Real.Rational]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,A,1*C(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 ($dReal :: GHC.Real.Real a1) (eta :: [[a1]]) ->
                 GHC.Base.build
                   @ [GHC.Real.Rational]
                   (\ @ b1
                      (c1 :: [GHC.Real.Rational] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [a1]
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Real.Rational]
                         @ b1
                         @ [a1]
                         c1
                         (GHC.Base.map
                            @ a1
                            @ GHC.Real.Rational
                            (GHC.Real.toRational @ a1 $dReal)))
                      n
                      eta)) -}
e9d8ec135f30057bcc8022dc0c58b46d
  radianToDegree :: GHC.Types.Float -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: GHC.Types.Float) ->
                 case x1 of wild { GHC.Types.F# x2 ->
                 GHC.Types.F# (GHC.Prim.timesFloat# x2 57.295776#) }) -}
99b97758712c8aef6495b051989c95c3
  randomDouble :: GHC.Types.Int -> GHC.Types.IO [GHC.Types.Double]
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.randomDouble1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Types.Double]>_R)) -}
5f70310aaf6c377172d6e70cfe977537
  randomDouble1 ::
    GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Double] #)
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 AronModule.$wrandomDouble ww1 w1 }) -}
6438e0006985486f2280ce569069e887
  randomFloat :: GHC.Types.Int -> GHC.Types.IO [GHC.Types.Float]
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.randomFloat1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Types.Float]>_R)) -}
658dee9622075bcc1d39d5fd1d9c47d1
  randomFloat1 ::
    GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Float] #)
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 AronModule.$wrandomFloat ww1 w1 }) -}
9a5028e7d01860f18364a3c7a2c339d8
  randomFrac ::
    GHC.Real.Fractional a => GHC.Types.Int -> GHC.Types.IO [a]
  {- Arity: 3, Strictness: <L,U(A,A,A,C(U))><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.randomFrac1
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Real.Fractional a1>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[a1]>_R)) -}
909f548d80332e8f56abf861883ea161
  randomFrac1 ::
    GHC.Real.Fractional a =>
    GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
  {- Arity: 3, Strictness: <L,U(A,A,A,C(U))><S(S),1*U(U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: GHC.Real.Fractional a1)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 AronModule.$wrandomFrac @ a1 w ww1 w2 }) -}
cab3f8719a6c3c1280a744f8011119e9
  randomFrac2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (100) -}
71782b71fedad342b5e4aef56145ab79
  randomList ::
    GHC.Types.Int -> GHC.Types.IO [GHC.Integer.Type.Integer]
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.randomList1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Integer.Type.Integer]>_R)) -}
ff43ff28ffcee3a79269c28e8ce0bea7
  randomList1 ::
    GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [GHC.Integer.Type.Integer] #)
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 AronModule.$wrandomList ww1 w1 }) -}
883d55a1e5320112affe49d4f1106ab0
  randomMatrix ::
    GHC.Num.Num a =>
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO [[a]]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(1*U)><L,1*U(1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.randomMatrix1
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[[a1]]>_R)) -}
fec115d1d098e1bd1505db68e34efe0f
  randomMatrix1 ::
    GHC.Num.Num a =>
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [[a]] #)
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(1*U)><L,1*U(1*U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ @ a1
                   (w :: GHC.Num.Num a1)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 AronModule.$wrandomMatrix @ a1 w ww1 w2 w3 }) -}
d9c9de2b59008ff3b2ea1e52784e13ab
  ratToInt :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 let {
                   xs :: [GHC.Integer.Type.Integer] = AronModule.splitR s
                 } in
                 let {
                   exit9 :: GHC.Integer.Type.Integer -> GHC.Base.String
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (eta :: GHC.Integer.Type.Integer)[OneShot] ->
                     case GHC.Integer.Type.eqInteger# eta AronModule.df3 of wild {
                       DEFAULT -> s
                       1#
                       -> case xs of wild1 {
                            [] -> case GHC.List.badHead ret_ty GHC.Base.String of {}
                            : x1 ds1
                            -> case GHC.Show.$w$cshowsPrec4
                                      0#
                                      x1
                                      (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                               GHC.Types.: @ GHC.Types.Char ww3 ww4 } } }
                 } in
                 letrec {
                   go29 :: [GHC.Integer.Type.Integer]
                           -> GHC.Integer.Type.Integer -> GHC.Base.String
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [GHC.Integer.Type.Integer])
                       (eta :: GHC.Integer.Type.Integer) ->
                     case ds of wild { [] -> exit9 eta : y1 ys -> go29 ys y1 }
                 } in
                 go29 xs (GHC.List.lastError @ GHC.Integer.Type.Integer)) -}
71a3410efbdd928b08988402c0b5a199
  re :: AronModule.C -> GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C x1 ds1 -> x1 }) -}
3b9225a816d93fc97ab1aaac8d528170
  readConfig ::
    GHC.IO.FilePath
    -> GHC.Types.IO
         (Data.HashMap.Base.HashMap
            GHC.Base.String
            (Data.HashMap.Base.HashMap GHC.Base.String GHC.Base.String))
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.readConfig1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.HashMap.Base.HashMap
                                  GHC.Base.String
                                  (Data.HashMap.Base.HashMap
                                     GHC.Base.String GHC.Base.String)>_R)) -}
2eabb0ccb0ede03faa70cc3117584d0b
  readConfig1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.HashMap.Base.HashMap
            GHC.Base.String
            (Data.HashMap.Base.HashMap GHC.Base.String GHC.Base.String) #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        p1
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.hSetEncoding1
                        ipv1
                        GHC.IO.Encoding.Latin1.latin1_checked
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4,
                    AronModule.readConfig_go
                      (Data.List.Split.Internals.splitWhen
                         @ GHC.Base.String
                         AronModule.readConfig2
                         (Data.OldList.lines ipv5))
                      (Data.HashMap.Base.Empty
                         @ GHC.Base.String
                         @ (Data.HashMap.Base.HashMap
                              GHC.Base.String GHC.Base.String)) #) } } }) -}
bd22ebc93e7d09767f7227a27636a018
  readConfig2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
96762436066aae1b6fa955d72b7fb60e
  readConfig_go ::
    [[GHC.Base.String]]
    -> Data.HashMap.Base.HashMap
         GHC.Base.String
         (Data.HashMap.Base.HashMap GHC.Base.String GHC.Base.String)
    -> Data.HashMap.Base.HashMap
         GHC.Base.String
         (Data.HashMap.Base.HashMap GHC.Base.String GHC.Base.String)
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
40abde09a648d7f98e7109bc93843e08
  readFileLatin1 :: GHC.IO.FilePath -> GHC.Types.IO GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.readFileLatin2
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
ca2d7993218415fbe7a2e027c97ae449
  readFileLatin1ToList ::
    GHC.IO.FilePath -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.readFileLatin1ToList1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
13de5cdbdbe877249d0ae6f19ac5567d
  readFileLatin1ToList1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        p1
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.hSetEncoding1
                        ipv1
                        GHC.IO.Encoding.Latin1.latin1_checked
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4, Data.OldList.lines ipv5 #) } } }) -}
d6ad7b47a173c915c78447586574cd8e
  readFileLatin2 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        p1
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.hSetEncoding1
                        ipv1
                        GHC.IO.Encoding.Latin1.latin1_checked
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hGetContents1 ipv1 ipv2 } }) -}
d012bba99c91599040c1d4f3b7064c47
  readFileRemote ::
    GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.readFileRemote1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
d892e49d7bebd34d74eaa1e0fafe08ea
  readFileRemote1 ::
    GHC.IO.FilePath
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (url :: GHC.IO.FilePath)
                   (fn :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Network.HTTP.Conduit.$wsimpleHttp
                         @ GHC.Types.IO
                         (\ @ a1 -> GHC.Base.id @ (GHC.Types.IO a1))
                         url)
                        `cast`
                      (GHC.Types.N:IO[0] <Data.ByteString.Lazy.Internal.ByteString>_R)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 Data.ByteString.Lazy.writeFile1 fn ipv1 ipv }) -}
7ed19e4a19934328a257849578c1415a
  readFileRemoteToList ::
    GHC.IO.FilePath
    -> GHC.Types.IO Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (url :: GHC.IO.FilePath) ->
                 Network.HTTP.Conduit.$wsimpleHttp
                   @ GHC.Types.IO
                   (\ @ a1 -> GHC.Base.id @ (GHC.Types.IO a1))
                   url) -}
641d0ee0c69b95938665a10676b86d26
  readFileToList :: GHC.IO.FilePath -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.readFileToList1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
fdcc37c2a6dd0fb13acdffbb7dbbce0a
  readFileToList1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Base.String] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: GHC.IO.FilePath)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        x1
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 (# ipv2, Data.OldList.lines ipv3 #) } }) -}
aa4a3ff4599f79ad23acafd9eebc746f
  readSnippet ::
    GHC.IO.FilePath
    -> GHC.Types.IO [([GHC.Base.String], [GHC.Base.String])]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.readSnippet1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <[([GHC.Base.String], [GHC.Base.String])]>_R)) -}
5a12c6f44281aefdca881ad2b03228cc
  readSnippet1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [([GHC.Base.String], [GHC.Base.String])] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (path :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        path
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.hSetEncoding1
                        ipv1
                        GHC.IO.Encoding.Latin1.latin1_checked
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 (# ipv4,
                    AronModule.readSnippet_go
                      (Data.List.Split.Internals.splitWhen
                         @ GHC.Base.String
                         AronModule.readSnippet2
                         (Data.OldList.lines ipv5)) #) } } }) -}
32d6020e8b6c6da1871645e9950d502f
  readSnippet2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
0b0248e91eb1b7eb57d1a420f0e552a9
  readSnippet_go ::
    [[GHC.Base.String]] -> [([GHC.Base.String], [GHC.Base.String])]
  {- Arity: 1, Strictness: <S,1*U> -}
aaee7cfdaf3717415b3e33c09e406bd5
  redisExtractAronModule ::
    [GHC.Base.String]
    -> [([GHC.Base.String], GHC.Integer.Type.Integer,
         [GHC.Base.String])]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) ->
                 case ds of wild {
                   []
                   -> GHC.Types.[]
                        @ ([GHC.Base.String], GHC.Integer.Type.Integer, [GHC.Base.String])
                   : ipv ipv1
                   -> AronModule.redisExtractAronModule_go1
                        AronModule.redisExtractAronModule1
                        (AronModule.redisExtractAronModule_go wild) }) -}
90838a996c529c0980aaaa232462e985
  redisExtractAronModule1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (30000) -}
496c5dcee66b5e5b034bdf32060b1bd7
  redisExtractAronModule_go ::
    [[GHC.Types.Char]] -> [(GHC.Base.String, GHC.Base.String)]
  {- Arity: 1, Strictness: <S,1*U> -}
7a18eecb9f909eb8d8a484c73923b664
  redisExtractAronModule_go1 ::
    GHC.Integer.Type.Integer
    -> [(GHC.Base.String, GHC.Base.String)]
    -> [([[GHC.Types.Char]], GHC.Integer.Type.Integer,
         [GHC.Base.String])]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
cd47af8b59cc4c2197dd563b40a8e557
  redisExtractJavaMethod ::
    [GHC.Base.String]
    -> [([GHC.Base.String], GHC.Integer.Type.Integer,
         [GHC.Base.String])]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) ->
                 case ds of wild {
                   []
                   -> GHC.Types.[]
                        @ ([GHC.Base.String], GHC.Integer.Type.Integer, [GHC.Base.String])
                   : ipv ipv1
                   -> AronModule.redisExtractJavaMethod_go
                        AronModule.redisExtractJavaMethod4
                        (GHC.List.filter
                           @ [GHC.Types.Char]
                           AronModule.redisExtractJavaMethod1
                           wild) }) -}
fbbbf90902ebf9824bda0f530263fb44
  redisExtractJavaMethod1 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (e :: GHC.Base.String) ->
                 Text.Regex.Posix.String.$fRegexLikeRegex[]_$cmatchTest
                   AronModule.redisExtractJavaMethod2
                   e) -}
80f04519e655e56ab1c9a4fcc5aa2c7c
  redisExtractJavaMethod2 :: Text.Regex.Posix.Wrap.Regex
  {- Unfolding: (Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                   Text.Regex.mkRegex1
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                   Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                   (GHC.CString.unpackCString# AronModule.redisExtractJavaMethod3)) -}
300703b06e896a595fa8f081fe381541
  redisExtractJavaMethod3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("public static"#) -}
ddc27ae68bcb726be00198515b0ffd99
  redisExtractJavaMethod4 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (10000) -}
d623935741fb8eea6fb0337ee2f8f7a2
  redisExtractJavaMethod_go ::
    GHC.Integer.Type.Integer
    -> [[GHC.Types.Char]]
    -> [([[GHC.Types.Char]], GHC.Integer.Type.Integer,
         [[GHC.Types.Char]])]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
d2afb01864f346eca19f64fb5438bbb6
  reduce :: [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (cx :: [GHC.Integer.Type.Integer]) ->
                 let {
                   d1 :: GHC.Integer.Type.Integer
                   = case cx of wild {
                       [] -> case GHC.List.badHead ret_ty GHC.Integer.Type.Integer of {}
                       : x1 ds1
                       -> let {
                            exit9 :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
                              <join 1> {- Arity: 1, Strictness: <S,U> -}
                            = \ (eta :: GHC.Integer.Type.Integer)[OneShot] ->
                              GHC.Integer.Type.gcdInteger x1 eta
                          } in
                          letrec {
                            go29 :: [GHC.Integer.Type.Integer]
                                    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
                              <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                            = \ (ds :: [GHC.Integer.Type.Integer])
                                (eta :: GHC.Integer.Type.Integer) ->
                              case ds of wild1 { [] -> exit9 eta : y1 ys -> go29 ys y1 }
                          } in
                          go29 wild (GHC.List.lastError @ GHC.Integer.Type.Integer) }
                 } in
                 GHC.Base.map
                   @ GHC.Integer.Type.Integer
                   @ GHC.Integer.Type.Integer
                   (\ (x1 :: GHC.Integer.Type.Integer) ->
                    GHC.Real.$fIntegralInteger_$cquot x1 d1)
                   cx) -}
5e90674a590da86a7562b3ee616eb0d4
  reduceForm :: [[GHC.Base.String]] -> [[GHC.Base.String]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (m :: [[GHC.Base.String]]) ->
                 GHC.Base.build
                   @ [GHC.Base.String]
                   (\ @ b1
                      (c1 :: [GHC.Base.String] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Base.String]
                         @ b1
                         @ [GHC.Base.String]
                         c1
                         AronModule.reduceForm1)
                      n
                      m)) -}
37602910163cc5d898c711849468e2dc
  reduceForm1 :: [GHC.Base.String] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (r :: [GHC.Base.String]) ->
                 GHC.Base.build
                   @ [GHC.Types.Char]
                   (\ @ b1
                      (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Types.Char]
                         @ b1
                         @ [GHC.Types.Char]
                         c1
                         AronModule.reduceForm2)
                      n
                      r)) -}
73c49d580a1a30cdf1fb081540188670
  reduceForm2 :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: GHC.Base.String) ->
                 AronModule.ratToInt (AronModule.normalR x1)) -}
18b8057d26c02ab0fb83377f5323ffe3
  rejection :: GHC.Real.Fractional a => [[[a]]] -> [[[a]]] -> [[[a]]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U><S,1*U> -}
1afbcc4117a78f0ee31489c3d29b75f7
  removeIndex :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a1 (ds :: GHC.Types.Int) (ds1 :: [a1]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> case ds of wild1 { GHC.Types.I# x1 ->
                      let {
                        n :: [a1]
                        = case GHC.Prim.<=# x1 0# of lwild {
                            DEFAULT
                            -> case x1 of ds2 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ a1
                                           ipv1
                                           (GHC.Prim.-# ds2 1#) of ww { (#,#) ww1 ww2 ->
                                    case ww2 of wild2 {
                                      [] -> GHC.List.scanl2 @ a1 : ds3 xs -> xs } }
                                 1#
                                 -> case ipv1 of wild2 {
                                      [] -> GHC.List.scanl2 @ a1 : ds3 xs -> xs } }
                            1# -> ipv1 }
                      } in
                      case GHC.Prim.<=# x1 0# of lwild {
                        DEFAULT
                        -> case x1 of ds2 {
                             DEFAULT
                             -> GHC.Base.++_$s++
                                  @ a1
                                  n
                                  ipv
                                  (case GHC.List.splitAt_$s$wsplitAt'
                                          @ a1
                                          ipv1
                                          (GHC.Prim.-# ds2 1#) of ww { (#,#) ww1 ww2 ->
                                   ww1 })
                             1# -> GHC.Types.: @ a1 ipv n }
                        1# -> n } } }) -}
91b75fa0d09c162e9f1e8b82c47c1489
  removeRowCol ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> [[a]] -> [[a]]
  {- Arity: 3, Strictness: <L,1*U><L,1*U><S,1*U>,
     Unfolding: (\ @ a1
                   (ds :: GHC.Integer.Type.Integer)
                   (ds1 :: GHC.Integer.Type.Integer)
                   (ds2 :: [[a1]]) ->
                 case ds2 of wild {
                   [] -> GHC.Types.[] @ [a1]
                   : ipv ipv1
                   -> Data.OldList.transpose
                        @ a1
                        (AronModule.removeIndex
                           @ [a1]
                           (case GHC.Integer.Type.integerToInt ds1 of wild1 { DEFAULT ->
                            GHC.Types.I# wild1 })
                           (Data.OldList.transpose
                              @ a1
                              (AronModule.removeIndex
                                 @ [a1]
                                 (case GHC.Integer.Type.integerToInt ds of wild1 { DEFAULT ->
                                  GHC.Types.I# wild1 })
                                 wild))) }) -}
4478b5166c2dc77b6f6bdbda16eb323c
  removeSpace :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 GHC.Base.build
                   @ GHC.Types.Char
                   (\ @ b1
                      (c1 :: GHC.Types.Char -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b1
                      (GHC.List.filterFB
                         @ GHC.Types.Char
                         @ b1
                         c1
                         AronModule.removeSpace1)
                      n
                      s)) -}
5e9afe1bce743a618d115b39d6019cd0
  removeSpace1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Char) ->
                 case w of ww { GHC.Types.C# ww1 -> AronModule.$wlvl ww1 }) -}
7b6af6a9ae634f924772ac581f14b1f1
  rename :: GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.mv1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
070ec52aa47a416b26c1f16b3b0a9f55
  renameAllFile ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.mvFiles1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
ccbdfab8e5088ad2d5f29a299377297b
  rep2d ::
    (GHC.Real.Integral n1, GHC.Real.Integral n2) =>
    [[a]] -> n1 -> n2 -> a -> [[a]]
  {- Arity: 6,
     Strictness: <S(LLLLLLLLC(S)),1*U(A,A,A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: InlineRule (6, True, False)
                (\ @ n
                   @ n1
                   @ a1
                   (w :: GHC.Real.Integral n)
                   (w1 :: GHC.Real.Integral n1)
                   (w2 :: [[a1]])
                   (w3 :: n)
                   (w4 :: n1)
                   (w5 :: a1) ->
                 case w of ww { GHC.Real.C:Integral ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 AronModule.$wrep2d @ n @ n1 @ a1 ww9 w1 w2 w3 w4 w5 }) -}
bf0352d2b5eeb5dbdad7f0e24b6c1fee
  rep2d_$srep2d ::
    [[a]]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> a
    -> [[a]]
  {- Arity: 4, Strictness: <L,U><S,1*U><L,1*U><L,U> -}
66449cd71229f9cf5475ec1a82004a13
  repeat' :: GHC.Integer.Type.Integer -> a -> [a]
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (AronModule.repeatN) -}
7b58e041aacebf52361d9ad04fcceb3c
  repeatN :: GHC.Integer.Type.Integer -> a -> [a]
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ @ a1 (n :: GHC.Integer.Type.Integer) (a2 :: a1) ->
                 letrec {
                   go29 :: GHC.Integer.Type.Integer -> [a1]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Integer.Type.Integer) ->
                     case GHC.Integer.Type.gtInteger# x1 n of wild {
                       DEFAULT
                       -> GHC.Types.:
                            @ a1
                            a2
                            (go29 (GHC.Integer.Type.plusInteger x1 AronModule.df3))
                       1# -> GHC.Types.[] @ a1 }
                 } in
                 go29 AronModule.df3) -}
6b909c3a352f99d9735318918ea2b9cd
  replaceList ::
    [GHC.Base.String]
    -> GHC.Base.String -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
e19dab9aa8c79c96907f311db16e2804
  replicate' :: GHC.Types.Int -> a -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (w :: GHC.Types.Int) (w1 :: a1) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 AronModule.$wreplicate' @ a1 ww1 w1 }) -}
f9341808bac3b0c4db252d800a1157c1
  reverseWord :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
9b50b401b6d051997e23c84d6758277a
  rf :: (GHC.Real.Real a, GHC.Real.Fractional b) => a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(U))><S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True) GHC.Real.realToFrac -}
c73662a708a5351df3f1f949829b9430
  rightDiagonal ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer]
  {- Arity: 3, Strictness: <S,U><S,1*U><L,1*U>,
     Unfolding: (\ (s :: [[GHC.Integer.Type.Integer]])
                   (c1 :: GHC.Integer.Type.Integer)
                   (r :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.integerToInt c1 of wild { DEFAULT ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Integer.Type.Integer]
                        s
                        0# of ww2 { DEFAULT ->
                 let {
                   r' :: GHC.Types.Int
                   = case GHC.Integer.Type.integerToInt r of wild1 { DEFAULT ->
                     GHC.Types.I# wild1 }
                 } in
                 letrec {
                   $wdown :: [[GHC.Integer.Type.Integer]]
                             -> GHC.Prim.Int# -> GHC.Types.Int -> [GHC.Integer.Type.Integer]
                     {- Arity: 3, Strictness: <L,U><S,U><L,1*U(U)>, Inline: [2] -}
                   = \ (w :: [[GHC.Integer.Type.Integer]])
                       (ww :: GHC.Prim.Int#)
                       (w1 :: GHC.Types.Int) ->
                     case GHC.Prim.<# ww ww2 of lwild {
                       DEFAULT -> GHC.Types.[] @ GHC.Integer.Type.Integer
                       1#
                       -> case w1 of wild1 { GHC.Types.I# x1 ->
                          case GHC.Prim.<# x1 ww2 of lwild1 {
                            DEFAULT -> GHC.Types.[] @ GHC.Integer.Type.Integer
                            1#
                            -> GHC.Types.:
                                 @ GHC.Integer.Type.Integer
                                 (GHC.List.$w!!
                                    @ GHC.Integer.Type.Integer
                                    (GHC.List.$w!! @ [GHC.Integer.Type.Integer] w ww)
                                    x1)
                                 ($wdown
                                    w
                                    (GHC.Prim.+# ww 1#)
                                    (GHC.Types.I# (GHC.Prim.+# x1 1#))) } } }
                 } in
                 GHC.Base.++
                   @ GHC.Integer.Type.Integer
                   ($wdown
                      s
                      (GHC.Prim.+# wild 1#)
                      (case r' of wild1 { GHC.Types.I# x1 ->
                       GHC.Types.I# (GHC.Prim.+# x1 1#) }))
                   (GHC.Types.:
                      @ GHC.Integer.Type.Integer
                      (case r' of ww { GHC.Types.I# ww1 ->
                       GHC.List.$w!!
                         @ GHC.Integer.Type.Integer
                         (GHC.List.$w!! @ [GHC.Integer.Type.Integer] s wild)
                         ww1 })
                      (AronModule.$wup
                         s
                         (GHC.Prim.-# wild 1#)
                         (case r' of wild1 { GHC.Types.I# x1 ->
                          GHC.Types.I# (GHC.Prim.-# x1 1#) }))) } }) -}
f0d7d4b3c0ab881ef831a0da32a19d48
  rm :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.compileHaskellToBin11
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
23082f5110df5ca72027d832e6874456
  rmDir :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Directory.removeDirectoryRecursive1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
6b4ba441c479b3490c5289d9239367bc
  rootList ::
    (GHC.Types.Double -> GHC.Types.Double)
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Integer.Type.Integer
    -> [GHC.Maybe.Maybe GHC.Types.Double]
  {- Arity: 5,
     Strictness: <L,C(U(U))><L,U(U)><L,U(U)><L,U(U)><L,1*U>,
     Unfolding: (\ (f :: GHC.Types.Double -> GHC.Types.Double)
                   (x0 :: GHC.Types.Double)
                   (x1 :: GHC.Types.Double)
                   ( :: GHC.Types.Double)
                   (n :: GHC.Integer.Type.Integer) ->
                 let {
                   n' :: GHC.Types.Double
                   = case GHC.Integer.Type.doubleFromInteger n of wild { DEFAULT ->
                     GHC.Types.D# wild }
                 } in
                 let {
                   delt :: GHC.Types.Double
                   = case x1 of wild { GHC.Types.D# x2 ->
                     case x0 of wild1 { GHC.Types.D# y1 ->
                     case n' of wild2 { GHC.Types.D# y2 ->
                     case GHC.Prim./##
                            (GHC.Prim.fabsDouble# (GHC.Prim.-## x2 y1))
                            y2 of wild3 { DEFAULT ->
                     GHC.Types.D# wild3 } } } }
                 } in
                 case GHC.Base.map
                        @ GHC.Types.Double
                        @ GHC.Types.Double
                        (\ (k :: GHC.Types.Double) ->
                         case delt of wild { GHC.Types.D# x2 ->
                         case k of wild1 { GHC.Types.D# y1 ->
                         case x0 of wild2 { GHC.Types.D# y2 ->
                         GHC.Types.D# (GHC.Prim.+## (GHC.Prim.*## x2 y1) y2) } } })
                        (GHC.Float.$w$cenumFromTo 0.0## n') of wild {
                   []
                   -> case GHC.List.init2
                      ret_ty [GHC.Maybe.Maybe GHC.Types.Double]
                      of {}
                   : x2 xs
                   -> let {
                        z2 :: [GHC.Maybe.Maybe GHC.Types.Double]
                        = case  of ww { GHC.Types.D# ww1 ->
                          case AronModule.$woneRoot f x1 x1 ww1 of wild1 {
                            GHC.Maybe.Nothing
                            -> GHC.Types.[] @ (GHC.Maybe.Maybe GHC.Types.Double)
                            GHC.Maybe.Just ipv
                            -> GHC.Types.:
                                 @ (GHC.Maybe.Maybe GHC.Types.Double)
                                 wild1
                                 (GHC.Types.[] @ (GHC.Maybe.Maybe GHC.Types.Double)) } }
                      } in
                      letrec {
                        go29 :: [GHC.Types.Double]
                                -> [GHC.Types.Double] -> [GHC.Maybe.Maybe GHC.Types.Double]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                        = \ (ds :: [GHC.Types.Double]) (_ys :: [GHC.Types.Double]) ->
                          case ds of wild1 {
                            [] -> z2
                            : ipv ipv1
                            -> case _ys of wild2 {
                                 [] -> z2
                                 : ipv2 ipv3
                                 -> case  of ww { GHC.Types.D# ww1 ->
                                    case AronModule.$woneRoot f ipv ipv2 ww1 of wild3 {
                                      GHC.Maybe.Nothing -> go29 ipv1 ipv3
                                      GHC.Maybe.Just ipv4
                                      -> GHC.Types.:
                                           @ (GHC.Maybe.Maybe GHC.Types.Double)
                                           wild3
                                           (go29 ipv1 ipv3) } } } }
                      } in
                      go29 (GHC.List.init1 @ GHC.Types.Double x2 xs) xs }) -}
f4a0ba8ec0b37dbf7330a8562ee9791b
  run :: GHC.Base.String -> GHC.Types.IO [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.compileHaskellToBin8
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Base.String]>_R)) -}
c56f4b81a34e47b2b6a103d040db4a66
  run' :: GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.run'1
                  `cast`
                (<GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
1a2b40cc748234675f97638081ecaf2c
  run'1 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (s :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Process.createProcess1
                        (System.Process.Common.CreateProcess
                           (System.Process.Common.RawCommand
                              s
                              (GHC.Types.[] @ GHC.Base.String))
                           (GHC.Maybe.Nothing @ GHC.IO.FilePath)
                           (GHC.Maybe.Nothing @ [(GHC.Base.String, GHC.Base.String)])
                           System.Process.Common.Inherit
                           System.Process.Common.Inherit
                           System.Process.Common.Inherit
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Maybe.Nothing @ System.Posix.Types.GroupID)
                           (GHC.Maybe.Nothing @ System.Posix.Types.UserID)
                           GHC.Types.False)
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
8998ab57312cc89388c9dba36a05e819
  rw :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) AronModule.reverseWord -}
10b0081df93d2ed211027383debbe23d
  scaleList :: GHC.Num.Num a => a -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1 ($dNum :: GHC.Num.Num a1) (ds :: a1) (ds1 :: [a1]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ a1
                   : ipv ipv1
                   -> GHC.Base.build
                        @ a1
                        (\ @ b1 (c1 :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ a1
                           @ b1
                           (GHC.Base.mapFB
                              @ a1
                              @ b1
                              @ a1
                              c1
                              (\ (x1 :: a1) -> GHC.Num.* @ a1 $dNum ds x1))
                           n
                           wild) }) -}
c8ef524dd5d3478d2d47ae0463d65fe0
  searchReplace ::
    GHC.Base.String
    -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
061b19ba1451478860caa0893daa2b1f
  sentence :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ea2eef6cf1ea0ff4bcf6bf6a6f01a1bc
  sfilter ::
    GHC.Base.String -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) (l :: [GHC.Base.String]) ->
                 GHC.List.filter
                   @ [GHC.Types.Char]
                   (let {
                      w :: Text.Regex.Posix.Wrap.Regex
                      = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                          Text.Regex.mkRegex1
                            `cast`
                          (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                          Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                            `cast`
                          (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                          s
                    } in
                    \ (w1 :: GHC.Base.String) ->
                    case w of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                    Text.Regex.Posix.String.$w$cmatchTest ww1 ww3 w1 })
                   l) -}
56fa14d34424f21d72af0066837f840c
  sleep :: GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Conc.IO.threadDelay1
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
f98b94eccfcf0f07fb6271f38ce07e43
  sleepSec :: GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.sleepSec1
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
5c781f644fd47c8541db8465b81c0bf1
  sleepSec1 ::
    GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: (\ (n :: GHC.Types.Int)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case {__pkg_ccall base-4.12.0.0 GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       GHC.Prim.Int# #)}
                        GHC.Prim.realWorld# of wild { (#,#) ds ds1 ->
                 case ds1 of wild1 {
                   DEFAULT
                   -> GHC.Event.Thread.threadDelay1
                        (case n of wild2 { GHC.Types.I# x1 ->
                         GHC.Types.I# (GHC.Prim.*# x1 1000000#) })
                        eta
                   0#
                   -> case n of wild2 { GHC.Types.I# x1 ->
                      case GHC.Prim.delay#
                             @ GHC.Prim.RealWorld
                             (GHC.Prim.*# x1 1000000#)
                             eta of s' { DEFAULT ->
                      (# s', GHC.Tuple.() #) } } } }) -}
fa15d43dc1344b796c193cdf4bac26b3
  sort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a1 ($dOrd :: GHC.Classes.Ord a1) (ds :: [a1]) ->
                 case ds of wild {
                   [] -> AronModule.sort1 @ a1
                   : x1 xs
                   -> letrec {
                        go29 :: [a1] -> [a1] {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [a1]) ->
                          case ds1 of wild1 {
                            [] -> GHC.Types.[] @ a1
                            : y1 ys
                            -> case GHC.Classes.< @ a1 $dOrd y1 x1 of wild2 {
                                 GHC.Types.False -> go29 ys
                                 GHC.Types.True -> GHC.Types.: @ a1 y1 (go29 ys) } }
                      } in
                      GHC.Base.++
                        @ a1
                        (AronModule.qqsort
                           @ a1
                           (\ (x2 :: a1) (y1 :: a1)[OneShot] ->
                            GHC.Classes.< @ a1 $dOrd x2 y1)
                           (go29 xs))
                        (GHC.Types.:
                           @ a1
                           x1
                           (letrec {
                              go30 :: [a1] -> [a1] {- Arity: 1, Strictness: <S,1*U> -}
                              = \ (ds1 :: [a1]) ->
                                case ds1 of wild1 {
                                  [] -> GHC.Types.[] @ a1
                                  : y1 ys
                                  -> case GHC.Classes.< @ a1 $dOrd y1 x1 of wild2 {
                                       GHC.Types.False -> GHC.Types.: @ a1 y1 (go30 ys)
                                       GHC.Types.True -> go30 ys } }
                            } in
                            AronModule.qqsort
                              @ a1
                              (\ (x2 :: a1) (y1 :: a1)[OneShot] ->
                               GHC.Classes.< @ a1 $dOrd x2 y1)
                              (go30 xs))) }) -}
ff07531943de65a630c2954236787e7d
  sort1 :: [a]
  {- Strictness: x -}
15b253958007f192f877608b3fab2b21
  sortRow ::
    [[GHC.Integer.Type.Integer]] -> [[GHC.Integer.Type.Integer]]
  {- Arity: 1, Strictness: <S,1*U> -}
552d9ca1999de2c51798ad3807894ce6
  splitBS ::
    GHC.Word.Word8
    -> Data.ByteString.Internal.ByteString
    -> [Data.ByteString.Internal.ByteString]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(U)><S(LLLS),1*U(U,U,U,U)>,
     Unfolding: InlineRule (0, True, True) Data.ByteString.split -}
5e4e5a98e6afcf8ecf8a42181c8ad753
  splitBlock ::
    [GHC.Base.String] -> GHC.Base.String -> [[GHC.Base.String]]
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [GHC.Base.String]) (ds1 :: GHC.Base.String) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ [GHC.Base.String]
                   : ipv ipv1
                   -> let {
                        lvl264 :: Text.Regex.Posix.Wrap.Regex
                        = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                            Text.Regex.mkRegex1
                              `cast`
                            (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                            Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                              `cast`
                            (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                            ds1
                      } in
                      Data.List.Split.Internals.splitWhen
                        @ GHC.Base.String
                        (\ (x1 :: GHC.Base.String) ->
                         Text.Regex.Posix.String.$fRegexLikeRegex[]_$cmatchTest lvl264 x1)
                        wild }) -}
c577b1c8ab7e939f44bc404f1ab6727c
  splitList ::
    [GHC.Base.String] -> ([GHC.Base.String], [GHC.Base.String])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Base.String]) ->
                 case AronModule.$wsplitList w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
ba2f19132374821ed16ca280d7f19ac7
  splitListEmptyLine :: [GHC.Base.String] -> [[GHC.Base.String]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (xs :: [GHC.Base.String]) ->
                 GHC.Base.build
                   @ [GHC.Base.String]
                   (\ @ b1
                      (c1 :: [GHC.Base.String] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.List.filterFB
                         @ [GHC.Base.String]
                         @ b1
                         c1
                         AronModule.splitListEmptyLine2)
                      n
                      (Data.List.Split.Internals.splitWhen
                         @ GHC.Base.String
                         AronModule.splitListEmptyLine1
                         xs))) -}
d6ae1a99b2b24ae81587eaa3df837c72
  splitListEmptyLine1 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (x1 :: GHC.Base.String) ->
                 case x1 of wild {
                   [] -> GHC.Types.True
                   : ipv ipv1
                   -> case AronModule.splitListEmptyLine_go
                             wild
                             AronModule.$fShowC6 of wild1 { GHC.Types.I# x2 ->
                      case x2 of wild2 {
                        DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } } }) -}
f05b9fe90f02bee2372811e7caf0ca1c
  splitListEmptyLine2 :: [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: [GHC.Base.String]) ->
                 case GHC.List.$wlenAcc @ [GHC.Types.Char] x1 0# of ww2 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># ww2 0#) }) -}
697e41cb3e61946a41d57b4e8b8864c4
  splitListEmptyLine_go ::
    [GHC.Types.Char] -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
489a5787248e2602e3a9aed7b9795ddd
  splitPathA :: GHC.IO.FilePath -> [GHC.IO.FilePath]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                System.FilePath.Posix.splitPath -}
d5c49c475762c01bedf941e795893427
  splitR :: GHC.Base.String -> [GHC.Integer.Type.Integer]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 let {
                   xs :: [GHC.Base.String]
                   = Text.Regex.splitRegex AronModule.splitR2 s
                 } in
                 case GHC.List.$wlenAcc @ [GHC.Types.Char] xs 0# of ww2 {
                   DEFAULT
                   -> let {
                        xx :: [GHC.Integer.Type.Integer]
                        = GHC.Base.map
                            @ [GHC.Types.Char]
                            @ GHC.Integer.Type.Integer
                            AronModule.stringToInt
                            xs
                      } in
                      let {
                        exit9 :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (eta :: GHC.Integer.Type.Integer)[OneShot] ->
                          case GHC.Integer.Type.eqInteger#
                                 eta
                                 AronModule.$fDnumDoubleInt1 of wild {
                            DEFAULT -> xx 1# -> AronModule.splitR1 }
                      } in
                      letrec {
                        go29 :: [GHC.Integer.Type.Integer]
                                -> GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                          <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                        = \ (ds :: [GHC.Integer.Type.Integer])
                            (eta :: GHC.Integer.Type.Integer) ->
                          case ds of wild { [] -> exit9 eta : y1 ys -> go29 ys y1 }
                      } in
                      go29 xx (GHC.List.lastError @ GHC.Integer.Type.Integer)
                   1#
                   -> let {
                        xx :: [GHC.Integer.Type.Integer] = AronModule.splitR_go xs
                      } in
                      let {
                        exit9 :: GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (eta :: GHC.Integer.Type.Integer)[OneShot] ->
                          case GHC.Integer.Type.eqInteger#
                                 eta
                                 AronModule.$fDnumDoubleInt1 of wild {
                            DEFAULT -> xx 1# -> AronModule.splitR1 }
                      } in
                      letrec {
                        go29 :: [GHC.Integer.Type.Integer]
                                -> GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
                          <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                        = \ (ds :: [GHC.Integer.Type.Integer])
                            (eta :: GHC.Integer.Type.Integer) ->
                          case ds of wild { [] -> exit9 eta : y1 ys -> go29 ys y1 }
                      } in
                      go29 xx (GHC.List.lastError @ GHC.Integer.Type.Integer) }) -}
103f81b482a24102530d1a85b4d1258a
  splitR1 :: [GHC.Integer.Type.Integer]
  {- Strictness: x -}
c38c1c631aae48d180f2bc56f7ba7c9d
  splitR2 :: Text.Regex.Posix.Wrap.Regex
  {- Unfolding: (Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                   Text.Regex.mkRegex1
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                   Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                     `cast`
                   (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                   (GHC.CString.unpackCString# AronModule.addR1)) -}
6d2129921c7b0730e0a8855a518b94b2
  splitR_go :: [[GHC.Types.Char]] -> [GHC.Integer.Type.Integer]
  {- Arity: 1, Strictness: <S,1*U>m2 -}
8a57a87065a7d003ad69e11057ff915b
  splitStr :: GHC.Base.String -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (r :: GHC.Base.String) (s :: GHC.Base.String) ->
                 Text.Regex.splitRegex
                   (Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                      Text.Regex.mkRegex1
                        `cast`
                      (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                      Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                        `cast`
                      (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                      r)
                   s) -}
cd934d88c10c2cf075add1f56d127bae
  splitStrChar ::
    GHC.Base.String -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (r :: GHC.Base.String) (s :: GHC.Base.String) ->
                 let {
                   rex :: Text.Regex.Posix.Wrap.Regex
                   = Text.Regex.Posix.String.$fRegexMakerRegexCompOptionExecOption[]_$cmakeRegexOpts
                       Text.Regex.mkRegex1
                         `cast`
                       (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:CompOption[0]))
                       Text.Regex.Posix.Wrap.$fRegexOptionsRegexCompOptionExecOption2
                         `cast`
                       (Sym (Foreign.C.Types.N:CInt[0]) ; Sym (Text.Regex.Posix.Wrap.N:ExecOption[0]))
                       r
                 } in
                 Data.List.Split.Internals.splitWhen
                   @ GHC.Types.Char
                   (\ (x1 :: GHC.Types.Char) ->
                    case rex of ww { Text.Regex.Posix.Wrap.Regex ww1 ww2 ww3 ->
                    Text.Regex.Posix.String.$w$cmatchTest
                      ww1
                      ww3
                      (GHC.Types.:
                         @ GHC.Types.Char
                         x1
                         (GHC.Types.[] @ GHC.Types.Char)) })
                   s) -}
13971efdce0fe9f79bc49c3d1be42e38
  splitStrT ::
    GHC.Base.String
    -> GHC.Base.String -> (GHC.Base.String, GHC.Base.String)
  {- Arity: 2, Strictness: <L,U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: GHC.Base.String) ->
                 case AronModule.$wsplitStrT w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
bca6b441a5d698f2a98a285aca3f1fc3
  sqVec ::
    GHC.Classes.Ord a => Data.Vector.Vector a -> Data.Vector.Vector a
  {- Arity: 2,
     Strictness: <L,U(A,A,C(C1(U)),A,C(C1(U)),A,A,A)><S(SSS),1*U(U,1*U,U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (w :: GHC.Classes.Ord a1) (w1 :: Data.Vector.Vector a1) ->
                 case w1 of ww { Data.Vector.Vector ww1 ww2 ww3 ->
                 AronModule.$wsqVec @ a1 w ww1 ww2 ww3 }) -}
46fce6e41efab3312bfa238c4caf2b5e
  sqrtC :: AronModule.C -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AronModule.C) ->
                 case AronModule.$wsqrtC w of ww { (#,#) ww1 ww2 ->
                 AronModule.C ww1 ww2 }) -}
e20e929715f88281866c036193afc7ef
  sqrtC' :: AronModule.C -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AronModule.C) ->
                 case AronModule.$wsqrtC' w of ww { (#,#) ww1 ww2 ->
                 AronModule.C ww1 ww2 }) -}
f0f81404158b41c2ff544d9ebad8b1fe
  strCompareIC ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: GHC.Base.String) (y1 :: GHC.Base.String) ->
                 GHC.Base.eqString
                   (AronModule.strCompareIC_go x1)
                   (AronModule.strCompareIC_go y1)) -}
db293ca6f03c4b342cb5e7c4fbb0b78b
  strCompareIC_go :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
b35519c018a4211df9f3eabe3deb2d3c
  strToLazyByteString ::
    GHC.Base.String -> Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.Lazy.Internal.packChars -}
78f3fcb1904b51b6d1a7ca0d4b7d3843
  strToLazyText :: GHC.Base.String -> Data.Text.Internal.Lazy.Text
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) Data.Text.Lazy.pack -}
a2160908f1fc7d0a83fbb3999c812b22
  strToStrictByteString ::
    GHC.Base.String -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x1 :: GHC.Base.String) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Text.Internal.Text #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         AronModule.$wouter1 ipv1 4# x1 0# ipv }) of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 Data.Text.Encoding.$wencodeUtf8 ww1 ww2 ww3 } }) -}
08ca6d6096162eab3c0aa67091ce171f
  strToStrictText :: GHC.Base.String -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) Data.Text.pack -}
8e34551b708b52528ae75039a0ad8bc3
  strictBSToString ::
    Data.ByteString.Internal.ByteString -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SLSS),1*U(U,U,U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.ByteString.Internal.ByteString) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 AronModule.$wstrictBSToString ww1 ww2 ww3 ww4 }) -}
f4428cbb85a7072bc57502232ee51b33
  strictByteStringToLazyByteString ::
    Data.ByteString.Internal.ByteString
    -> Data.ByteString.Lazy.Internal.ByteString
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.Lazy.fromStrict -}
240fd4fc7665d7d2c64268fadedfbe58
  strictByteStringToStrictText ::
    Data.ByteString.Internal.ByteString -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S(SLSS),1*U(U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Text.Encoding.decodeUtf8 -}
1e22b321012acd9633407c33b2cd44bf
  strictTextToLazyText ::
    Data.Text.Internal.Text -> Data.Text.Internal.Lazy.Text
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(U,U,1*U)>,
     Unfolding: InlineRule (0, True, True) Data.Text.Lazy.fromStrict -}
f0e9f32223c10490702fe7f0c87254ff
  strictTextToStr :: Data.Text.Internal.Text -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSS),1*U(U,U,U)>,
     Unfolding: InlineRule (0, True, True) Data.Text.Show.unpack -}
230ffaa3ce6c553b575bb88446fdf6ae
  strictTextToStrictByteString ::
    Data.Text.Internal.Text -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,1*U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Text.Encoding.encodeUtf8 -}
3d3ddbbbb008e6d8afd44c71c26580e3
  stringToInt :: GHC.Base.String -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case Text.Read.readEither8
                        @ GHC.Integer.Type.Integer
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Integer.Type.Integer
                           AronModule.stringToInt3
                           s) of wild {
                   [] -> AronModule.stringToInt2
                   : x1 ds
                   -> case ds of wild1 {
                        [] -> x1 : ipv ipv1 -> AronModule.stringToInt1 } }) -}
101fc096a2f8f0629b8e95c0aa34d637
  stringToInt1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
284cf1c5115912e34813398978fc4447
  stringToInt2 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
e89a6938b6b220c4037223a9d7b3247a
  stringToInt3 ::
    Text.ParserCombinators.ReadP.P GHC.Integer.Type.Integer
  {- Unfolding: (GHC.Read.$fReadInteger_$sreadNumber
                   GHC.Read.$fReadInteger2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Integer.Type.Integer
                   (Text.Read.readEither7 @ GHC.Integer.Type.Integer)) -}
6649a522679827d7f74932e87a345e4a
  subR :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (s1 :: GHC.Base.String) (s2 :: GHC.Base.String) ->
                 AronModule.addR s1 (AronModule.negR s2)) -}
3df324d2338a7f2936c67b0e0d281803
  subRL ::
    [GHC.Base.String] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (cx :: [GHC.Base.String]) (cs :: [GHC.Base.String]) ->
                 case cx of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ipv ipv1
                   -> case GHC.Base.build
                             @ [GHC.Types.Char]
                             (\ @ b1
                                (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                                (n :: b1)[OneShot] ->
                              GHC.Base.foldr
                                @ [GHC.Types.Char]
                                @ b1
                                (GHC.Base.mapFB
                                   @ [GHC.Types.Char]
                                   @ b1
                                   @ [GHC.Types.Char]
                                   c1
                                   AronModule.negR)
                                n
                                cs) of wild1 {
                        [] -> GHC.Types.[] @ GHC.Base.String
                        : ipv2 ipv3 -> AronModule.addRL_go2 wild wild1 } }) -}
2031694c3baa31a482f621949b353226
  sumLeft ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <S,U><S,1*U><S,1*U> -}
3f4fc16d4731a5c5bf0d0f1892d73953
  sumRatList :: [GHC.Base.String] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (cx :: [GHC.Base.String]) ->
                 letrec {
                   go29 :: [GHC.Base.String] -> GHC.Base.String -> GHC.Base.String
                     <join 2> {- Arity: 2 -}
                   = \ (ds :: [GHC.Base.String]) (eta :: GHC.Base.String) ->
                     case ds of wild {
                       [] -> eta : y1 ys -> go29 ys (AronModule.addR eta y1) }
                 } in
                 go29 cx AronModule.multiRatMat1) -}
5498d5485862dc3ba93421ed63d74f6c
  sumRight ::
    [[GHC.Integer.Type.Integer]]
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <S,U><S,1*U><S,1*U>,
     Unfolding: (\ (s :: [[GHC.Integer.Type.Integer]])
                   (c1 :: GHC.Integer.Type.Integer)
                   (r :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.integerToInt r of wild { DEFAULT ->
                 case GHC.Integer.Type.integerToInt c1 of wild1 { DEFAULT ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Integer.Type.Integer]
                        s
                        0# of ww2 { DEFAULT ->
                 letrec {
                   $wdown :: [[GHC.Integer.Type.Integer]]
                             -> GHC.Prim.Int# -> GHC.Types.Int -> GHC.Integer.Type.Integer
                     {- Arity: 3, Strictness: <L,U><S,U><L,1*U(U)>, Inline: [2] -}
                   = \ (w :: [[GHC.Integer.Type.Integer]])
                       (ww :: GHC.Prim.Int#)
                       (w1 :: GHC.Types.Int) ->
                     case GHC.Prim.<# ww ww2 of lwild {
                       DEFAULT -> AronModule.$fDnumDoubleInt1
                       1#
                       -> case w1 of wild2 { GHC.Types.I# x1 ->
                          case GHC.Prim.<# x1 ww2 of lwild1 {
                            DEFAULT -> AronModule.$fDnumDoubleInt1
                            1#
                            -> GHC.Integer.Type.plusInteger
                                 (GHC.List.$w!!
                                    @ GHC.Integer.Type.Integer
                                    (GHC.List.$w!! @ [GHC.Integer.Type.Integer] w ww)
                                    x1)
                                 ($wdown
                                    w
                                    (GHC.Prim.+# ww 1#)
                                    (GHC.Types.I# (GHC.Prim.+# x1 1#))) } } }
                 } in
                 GHC.Integer.Type.plusInteger
                   (GHC.Integer.Type.plusInteger
                      (GHC.List.$w!!
                         @ GHC.Integer.Type.Integer
                         (GHC.List.$w!! @ [GHC.Integer.Type.Integer] s wild1)
                         wild)
                      ($wdown
                         s
                         (GHC.Prim.+# wild1 1#)
                         (GHC.Types.I# (GHC.Prim.+# wild 1#))))
                   (AronModule.$wup1
                      s
                      (GHC.Prim.-# wild1 1#)
                      (GHC.Types.I# (GHC.Prim.-# wild 1#))) } } }) -}
d20b349072c0c2b6a9bf994a65b1562e
  sym :: AronModule.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d41dd639520c9fcf50a5f0c59547b554
  sys :: GHC.Base.String -> GHC.Types.IO GHC.IO.Exception.ExitCode
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.Process.system1
                  `cast`
                (<[GHC.Types.Char]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.IO.Exception.ExitCode>_R)) -}
be3248ad7eb05735823aefbb1f3e71b4
  t1 :: (a, b, c) -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 @ b1 @ c1 (ds :: (a1, b1, c1)) ->
                 case ds of wild { (,,) a2 b2 c2 -> a2 }) -}
37e3569d17303594ce3fe17f987de220
  t2 :: (a, b, c) -> b
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 @ b1 @ c1 (ds :: (a1, b1, c1)) ->
                 case ds of wild { (,,) a2 b2 c2 -> b2 }) -}
13f8cb72d1213c3ccdcf891eaed3f442
  t3 :: (a, b, c) -> c
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 @ b1 @ c1 (ds :: (a1, b1, c1)) ->
                 case ds of wild { (,,) a2 b2 c2 -> c2 }) -}
d5ed70709d769e61c9edd28e9b029ce1
  take' :: GHC.Real.Integral n => n -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLLLLLC(S)),1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,U><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ n @ a1 (w :: GHC.Real.Integral n) (w1 :: n) (w2 :: [a1]) ->
                 case w of ww { GHC.Real.C:Integral ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 AronModule.$wtake' @ n @ a1 ww9 w1 w2 }) -}
c165698855c4a8a133ec9c5cf23d8449
  takeBS ::
    GHC.Integer.Type.Integer
    -> Data.ByteString.Internal.ByteString
    -> Data.ByteString.Internal.ByteString
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,U,U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: Data.ByteString.Internal.ByteString) ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 case GHC.Integer.Type.integerToInt w of wild { DEFAULT ->
                 case GHC.Prim.<=# wild 0# of lwild {
                   DEFAULT
                   -> case GHC.Prim.>=# wild ww4 of lwild1 {
                        DEFAULT -> Data.ByteString.Internal.PS ww1 ww2 ww3 wild
                        1# -> Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 }
                   1#
                   -> Data.ByteString.Internal.PS
                        __NULL
                        Data.ByteString.Internal.$fMonoidByteString1
                        0#
                        0# } } }) -}
b91f39e13677626b1782fa3ea48301cf
  takeEnd :: GHC.Integer.Type.Integer -> [a] -> [a]
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ @ a1 (n :: GHC.Integer.Type.Integer) (s :: [a1]) ->
                 case GHC.List.$wlenAcc @ a1 s 0# of ww2 { DEFAULT ->
                 case GHC.Integer.Type.integerToInt
                        (GHC.Integer.Type.minusInteger
                           (GHC.Integer.Type.smallInteger ww2)
                           n) of wild { DEFAULT ->
                 case GHC.Prim.<=# wild 0# of lwild {
                   DEFAULT -> AronModule.$wunsafeDrop @ a1 wild s 1# -> s } } }) -}
eaf917b62d17243d7de86f9eb7e8b1cc
  takeFileNameT :: Data.Text.Internal.Text -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <L,1*U(U,U,U)>,
     Unfolding: (\ (s :: Data.Text.Internal.Text) ->
                 case System.FilePath.Posix.$wsplitFileName_
                        (case s of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                         let {
                           end :: GHC.Prim.Int# = GHC.Prim.+# dt1 dt2
                         } in
                         letrec {
                           $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                             {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                           = \ (ww :: GHC.Prim.Int#) ->
                             case GHC.Prim.>=# ww end of lwild {
                               DEFAULT
                               -> case GHC.Prim.indexWord16Array# dt ww of r# { DEFAULT ->
                                  case GHC.Prim.geWord# r# 55296## of lwild1 {
                                    DEFAULT
                                    -> GHC.Types.:
                                         @ GHC.Types.Char
                                         (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                         ($wunfold (GHC.Prim.+# ww 1#))
                                    1#
                                    -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                         DEFAULT
                                         -> GHC.Types.:
                                              @ GHC.Types.Char
                                              (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                              ($wunfold (GHC.Prim.+# ww 1#))
                                         1#
                                         -> case GHC.Prim.indexWord16Array#
                                                   dt
                                                   (GHC.Prim.+# ww 1#) of r#1 { DEFAULT ->
                                            GHC.Types.:
                                              @ GHC.Types.Char
                                              (GHC.Types.C#
                                                 (GHC.Prim.chr#
                                                    (GHC.Prim.+#
                                                       9216#
                                                       (GHC.Prim.+#
                                                          (GHC.Prim.uncheckedIShiftL#
                                                             (GHC.Prim.-#
                                                                (GHC.Prim.word2Int# r#)
                                                                55296#)
                                                             10#)
                                                          (GHC.Prim.word2Int# r#1)))))
                                              ($wunfold (GHC.Prim.+# ww 2#)) } } } }
                               1# -> GHC.Types.[] @ GHC.Types.Char }
                         } in
                         $wunfold dt1 }) of ww { (#,#) ww1 ww2 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Text.Internal.Text #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         AronModule.$wouter2
                           ipv1
                           4#
                           ww2
                           0#
                           ipv }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 } }) -}
d43418e6a52866ca3b83192371f59b54
  tangent :: GHC.Real.Fractional a => (a -> a) -> a -> a -> a
  {- Arity: 4,
     Strictness: <S(S(C(C(S))LLLLLL)LLL),1*U(1*U(C(C1(U)),C(C1(U)),1*C1(C1(U)),A,A,A,A),1*C1(C1(U)),A,1*C1(U))><L,C(U)><L,U><L,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ @ a1
                   (w :: GHC.Real.Fractional a1)
                   (w1 :: a1 -> a1)
                   (w2 :: a1)
                   (w3 :: a1) ->
                 case w of ww { GHC.Real.C:Fractional ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Num.C:Num ww6 ww7 ww8 ww9 ww10 ww11 ww12 ->
                 AronModule.$wtangent @ a1 ww6 ww7 ww8 ww2 ww4 w1 w2 w3 } }) -}
35cd6ccce93d811240a9a3eda0416604
  tangent1 :: GHC.Integer.Type.Integer -> a
  {- Unfolding: (\ @ a1 ->
                 Control.Exception.Base.absentError
                   @ (GHC.Integer.Type.Integer -> a1)
                   AronModule.tangent2) -}
6cc011035ae9d793a41eb50c38b52c0c
  tangent2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww Integer -> a"#) -}
176a56926cb743eec57f2cbefd0b8bcb
  tangent3 :: a -> a
  {- Unfolding: (\ @ a1 ->
                 Control.Exception.Base.absentError
                   @ (a1 -> a1)
                   AronModule.tangent4) -}
2ac53163d43b700943317124847a4af7
  tangent4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww a -> a"#) -}
f47fc1736d8f89990199289df6f8d293
  tangentVec :: GHC.Real.Fractional a => (a -> a) -> a -> a -> (a, a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A),1*C1(C1(U)),A,1*C1(U))><L,C(U)><L,A><L,U>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a1
                   ($dFractional :: GHC.Real.Fractional a1)
                   (f :: a1 -> a1)
                   (x1 :: a1)
                   (x0 :: a1) ->
                 (x0, AronModule.df @ a1 $dFractional f x0)) -}
9a8eaf05f9e2985041952acc822c41f8
  textArea ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U>,
     Unfolding: (\ (r :: GHC.Integer.Type.Integer)
                   (c1 :: GHC.Integer.Type.Integer)
                   (s :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   AronModule.textArea8
                   (GHC.Base.++
                      @ GHC.Types.Char
                      AronModule.textArea7
                      (GHC.CString.unpackAppendCString#
                         AronModule.textArea6
                         (case GHC.Show.$w$cshowsPrec4
                                 0#
                                 r
                                 (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                          GHC.Base.++_$s++
                            @ GHC.Types.Char
                            (GHC.CString.unpackAppendCString#
                               AronModule.textArea5
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  AronModule.textArea7
                                  (GHC.CString.unpackAppendCString#
                                     AronModule.textArea4
                                     (case GHC.Show.$w$cshowsPrec4
                                             0#
                                             c1
                                             (GHC.Types.[]
                                                @ GHC.Types.Char) of ww1 { (#,#) ww5 ww6 ->
                                      GHC.Base.++_$s++
                                        @ GHC.Types.Char
                                        (GHC.CString.unpackAppendCString#
                                           AronModule.textArea3
                                           (GHC.Base.++ @ GHC.Types.Char s AronModule.textArea1))
                                        ww5
                                        ww6 }))))
                            ww3
                            ww4 })))) -}
ed0842cfdbdca54aee0e1f2e1e877970
  textArea1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# AronModule.textArea2) -}
04384860f24d9ea95f97fd2c95a7f6b3
  textArea2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("</textarea>"#) -}
2c14e8ef4d6b13eeb3e598aefd9e9edc
  textArea3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\">"#) -}
ac791440ee7775d30e0a80f077becc4f
  textArea4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("cols=\""#) -}
53264c515d94573d96208b1061f864d0
  textArea5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\""#) -}
d693b5937fd4f73af552b4abb06caea8
  textArea6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("rows=\""#) -}
b225561ffebbff1ae091918c918148bc
  textArea7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   AronModule.compileHaskellToBin4) -}
cc49a838af218f7f1c8925cb29d01bdc
  textArea8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<textarea"#) -}
cfb8ee47b8a71129e07890eb5cca6d4a
  timeNowMicro :: GHC.Types.IO GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.timeNowMicro1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Integer.Type.Integer>_R)) -}
e8fa6c14dbe9218c34492dcdcb03c965
  timeNowMicro1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Integer.Type.Integer #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         Data.Time.Clock.Internal.CTimeval.$fStorableCTimeval7
                         Foreign.Storable.$fStorableDouble5
                         Data.Time.Clock.Internal.CTimeval.getCTimeval1
                           `cast`
                         (<GHC.Ptr.Ptr Data.Time.Clock.Internal.CTimeval.CTimeval>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Data.Time.Clock.Internal.CTimeval.MkCTimeval ds ds2 ->
                 (# ipv,
                    case ds
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of dt { GHC.Int.I64# dt1 ->
                    case ds2
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of wild1 { GHC.Int.I64# x# ->
                    case GHC.Real.$w$s$c/
                           (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.timesInteger
                                 (Data.Time.Clock.POSIX.$wsystemToPOSIXTime
                                    dt1
                                    (GHC.Prim.narrow32Word#
                                       (GHC.Prim.timesWord#
                                          (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# x#))
                                          1000##)))
                                 (AronModule.$s^
                                    AronModule.timeNowMicro2
                                      `cast`
                                    (Sym (Data.Fixed.N:Fixed[0]
                                              <Data.Fixed.E12>_P) ; Sym (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0]))
                                    AronModule.mat12)
                                   `cast`
                                 (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0] ; Data.Fixed.N:Fixed[0]
                                                                                                      <Data.Fixed.E12>_P))
                              Data.Fixed.$fHasResolutionE5)
                           GHC.Real.$fEnumRatio1
                           Data.Fixed.$fHasResolutionE5
                           GHC.Real.$fEnumRatio1 of ww6 { (#,#) ww7 ww8 ->
                    GHC.Real.$w$s$cround
                      @ GHC.Integer.Type.Integer
                      GHC.Real.$fIntegralInteger
                      ww7
                      ww8 } } } #) } }) -}
fc95bead2214f1075fc7bf12a370507c
  timeNowMicro2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (10000000000000) -}
946a7b1635edbbc631f0209e0da96b11
  timeNowMilli :: GHC.Types.IO GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.timeNowMilli1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Integer.Type.Integer>_R)) -}
c3e095b34e647d17e33172eb216ab05e
  timeNowMilli1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Integer.Type.Integer #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         Data.Time.Clock.Internal.CTimeval.$fStorableCTimeval7
                         Foreign.Storable.$fStorableDouble5
                         Data.Time.Clock.Internal.CTimeval.getCTimeval1
                           `cast`
                         (<GHC.Ptr.Ptr Data.Time.Clock.Internal.CTimeval.CTimeval>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Data.Time.Clock.Internal.CTimeval.MkCTimeval ds ds2 ->
                 (# ipv,
                    case ds
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of dt { GHC.Int.I64# dt1 ->
                    case ds2
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of wild1 { GHC.Int.I64# x# ->
                    case GHC.Real.$w$s$c/
                           (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.timesInteger
                                 (Data.Time.Clock.POSIX.$wsystemToPOSIXTime
                                    dt1
                                    (GHC.Prim.narrow32Word#
                                       (GHC.Prim.timesWord#
                                          (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# x#))
                                          1000##)))
                                 AronModule.timeNowMilli2)
                              Data.Fixed.$fHasResolutionE5)
                           GHC.Real.$fEnumRatio1
                           Data.Fixed.$fHasResolutionE5
                           GHC.Real.$fEnumRatio1 of ww6 { (#,#) ww7 ww8 ->
                    GHC.Real.$w$s$cround
                      @ GHC.Integer.Type.Integer
                      GHC.Real.$fIntegralInteger
                      ww7
                      ww8 } } } #) } }) -}
bc940c50547bc97f5923aacdc0190a09
  timeNowMilli2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1000000000000000) -}
c6cc4227e1ace3363e1dda1ac3b9ec83
  timeNowNano :: GHC.Types.IO GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.timeNowNano1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Integer.Type.Integer>_R)) -}
bea2863487f85550b441ed530d9e5887
  timeNowNano1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Integer.Type.Integer #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         Data.Time.Clock.Internal.CTimeval.$fStorableCTimeval7
                         Foreign.Storable.$fStorableDouble5
                         Data.Time.Clock.Internal.CTimeval.getCTimeval1
                           `cast`
                         (<GHC.Ptr.Ptr Data.Time.Clock.Internal.CTimeval.CTimeval>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Data.Time.Clock.Internal.CTimeval.MkCTimeval ds ds2 ->
                 (# ipv,
                    case ds
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of dt { GHC.Int.I64# dt1 ->
                    case ds2
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of wild1 { GHC.Int.I64# x# ->
                    case GHC.Real.$w$s$c/
                           (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.timesInteger
                                 (Data.Time.Clock.POSIX.$wsystemToPOSIXTime
                                    dt1
                                    (GHC.Prim.narrow32Word#
                                       (GHC.Prim.timesWord#
                                          (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# x#))
                                          1000##)))
                                 (AronModule.$s^
                                    AronModule.timeNowMicro2
                                      `cast`
                                    (Sym (Data.Fixed.N:Fixed[0]
                                              <Data.Fixed.E12>_P) ; Sym (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0]))
                                    AronModule.timeNowNano2)
                                   `cast`
                                 (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0] ; Data.Fixed.N:Fixed[0]
                                                                                                      <Data.Fixed.E12>_P))
                              Data.Fixed.$fHasResolutionE5)
                           GHC.Real.$fEnumRatio1
                           Data.Fixed.$fHasResolutionE5
                           GHC.Real.$fEnumRatio1 of ww6 { (#,#) ww7 ww8 ->
                    GHC.Real.$w$s$cround
                      @ GHC.Integer.Type.Integer
                      GHC.Real.$fIntegralInteger
                      ww7
                      ww8 } } } #) } }) -}
20c8b3415307870e0b68fc10c7c4fccd
  timeNowNano2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (9) -}
4abb8ab186f7e23d2a7d76e211b4b950
  timeNowPico :: GHC.Types.IO GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.timeNowPico1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Integer.Type.Integer>_R)) -}
c0467a0aba8581c7774a085170aabcdb
  timeNowPico1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Integer.Type.Integer #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         Data.Time.Clock.Internal.CTimeval.$fStorableCTimeval7
                         Foreign.Storable.$fStorableDouble5
                         Data.Time.Clock.Internal.CTimeval.getCTimeval1
                           `cast`
                         (<GHC.Ptr.Ptr Data.Time.Clock.Internal.CTimeval.CTimeval>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Data.Time.Clock.Internal.CTimeval.MkCTimeval ds ds2 ->
                 (# ipv,
                    case ds
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of dt { GHC.Int.I64# dt1 ->
                    case ds2
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of wild1 { GHC.Int.I64# x# ->
                    case GHC.Real.$w$s$c/
                           (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.timesInteger
                                 (Data.Time.Clock.POSIX.$wsystemToPOSIXTime
                                    dt1
                                    (GHC.Prim.narrow32Word#
                                       (GHC.Prim.timesWord#
                                          (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# x#))
                                          1000##)))
                                 (AronModule.$s^
                                    AronModule.timeNowMicro2
                                      `cast`
                                    (Sym (Data.Fixed.N:Fixed[0]
                                              <Data.Fixed.E12>_P) ; Sym (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0]))
                                    AronModule.timeNowPico2)
                                   `cast`
                                 (Data.Time.Clock.Internal.NominalDiffTime.N:NominalDiffTime[0] ; Data.Fixed.N:Fixed[0]
                                                                                                      <Data.Fixed.E12>_P))
                              Data.Fixed.$fHasResolutionE5)
                           GHC.Real.$fEnumRatio1
                           Data.Fixed.$fHasResolutionE5
                           GHC.Real.$fEnumRatio1 of ww6 { (#,#) ww7 ww8 ->
                    GHC.Real.$w$s$cround
                      @ GHC.Integer.Type.Integer
                      GHC.Real.$fIntegralInteger
                      ww7
                      ww8 } } } #) } }) -}
07411ed6c49e6dd8286e39675978a043
  timeNowPico2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (12) -}
7faf96bc168a733a98ef3a8025062b25
  timeNowSecond :: GHC.Types.IO GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.timeNowSecond1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <GHC.Integer.Type.Integer>_R)) -}
163f21767616ce6518e45fc89ed4e1e8
  timeNowSecond1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Integer.Type.Integer #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         @ Data.Time.Clock.Internal.CTimeval.CTimeval
                         Data.Time.Clock.Internal.CTimeval.$fStorableCTimeval7
                         Foreign.Storable.$fStorableDouble5
                         Data.Time.Clock.Internal.CTimeval.getCTimeval1
                           `cast`
                         (<GHC.Ptr.Ptr Data.Time.Clock.Internal.CTimeval.CTimeval>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <Data.Time.Clock.Internal.CTimeval.CTimeval>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Data.Time.Clock.Internal.CTimeval.MkCTimeval ds ds2 ->
                 (# ipv,
                    case ds
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of dt { GHC.Int.I64# dt1 ->
                    case ds2
                           `cast`
                         (Foreign.C.Types.N:CLong[0]) of wild1 { GHC.Int.I64# x# ->
                    case GHC.Real.$w$s$c/
                           (GHC.Integer.Type.divInteger
                              (GHC.Integer.Type.timesInteger
                                 (Data.Time.Clock.POSIX.$wsystemToPOSIXTime
                                    dt1
                                    (GHC.Prim.narrow32Word#
                                       (GHC.Prim.timesWord#
                                          (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# x#))
                                          1000##)))
                                 AronModule.$s^2)
                              Data.Fixed.$fHasResolutionE5)
                           GHC.Real.$fEnumRatio1
                           Data.Fixed.$fHasResolutionE5
                           GHC.Real.$fEnumRatio1 of ww6 { (#,#) ww7 ww8 ->
                    GHC.Real.$w$s$cround
                      @ GHC.Integer.Type.Integer
                      GHC.Real.$fIntegralInteger
                      ww7
                      ww8 } } } #) } }) -}
b19a6857d3c798d284c39202c143204d
  toCard :: (GHC.Types.Float, GHC.Types.Float) -> AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U(U),U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Types.Float, GHC.Types.Float)) ->
                 case w of ww { (,) ww1 ww2 ->
                 AronModule.C
                   (case ww1 of wild { GHC.Types.F# x1 ->
                    case ww2 of wild1 { GHC.Types.F# x2 ->
                    GHC.Types.F# (GHC.Prim.timesFloat# x1 (GHC.Prim.cosFloat# x2)) } })
                   (case ww1 of wild { GHC.Types.F# x1 ->
                    case ww2 of wild1 { GHC.Types.F# x2 ->
                    GHC.Types.F#
                      (GHC.Prim.timesFloat# x1 (GHC.Prim.sinFloat# x2)) } }) }) -}
31a27fce61b46e56bccd3354fec25e86
  toLowerStr :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 AronModule.toLowerStr_go s) -}
c34f045b49bae41c343566b2387092c8
  toLowerStr_go :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
5ce72c335fd1d824b38c91dfee960f8d
  toPolar :: AronModule.C -> (GHC.Types.Float, GHC.Types.Float)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AronModule.C) ->
                 case w of ww { AronModule.C ww1 ww2 ->
                 let {
                   r :: GHC.Types.Float
                   = case ww1 of wild { GHC.Types.F# x1 ->
                     case ww2 of wild1 { GHC.Types.F# x2 ->
                     GHC.Types.F#
                       (GHC.Prim.sqrtFloat#
                          (GHC.Prim.plusFloat#
                             (GHC.Prim.timesFloat# x1 x1)
                             (GHC.Prim.timesFloat# x2 x2))) } }
                 } in
                 (r,
                  case ww1 of wild { GHC.Types.F# x1 ->
                  case r of wild1 { GHC.Types.F# y1 ->
                  case GHC.Prim.divideFloat# x1 y1 of wild2 { DEFAULT ->
                  case GHC.Prim.acosFloat# wild2 of wild4 { DEFAULT ->
                  GHC.Types.F# wild4 } } } }) }) -}
568d90714edce58a2afb0f407a80515f
  toStrictBS ::
    Data.ByteString.Lazy.Internal.ByteString
    -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Data.ByteString.Lazy.Internal.ByteString) ->
                 Data.ByteString.concat (Data.ByteString.Lazy.toChunks_go x1)) -}
25e8eab2d96e27edc70e1f9ae2702904
  toUpperStr :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 AronModule.strCompareIC_go s) -}
a7d4c4159b345fcfbe839affcac36325
  tran :: [[a]] -> [[a]]
  {- Arity: 1, Strictness: <S,1*U> -}
1f654cfd5580b29e1f8a1177b0282ff1
  tri ::
    AronModule.C -> (GHC.Types.Float, GHC.Types.Float, GHC.Types.Float)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U(U),U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: AronModule.C) ->
                 case w of ww { AronModule.C ww1 ww2 ->
                 let {
                   r :: GHC.Types.Float
                   = case ww1 of wild { GHC.Types.F# x1 ->
                     case ww2 of wild1 { GHC.Types.F# x2 ->
                     GHC.Types.F#
                       (GHC.Prim.sqrtFloat#
                          (GHC.Prim.plusFloat#
                             (GHC.Prim.timesFloat# x1 x1)
                             (GHC.Prim.timesFloat# x2 x2))) } }
                 } in
                 (r,
                  case ww1 of wild { GHC.Types.F# x1 ->
                  case r of wild1 { GHC.Types.F# y1 ->
                  case GHC.Prim.divideFloat# x1 y1 of wild2 { DEFAULT ->
                  GHC.Types.F# (GHC.Prim.cosFloat# wild2) } } },
                  case ww2 of wild { GHC.Types.F# x1 ->
                  case r of wild1 { GHC.Types.F# y1 ->
                  case GHC.Prim.divideFloat# x1 y1 of wild2 { DEFAULT ->
                  GHC.Types.F# (GHC.Prim.sinFloat# wild2) } } }) }) -}
3d2d8a406d2f771c7c8f87e12b29390e
  trim :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
367352cd05ae00e6ef42ded4fb586adf
  trimAll :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) AronModule.trimWS -}
5f4608314877b779dc2875e9b58344a1
  trimBoth :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True) AronModule.trim -}
958263445bfe286775a48e087dc1f304
  trimEnd :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) -> AronModule.trimEnd_go s) -}
240fce48e120093e38daa39df9934c42
  trimEnd_go :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
08cc76830b2d1a62976c2a35097739b6
  trimStart :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.List.dropWhile
                   @ GHC.Types.Char
                   GHC.Unicode.isSpace) -}
87e487b858764b01cb07c1b278ef6c86
  trimT :: Data.Text.Internal.Text -> Data.Text.Internal.Text
  {- Arity: 1, Strictness: <S(LLS),1*U(U,U,U)>,
     Unfolding: InlineRule (0, True, True) Data.Text.strip -}
5cc9b1a49b2a831ef63a0d06974de4e1
  trimWS :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Char]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> GHC.Base.build
                        @ GHC.Types.Char
                        (\ @ b1
                           (c1 :: GHC.Types.Char -> b1 -> b1)[OneShot]
                           (n :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b1
                           (GHC.List.filterFB @ GHC.Types.Char @ b1 c1 AronModule.trimWS1)
                           n
                           wild) }) -}
14e85ff900afae10162bf1bb03456661
  trimWS1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Char) ->
                 case w of ww { GHC.Types.C# ww1 -> AronModule.$wlvl1 ww1 }) -}
e25359b05bca711185cec0b9a096200d
  tuplify1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("src/AronModule.hs:795:1-24|function tuplify2"#) -}
4b36d89ad6f83b67f7ba275026a7ea07
  tuplify2 :: [a] -> (a, a)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 (w :: [a1]) ->
                 case w of wild {
                   []
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ (a1, a1)
                        AronModule.tuplify1
                   : a2 ds
                   -> case ds of wild1 {
                        []
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ (a1, a1)
                             AronModule.tuplify1
                        : b1 ds1
                        -> case ds1 of wild2 {
                             [] -> (a2, b1)
                             : ipv ipv1
                             -> Control.Exception.Base.patError
                                  @ 'GHC.Types.LiftedRep
                                  @ (a1, a1)
                                  AronModule.tuplify1 } } }) -}
8784cc448880751e125d7b5505b49f4a
  tuplify3 :: [a] -> (a, a, a)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 (w :: [a1]) ->
                 case w of wild {
                   [] -> case AronModule.tuplify5 ret_ty (a1, a1, a1) of {}
                   : a2 ds
                   -> case ds of wild1 {
                        [] -> case AronModule.tuplify5 ret_ty (a1, a1, a1) of {}
                        : b1 ds1
                        -> case ds1 of wild2 {
                             [] -> case AronModule.tuplify5 ret_ty (a1, a1, a1) of {}
                             : c1 ds2
                             -> case ds2 of wild3 {
                                  [] -> (a2, b1, c1)
                                  : ipv ipv1
                                  -> case AronModule.tuplify5 ret_ty (a1, a1, a1) of {} } } } }) -}
bcbb54d22ba08077652eb88a786f9d94
  tuplify5 :: (a, a, a)
  {- Strictness: x -}
b60ce8ae287b7949bd7149e6dc75f1e5
  unique :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2,
     Strictness: <L,U(A,C(C1(U)),A,A,A,C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 ($dOrd :: GHC.Classes.Ord a1) (xs :: [a1]) ->
                 Data.Set.Internal.$fDataSet_go
                   @ a1
                   (GHC.Types.[] @ a1)
                   (Data.Set.Internal.fromList @ a1 $dOrd xs)) -}
7128d82c3cfb5c845e0e1a76c4bfb6ab
  unwrap :: GHC.Maybe.Maybe a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 (ds :: GHC.Maybe.Maybe a1) ->
                 case ds of wild {
                   GHC.Maybe.Nothing -> AronModule.unwrap1 @ a1
                   GHC.Maybe.Just x1 -> x1 }) -}
420be721fc5811abf6fa6181c6fdd58c
  unwrap1 :: a
  {- Strictness: x -}
4e3e61ad2071266a7caea5e8bbf0aa64
  upperTri ::
    [[GHC.Integer.Type.Integer]] -> [[GHC.Integer.Type.Integer]]
  {- Arity: 1, Strictness: <S,1*U> -}
bb65d94c4b604bc252c9311deb2508a0
  upperTri' :: [[GHC.Real.Rational]] -> [[GHC.Real.Rational]]
  {- Arity: 1, Strictness: <S,1*U> -}
c53b3d3e34b43b5d352a4de49f4f7171
  uptri :: [[a]] -> [[a]]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 (w :: [[a1]]) ->
                 case AronModule.$wuptri @ a1 w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ [a1] ww1 ww2 }) -}
fded7455fbdfdd89c5649612ac429200
  vcol :: [[a]] -> GHC.Types.Int -> [[a]]
  {- Arity: 2, Strictness: <L,1*U><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (m :: [[a1]]) (n :: GHC.Types.Int) ->
                 AronModule.tran
                   @ a1
                   (AronModule.vrow @ a1 (AronModule.tran @ a1 m) n)) -}
48edfac769578d66ce3cda87df4d5f1c
  vimLink :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.vimLink1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
090a2c185c79e0c0d05fc236627492a9
  vimLink1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
fdb649c9d1410a4dbb9e3fe9b8f22d26
  vrow :: [[a]] -> GHC.Types.Int -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a1 (w :: [[a1]]) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 AronModule.$wvrow @ a1 w ww1 }) -}
cdf3853bb94caa4c757dbf76f38daa5c
  watchDir :: GHC.IO.FilePath -> GHC.Types.IO GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.watchDir1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R)) -}
9d988805638424266751bb431dffe9d6
  watchDir1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case AronModule.dirModified3 p1 eta of ds1 { (#,#) ipv ipv1 ->
                 case AronModule.dirModified2 ipv1 ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case {__pkg_ccall base-4.12.0.0 GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       GHC.Prim.Int# #)}
                        GHC.Prim.realWorld# of wild { (#,#) ds ds3 ->
                 case ds3 of wild1 {
                   DEFAULT
                   -> case GHC.Event.Thread.threadDelay1
                             AronModule.watchDir2
                             ipv2 of ds4 { (#,#) ipv4 ipv5 ->
                      case AronModule.dirModified2 ipv1 ipv4 of ds5 { (#,#) ipv6 ipv7 ->
                      (# ipv6, AronModule.watchDir_go2 ipv3 ipv7 #) } }
                   0#
                   -> case GHC.Prim.delay#
                             @ GHC.Prim.RealWorld
                             1000000#
                             ipv2 of s' { DEFAULT ->
                      case AronModule.dirModified2 ipv1 s' of ds4 { (#,#) ipv4 ipv5 ->
                      (# ipv4, AronModule.watchDir_go2 ipv3 ipv5 #) } } } } } }) -}
a59825e21b7acdb2dbf158831d817972
  watchDir2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.I# 1000000#) -}
c44bbe675f792a7c45fcbfdda527a25a
  watchDir_go2 ::
    [Foreign.C.Types.CTime]
    -> [Foreign.C.Types.CTime] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
2ba6f59bdc1dbe0bf3b3186163b366f6
  wf :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                System.IO.writeFile1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
e7a46cf135a219fb5e7af4b37771dd98
  wfs :: GHC.IO.FilePath -> [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.wfs1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
e10a628d0449c39229a565f8dac0d13a
  wfs1 ::
    GHC.IO.FilePath
    -> [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (list :: [GHC.Base.String])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.IO.appendFile2
                   @ ()
                   p1
                   GHC.IO.IOMode.WriteMode
                   (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot] ->
                    GHC.IO.Handle.Text.hPutStr'
                      hdl
                      (Data.OldList.unlines list)
                      GHC.Types.False)
                   eta) -}
f4bbc6d558729e502c00bb03ca0aea96
  word :: GHC.Base.String -> (GHC.Base.String, GHC.Base.String)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Base.String) ->
                 case AronModule.$wword w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
31c6dcaac1ff661b20d054cb14730ac0
  writeFileBS ::
    GHC.IO.FilePath
    -> Data.ByteString.Internal.ByteString -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U(U,U,U,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Data.ByteString.writeFile1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <Data.ByteString.Internal.ByteString>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
34e44e484a10297826779721a4e072fc
  writeFileList ::
    GHC.IO.FilePath -> [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.wfs1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
1e0f6c8e2f19622008fc0f496c0d6ada
  writeFileListBS ::
    GHC.IO.FilePath
    -> [Data.ByteString.Internal.ByteString] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.writeFileListBS1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[Data.ByteString.Internal.ByteString]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
bc840de05715239b7de25f967d636b53
  writeFileListBS1 ::
    GHC.IO.FilePath
    -> [Data.ByteString.Internal.ByteString]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (cs :: [Data.ByteString.Internal.ByteString])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.IO.withBinaryFile1
                   @ ()
                   p1
                   GHC.IO.IOMode.WriteMode
                   (\ (ds :: GHC.IO.Handle.Types.Handle)[OneShot]
                      (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                    case Data.ByteString.concat
                           cs of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                    Data.ByteString.$whPut ds ww1 ww2 ww3 ww4 eta1 })
                     `cast`
                   (<GHC.IO.Handle.Types.Handle>_R
                    ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                   eta) -}
aa955bdefaa228139ae292ccef0b3157
  writeToFile ::
    GHC.IO.FilePath -> [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.wfs1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
98e9870bc5ad0dfd56243e27b75e620e
  writeToFile2dMat ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Show.Show a) =>
    GHC.IO.FilePath -> [[a]] -> GHC.Types.IO ()
  {- Arity: 6, Strictness: <L,A><L,A><L,U(A,C(U),A)><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.writeToFile2dMat1
                  `cast`
                (forall (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <GHC.Real.Fractional a1>_R
                 ->_R <GHC.Show.Show a1>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R <[[a1]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
9362f4de027bb02e3fb330489b549867
  writeToFile2dMat1 ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Show.Show a) =>
    GHC.IO.FilePath
    -> [[a]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 6, Strictness: <L,A><L,A><L,U(A,C(U),A)><L,U><L,U><S,U>,
     Inline: [2],
     Unfolding: InlineRule (6, True, True)
                (\ @ a1
                   (w :: GHC.Num.Num a1)
                   (w1 :: GHC.Real.Fractional a1)
                   (w2 :: GHC.Show.Show a1)
                   (w3 :: GHC.IO.FilePath)
                   (w4 :: [[a1]])
                   (w5 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 AronModule.$wwriteToFile2dMat @ a1 w2 w3 w4 w5) -}
b0206612d5a424624d74221b3ded9035
  writeToFile2dMat2 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (r :: [[GHC.Types.Char]]) ->
                 AronModule.writeToFile2dMat_go r) -}
1166a67895e2340928a8eb69e825e456
  writeToFile2dMat_go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e12480b6839fb665889df4ed22176099
  writeToFileAppend ::
    GHC.IO.FilePath -> [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.writeToFileAppend1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
4eba98ebb14802aa91b88ea039e29778
  writeToFileAppend1 ::
    GHC.IO.FilePath
    -> [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,1*U><S,U>,
     Unfolding: (\ (f :: GHC.IO.FilePath)
                   (list :: [GHC.Base.String])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.IO.appendFile2
                   @ ()
                   f
                   GHC.IO.IOMode.AppendMode
                   (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot] ->
                    GHC.IO.Handle.Text.hPutStr'
                      hdl
                      (Data.OldList.unlines list)
                      GHC.Types.False)
                   eta) -}
253480c57806606b861717254e6f5a75
  writeToFileMat ::
    GHC.IO.FilePath -> [[GHC.Base.String]] -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                AronModule.writeToFileMat1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <[[GHC.Base.String]]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
1173e9851a530bb248624df7d5d45d29
  writeToFileMat1 ::
    GHC.IO.FilePath
    -> [[GHC.Base.String]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (p1 :: GHC.IO.FilePath)
                   (m2 :: [[GHC.Base.String]])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 System.IO.appendFile2
                   @ ()
                   p1
                   GHC.IO.IOMode.WriteMode
                   (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot] ->
                    GHC.IO.Handle.Text.hPutStr'
                      hdl
                      (Data.OldList.unlines
                         (GHC.Base.map
                            @ [[GHC.Types.Char]]
                            @ [GHC.Types.Char]
                            AronModule.writeToFileMat2
                            (AronModule.ppad_$sppad m2)))
                      GHC.Types.False)
                   eta) -}
2d66a5b45ad75b6ad5645a1f639ce965
  writeToFileMat2 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (r :: [[GHC.Types.Char]]) ->
                 AronModule.writeToFileMat_go r) -}
969579fb19b2a27ac9c8bba558f99f5f
  writeToFileMat_go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
333978fdd88953d8934bc07531783829
  x :: AronModule.C -> GHC.Types.Float
  RecSel Left AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C ds1 ds2 -> ds1 }) -}
333978fdd88953d8934bc07531783829
  y :: AronModule.C -> GHC.Types.Float
  RecSel Left AronModule.C
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: AronModule.C) ->
                 case ds of wild { AronModule.C ds1 ds2 -> ds2 }) -}
2f3156315d82244d842b72e63f7a94b2
  zipWith2 ::
    GHC.Num.Num a => (a -> a -> a) -> [[a]] -> [[a]] -> [[a]]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,C(C1(U))><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (4, True, True)
                (\ @ a1
                   (w :: GHC.Num.Num a1)
                   (w1 :: a1 -> a1 -> a1)
                   (w2 :: [[a1]])
                   (w3 :: [[a1]]) ->
                 AronModule.$wzipWith2 @ a1 w1 w2 w3) -}
instance AronModule.Add [GHC.Types.Double, GHC.Types.Int]
  = AronModule.$fAddDoubleInt
instance AronModule.Add [GHC.Types.Double,
                         GHC.Integer.Type.Integer]
  = AronModule.$fAddDoubleInteger
instance AronModule.Add [GHC.Types.Int, GHC.Types.Double]
  = AronModule.$fAddIntDouble
instance AronModule.Add [GHC.Integer.Type.Integer,
                         GHC.Types.Double]
  = AronModule.$fAddIntegerDouble
instance AronModule.Add [., .] = AronModule.$fAddaa
instance AronModule.Cnum [GHC.Types.Double]
  = AronModule.$fCnumDouble
instance AronModule.Cnum [GHC.Types.Float] = AronModule.$fCnumFloat
instance AronModule.Cnum [GHC.Types.Int] = AronModule.$fCnumInt
instance AronModule.Cnum [GHC.Integer.Type.Integer]
  = AronModule.$fCnumInteger
instance AronModule.Dnum [GHC.Types.Double, GHC.Types.Int]
  = AronModule.$fDnumDoubleInt
instance AronModule.Dnum [GHC.Types.Double,
                          GHC.Integer.Type.Integer]
  = AronModule.$fDnumDoubleInteger
instance AronModule.Dnum [GHC.Types.Float, GHC.Types.Int]
  = AronModule.$fDnumFloatInt
instance AronModule.Dnum [GHC.Types.Float,
                          GHC.Integer.Type.Integer]
  = AronModule.$fDnumFloatInteger
instance AronModule.Dnum [GHC.Types.Int, GHC.Types.Float]
  = AronModule.$fDnumIntFloat
instance AronModule.Dnum [GHC.Integer.Type.Integer,
                          GHC.Types.Double]
  = AronModule.$fDnumIntegerDouble
instance AronModule.Dnum [GHC.Integer.Type.Integer,
                          GHC.Types.Float]
  = AronModule.$fDnumIntegerFloat
instance GHC.Classes.Eq [AronModule.C] = AronModule.$fEqC
instance GHC.Classes.Eq [AronModule.Tree] = AronModule.$fEqTree
instance GHC.Classes.Eq [AronModule.XNode] = AronModule.$fEqXNode
instance GHC.Num.Num [AronModule.C] = AronModule.$fNumC
instance GHC.Num.Num [AronModule.Quaternion]
  = AronModule.$fNumQuaternion
instance [orphan] GHC.Num.Num [[]] = AronModule.$fNum[]
instance GHC.Show.Show [AronModule.C] = AronModule.$fShowC
instance GHC.Show.Show [AronModule.Quaternion]
  = AronModule.$fShowQuaternion
instance GHC.Show.Show [AronModule.Tree] = AronModule.$fShowTree
instance GHC.Show.Show [AronModule.XNode] = AronModule.$fShowXNode
family instance AronModule.DivType [GHC.Integer.Type.Integer],
                                   [GHC.Types.Float]
  = AronModule.D:R:DivTypeIntegerFloat
family instance AronModule.DivType [GHC.Types.Float],
                                   [GHC.Integer.Type.Integer]
  = AronModule.D:R:DivTypeFloatInteger
family instance AronModule.DivType [GHC.Types.Int],
                                   [GHC.Types.Float]
  = AronModule.D:R:DivTypeIntFloat
family instance AronModule.DivType [GHC.Types.Float],
                                   [GHC.Types.Int]
  = AronModule.D:R:DivTypeFloatInt
family instance AronModule.DivType [GHC.Types.Double],
                                   [GHC.Types.Int]
  = AronModule.D:R:DivTypeDoubleInt
family instance AronModule.DivType [GHC.Types.Double],
                                   [GHC.Integer.Type.Integer]
  = AronModule.D:R:DivTypeDoubleInteger
family instance AronModule.DivType [GHC.Integer.Type.Integer],
                                   [GHC.Types.Double]
  = AronModule.D:R:DivTypeIntegerDouble
family instance AronModule.SumTy [GHC.Integer.Type.Integer],
                                 [GHC.Types.Double]
  = AronModule.D:R:SumTyIntegerDouble
family instance AronModule.SumTy [GHC.Types.Double],
                                 [GHC.Integer.Type.Integer]
  = AronModule.D:R:SumTyDoubleInteger
family instance AronModule.SumTy [GHC.Types.Double],
                                 [GHC.Types.Int]
  = AronModule.D:R:SumTyDoubleInt
family instance AronModule.SumTy [GHC.Types.Int],
                                 [GHC.Types.Double]
  = AronModule.D:R:SumTyIntDouble
family instance AronModule.SumTy [.], [.] = AronModule.D:R:SumTyaa
"SPEC listDots @ Double" forall ($dNum :: GHC.Num.Num
                                            GHC.Types.Double)
  AronModule.listDots @ GHC.Types.Double $dNum
  = AronModule.listDots_$slistDots
"SPEC mergeSortM @ Integer" forall ($dEq :: GHC.Classes.Eq
                                              GHC.Integer.Type.Integer)
                                   ($dNum :: GHC.Num.Num GHC.Integer.Type.Integer)
  AronModule.mergeSortM @ GHC.Integer.Type.Integer $dNum $dEq
  = AronModule.mergeSortM_$smergeSortM1
"SPEC mergeSortM @ Rational" forall ($dEq :: GHC.Classes.Eq
                                               GHC.Real.Rational)
                                    ($dNum :: GHC.Num.Num GHC.Real.Rational)
  AronModule.mergeSortM @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                        $dNum
                        $dEq
  = AronModule.mergeSortM_$smergeSortM
"SPEC normList @ Double" forall ($dFloating :: GHC.Float.Floating
                                                 GHC.Types.Double)
  AronModule.normList @ GHC.Types.Double $dFloating
  = AronModule.normList_$snormList
"SPEC ppad @ String" forall ($dShow :: GHC.Show.Show
                                         GHC.Base.String)
  AronModule.ppad @ [GHC.Types.Char] $dShow = AronModule.ppad_$sppad
"SPEC projn @ Double" forall ($dFractional :: GHC.Real.Fractional
                                                GHC.Types.Double)
  AronModule.projn @ GHC.Types.Double $dFractional
  = AronModule.projn_$sprojn
"SPEC rMatrixUpperTri @ Double" forall ($dNum :: GHC.Num.Num
                                                   GHC.Types.Double)
  AronModule.rMatrixUpperTri @ GHC.Types.Double $dNum
  = AronModule.qrDecompose'_$srMatrixUpperTri
"SPEC rejection @ Double" forall ($dFractional :: GHC.Real.Fractional
                                                    GHC.Types.Double)
  AronModule.rejection @ GHC.Types.Double $dFractional
  = AronModule.qrDecompose'_$srejection
"SPEC rep2d @ Integer @ Integer _" forall @ a1
                                          ($dIntegral :: GHC.Real.Integral GHC.Integer.Type.Integer)
                                          ($dIntegral1 :: GHC.Real.Integral
                                                            GHC.Integer.Type.Integer)
  AronModule.rep2d @ GHC.Integer.Type.Integer
                   @ GHC.Integer.Type.Integer
                   @ a1
                   $dIntegral1
                   $dIntegral
  = AronModule.rep2d_$srep2d @ a1
"SPEC/AronModule $wupdateOrSnocWithKey @ String _" [orphan] [2] forall @ v
                                                                       (w :: GHC.Classes.Eq
                                                                               GHC.Base.String)
  Data.HashMap.Base.$wupdateOrSnocWithKey @ [GHC.Types.Char] @ v w
  = AronModule.$s$wupdateOrSnocWithKey1 @ v
"SPEC/AronModule ^ @ POSIXTime @ Integer" [orphan] [1] forall ($dIntegral :: GHC.Real.Integral
                                                                               GHC.Integer.Type.Integer)
                                                              ($dNum :: GHC.Num.Num
                                                                          Data.Time.Clock.Internal.POSIXTime.POSIXTime)
  GHC.Real.^ @ Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
             @ GHC.Integer.Type.Integer
             $dNum
             $dIntegral
  = AronModule.$s^
"SPEC/AronModule fromIntegral @ Integer @ Integer" [orphan] [1] forall (w1 :: GHC.Num.Num
                                                                                GHC.Integer.Type.Integer)
                                                                       (w :: GHC.Real.Integral
                                                                               GHC.Integer.Type.Integer)
  GHC.Real.fromIntegral @ GHC.Integer.Type.Integer
                        @ GHC.Integer.Type.Integer
                        w
                        w1
  = AronModule.$sfromIntegral
"SPEC/AronModule fromList @ String" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                GHC.Base.String)
  Data.Set.Internal.fromList @ [GHC.Types.Char] $dOrd
  = AronModule.$sfromList
"SPEC/AronModule lookup# @ [Char] _" [orphan] forall @ v
                                                     ($dHashable :: Data.Hashable.Class.Hashable
                                                                      [GHC.Types.Char])
                                                     ($dEq :: GHC.Classes.Eq [GHC.Types.Char])
  Data.HashMap.Base.lookup# @ [GHC.Types.Char] @ v $dEq $dHashable
  = AronModule.$slookup# @ v
"SPEC/AronModule simpleHttp @ IO" [orphan] [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                              GHC.Types.IO)
  Network.HTTP.Conduit.simpleHttp @ GHC.Types.IO w
  = AronModule.$ssimpleHttp
"SPEC/AronModule unsafeInsert @ String _" [orphan] forall @ v
                                                          ($dHashable :: Data.Hashable.Class.Hashable
                                                                           GHC.Base.String)
                                                          ($dEq :: GHC.Classes.Eq GHC.Base.String)
  Data.HashMap.Base.unsafeInsert @ [GHC.Types.Char]
                                 @ v
                                 $dEq
                                 $dHashable
  = AronModule.$sunsafeInsert @ v
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

